

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>9.1 Interpolation &amp; Quadrature 2 &#8212; Modelling and Numerical Methods</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Chapter9/Lecture 9.1 - interpolation quadrature';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Homework" href="Homework.html" />
    <link rel="prev" title="9. Interpolation Quadrature 2" href="intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Modelling and Numerical Methods
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Part 1 - Analytical Background</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter1/intro.html">1. Intro to Vector/Tensor Calculus</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/Lecture%201.1%20-%20Intro%20to%20Vectors.html">1.1 Continuum Mechanics and Vector Calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/Lecture%201.2%20-%20Vector%20Transformations.html">1.2 Vector Transformations  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/Lecture%201.3%20-%20Intro%20to%20Tensors.html">1.3 Intro to Tensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/exercises.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/solutions.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter2/intro.html">2. Stress Tensor</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter2/Lecture%202%20-%20Stress%20and%20Tensors.html">2.1 Stress and Tensors  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter2/exercises2.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter2/solutions2.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter3/intro.html">3. Kinematics and Strain</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter3/Lecture%203%20-%20Kinematics.html">3.1 Kinematics   <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter3/exercises3.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter3/solutions3.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter4/intro.html">4. Conservation Equations</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/Lecture%204.1%20-%20Conservation%20Equations.html">4.1 Conservation Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/Lecture%204.2%20-%20Rheology.html">4.2 Rheology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/exercises4.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/solutions4.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter5/intro.html">5. Dimensional Analysis</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter5/Lecture%205%20-%20Dimensions%20and%20Dimensional%20Analysis.html">5.1 Dimensions and Dimensional Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter5/Worksheet.html">Worksheet  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter5/Solutions.html">Solutions  <a class="tocSkip"></a></a></li>

</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part 2 - Numerical Solutions</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter6/intro.html">6. Potential Flow</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter6/Lecture%206%20-%20Potential%20Flow.html">6.1 Potential Flow  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter6/Worksheet.html">Worksheet  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter6/Solutions.html">Solutions  <a class="tocSkip"></a></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter7/intro.html">7. Navier-Stokes</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter7/Lecture%207.1%20-%20Navier-Stokes.html">7.1 Solving Navier-Stokes Numerically</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter7/Worksheet.html">Worksheet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter7/SolversIntro.html">Solvers</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter8/intro.html">8. Turbulence and Non-Newtonian Flows</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter8/Lecture%208.1%20-%20Turbulent%20and%20Non-Newtonian%20Flows.html">8.1 Turbulent and Non-Newtonian Flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter8/Worksheet.html">Worksheet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter8/Solutions.html">Solutions</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part 3 - Numerical Techniques</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">9. Interpolation Quadrature 2</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">9.1 Interpolation &amp; Quadrature 2 <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="Homework.html">Homework <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="Solutions.html">Solutions <a class="tocSkip"></a></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter10/intro.html">10. ODE Solvers 2</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter10/Lecture%2010.1%20-%20ODE%20Solver.html">10.1 ODE solvers 2 <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter10/Homework.html">Homework <a class="tocSkip"></a></a></li>

<li class="toctree-l2"><a class="reference internal" href="../Chapter10/Solutions.html">Solutions <a class="tocSkip"></a></a></li>

</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter11/intro.html">11. PDE Solvers: Finite Difference Methods 2</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter11/Lecture%2011%20-%20PDE%20Solvers%20-%20Finite%20Difference%20Methods%202.html">11.1 PDE Solvers: Finite Difference Methods 2</a></li>

<li class="toctree-l2"><a class="reference internal" href="../Chapter11/Homework.html">Homework <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter11/Solutions.html">Solutions <a class="tocSkip"></a></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter12/intro.html">12. Finite Element Methods</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter12/Lecture%2012.1%20-%20FEM.html">12.1 Finite Element Methods <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter12/Homework.html">Homework <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter12/Solutions.html">Solutions <a class="tocSkip"></a></a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2FChapter9/Lecture 9.1 - interpolation quadrature.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/Chapter9/Lecture 9.1 - interpolation quadrature.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>9.1 Interpolation & Quadrature 2 <a class="tocSkip"></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># the following allows us to plot triangles indicating convergence order</span>
<span class="kn">from</span> <span class="nn">mpltools</span> <span class="kn">import</span> <span class="n">annotation</span>
<span class="c1"># as this lecture is about interpolation we will make use of this SciPy library</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">si</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">integrate</span>

<span class="c1"># some default font sizes for plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sans-serif&#39;</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.sans-serif&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Arial&#39;</span><span class="p">,</span> <span class="s1">&#39;Dejavu Sans&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<section class="tex2jax_ignore mathjax_ignore" id="interpolation-quadrature-2-a-class-tocskip">
<h1>9.1 Interpolation &amp; Quadrature 2 <a class="tocSkip"><a class="headerlink" href="#interpolation-quadrature-2-a-class-tocskip" title="Permalink to this heading">#</a></h1>
<p>Lecture 9.1<br />
Matt Piggott</p>
<section id="lecture-plan-learning-objectives-a-class-tocskip">
<h2>Lecture plan / learning objectives: <a class="tocSkip"><a class="headerlink" href="#lecture-plan-learning-objectives-a-class-tocskip" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Review and consolidation of some Computational Mathematics material - I will review quite a lot of key material we saw in that previous module.</p></li>
<li><p>To cover some more advanced topics related to the approximation of data and functions.</p></li>
<li><p>To introduce piecewise-linear basis functions and expansions (an important part of the finite element method).</p></li>
<li><p>To cover some more advanced topics related to the approximation of integrals.</p></li>
<li><p>More exposure to error analysis and convergence rates.</p></li>
<li><p>More practice of your coding skills.</p></li>
<li><p>Introduction to the generic principles of Richardson extrapolation and adaptive algorithms.</p></li>
</ul>
</section>
<section id="what-s-really-important-here-a-class-tocskip">
<h2>What’s really important here? <a class="tocSkip"><a class="headerlink" href="#what-s-really-important-here-a-class-tocskip" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>General familiarity with errors and their dependence on the specifics of the numerical method, the function being considered and the interval size (or mesh resolution).</p></li>
<li><p>The specifics of the hat functions used as a basis for p/w linear interpolation.</p></li>
<li><p>Anything with a double star can be completely ignored, including the similarly coloured material within that section.</p></li>
</ul>
<h2>Table of Contents<span class="tocSkip"></span></h2>
<div class="toc"><ul class="toc-item"><li><span><a href="#Interpolation" data-toc-modified-id="Interpolation-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Interpolation</a></span><ul class="toc-item"><li><span><a href="#Review" data-toc-modified-id="Review-1.1"><span class="toc-item-num">1.1&nbsp;&nbsp;</span>Review</a></span></li><li><span><a href="#Polynomial-interpolation-(revisited)" data-toc-modified-id="Polynomial-interpolation-(revisited)-1.2"><span class="toc-item-num">1.2&nbsp;&nbsp;</span>Polynomial interpolation (revisited)</a></span><ul class="toc-item"><li><span><a href="#Introduction" data-toc-modified-id="Introduction-1.2.1"><span class="toc-item-num">1.2.1&nbsp;&nbsp;</span>Introduction</a></span></li><li><span><a href="#Expansion-over-basis-functions-(e.g.-monomials)" data-toc-modified-id="Expansion-over-basis-functions-(e.g.-monomials)-1.2.2"><span class="toc-item-num">1.2.2&nbsp;&nbsp;</span>Expansion over basis functions (e.g. monomials)</a></span></li><li><span><a href="#Example" data-toc-modified-id="Example-1.2.3"><span class="toc-item-num">1.2.3&nbsp;&nbsp;</span>Example</a></span></li><li><span><a href="#Lagrange-polynomial" data-toc-modified-id="Lagrange-polynomial-1.2.4"><span class="toc-item-num">1.2.4&nbsp;&nbsp;</span>Lagrange polynomial</a></span></li></ul></li><li><span><a href="#Using-scipy.interpolate" data-toc-modified-id="Using-scipy.interpolate-1.3"><span class="toc-item-num">1.3&nbsp;&nbsp;</span>Using scipy.interpolate</a></span></li><li><span><a href="#Newton-polynomial--[$\star$]" data-toc-modified-id="Newton-polynomial--[$\star$]-1.4"><span class="toc-item-num">1.4&nbsp;&nbsp;</span>Newton polynomial  [$\star$]</a></span></li></ul></li><li><span><a href="#Approximating-a-function" data-toc-modified-id="Approximating-a-function-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Approximating a function</a></span><ul class="toc-item"><li><span><a href="#A-simple-example" data-toc-modified-id="A-simple-example-2.1"><span class="toc-item-num">2.1&nbsp;&nbsp;</span>A simple example</a></span></li><li><span><a href="#Error-in-Lagrange-interpolation" data-toc-modified-id="Error-in-Lagrange-interpolation-2.2"><span class="toc-item-num">2.2&nbsp;&nbsp;</span>Error in Lagrange interpolation</a></span><ul class="toc-item"><li><span><a href="#Aside:-The-Lagrange-Remainder-Theorem--[$\star$]" data-toc-modified-id="Aside:-The-Lagrange-Remainder-Theorem--[$\star$]-2.2.1"><span class="toc-item-num">2.2.1&nbsp;&nbsp;</span>Aside: The Lagrange Remainder Theorem  [$\star$]</a></span></li><li><span><a href="#Observations--[$\star$]" data-toc-modified-id="Observations--[$\star$]-2.2.2"><span class="toc-item-num">2.2.2&nbsp;&nbsp;</span>Observations  [$\star$]</a></span></li><li><span><a href="#Example--[$\star$]" data-toc-modified-id="Example--[$\star$]-2.2.3"><span class="toc-item-num">2.2.3&nbsp;&nbsp;</span>Example  [$\star$]</a></span></li><li><span><a href="#Comments--[$\star$]" data-toc-modified-id="Comments--[$\star$]-2.2.4"><span class="toc-item-num">2.2.4&nbsp;&nbsp;</span>Comments  [$\star$]</a></span></li></ul></li><li><span><a href="#A-more-problematic-example-[$\star$]" data-toc-modified-id="A-more-problematic-example-[$\star$]-2.3"><span class="toc-item-num">2.3&nbsp;&nbsp;</span>A more problematic example [$\star$]</a></span><ul class="toc-item"><li><span><a href="#Observations--[$\star$]" data-toc-modified-id="Observations--[$\star$]-2.3.1"><span class="toc-item-num">2.3.1&nbsp;&nbsp;</span>Observations  [$\star$]</a></span></li><li><span><a href="#An-explanation--[$\star$]" data-toc-modified-id="An-explanation--[$\star$]-2.3.2"><span class="toc-item-num">2.3.2&nbsp;&nbsp;</span>An explanation  [$\star$]</a></span></li></ul></li><li><span><a href="#Chebyshev-nodes--[$\star$]" data-toc-modified-id="Chebyshev-nodes--[$\star$]-2.4"><span class="toc-item-num">2.4&nbsp;&nbsp;</span>Chebyshev nodes  [$\star$]</a></span></li><li><span><a href="#Chebyshev-polynomial-interpolation--[$\star$]" data-toc-modified-id="Chebyshev-polynomial-interpolation--[$\star$]-2.5"><span class="toc-item-num">2.5&nbsp;&nbsp;</span>Chebyshev polynomial interpolation  [$\star$]</a></span></li><li><span><a href="#Piecewise-polynomial-interpolation" data-toc-modified-id="Piecewise-polynomial-interpolation-2.6"><span class="toc-item-num">2.6&nbsp;&nbsp;</span>Piecewise polynomial interpolation</a></span><ul class="toc-item"><li><span><a href="#Piecewise-linear-interpolant" data-toc-modified-id="Piecewise-linear-interpolant-2.6.1"><span class="toc-item-num">2.6.1&nbsp;&nbsp;</span>Piecewise-linear interpolant</a></span></li><li><span><a href="#Piecewise-quadratic-interpolant" data-toc-modified-id="Piecewise-quadratic-interpolant-2.6.2"><span class="toc-item-num">2.6.2&nbsp;&nbsp;</span>Piecewise-quadratic interpolant</a></span></li><li><span><a href="#Observations" data-toc-modified-id="Observations-2.6.3"><span class="toc-item-num">2.6.3&nbsp;&nbsp;</span>Observations</a></span></li></ul></li><li><span><a href="#Piecewise-polynomial-interpolation-via-an-appropriate-set-of-basis-functions" data-toc-modified-id="Piecewise-polynomial-interpolation-via-an-appropriate-set-of-basis-functions-2.7"><span class="toc-item-num">2.7&nbsp;&nbsp;</span>Piecewise-polynomial interpolation via an appropriate set of basis functions</a></span><ul class="toc-item"><li><span><a href="#The-idea" data-toc-modified-id="The-idea-2.7.1"><span class="toc-item-num">2.7.1&nbsp;&nbsp;</span>The idea</a></span></li><li><span><a href="#Example---revisiting-a-quadratic-example-we've-already-seen" data-toc-modified-id="Example---revisiting-a-quadratic-example-we've-already-seen-2.7.2"><span class="toc-item-num">2.7.2&nbsp;&nbsp;</span>Example - revisiting a quadratic example we've already seen</a></span></li><li><span><a href="#Hat-functions-and-p/w-linear-interpolation/expansions" data-toc-modified-id="Hat-functions-and-p/w-linear-interpolation/expansions-2.7.3"><span class="toc-item-num">2.7.3&nbsp;&nbsp;</span>Hat functions and p/w linear interpolation/expansions</a></span></li><li><span><a href="#Some-code-to-return-the-hat/basis-functions" data-toc-modified-id="Some-code-to-return-the-hat/basis-functions-2.7.4"><span class="toc-item-num">2.7.4&nbsp;&nbsp;</span>Some code to return the hat/basis functions</a></span></li><li><span><a href="#Support-of-basis-functions" data-toc-modified-id="Support-of-basis-functions-2.7.5"><span class="toc-item-num">2.7.5&nbsp;&nbsp;</span>Support of basis functions</a></span></li></ul></li><li><span><a href="#Cubic-splines-[$\star\star$]" data-toc-modified-id="Cubic-splines-[$\star\star$]-2.8"><span class="toc-item-num">2.8&nbsp;&nbsp;</span>Cubic splines [$\star\star$]</a></span><ul class="toc-item"><li><span><a href="#Algorithm-sketch--[$\star\star$]" data-toc-modified-id="Algorithm-sketch--[$\star\star$]-2.8.1"><span class="toc-item-num">2.8.1&nbsp;&nbsp;</span>Algorithm sketch  [$\star\star$]</a></span></li></ul></li><li><span><a href="#Piecewise-Cubic-Hermite-Interpolating-Polynomial-(PCHIP)--[$\star\star$]" data-toc-modified-id="Piecewise-Cubic-Hermite-Interpolating-Polynomial-(PCHIP)--[$\star\star$]-2.9"><span class="toc-item-num">2.9&nbsp;&nbsp;</span>Piecewise Cubic Hermite Interpolating Polynomial (PCHIP)  [$\star\star$]</a></span><ul class="toc-item"><li><span><a href="#Observations" data-toc-modified-id="Observations-2.9.1"><span class="toc-item-num">2.9.1&nbsp;&nbsp;</span>Observations</a></span></li></ul></li><li><span><a href="#Compare-interpolation-methods" data-toc-modified-id="Compare-interpolation-methods-2.10"><span class="toc-item-num">2.10&nbsp;&nbsp;</span>Compare interpolation methods</a></span></li></ul></li><li><span><a href="#Quadrature" data-toc-modified-id="Quadrature-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Quadrature</a></span><ul class="toc-item"><li><span><a href="#Review" data-toc-modified-id="Review-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>Review</a></span></li><li><span><a href="#The-Midpoint-rule" data-toc-modified-id="The-Midpoint-rule-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>The Midpoint rule</a></span></li><li><span><a href="#Trapezoidal-rule" data-toc-modified-id="Trapezoidal-rule-3.3"><span class="toc-item-num">3.3&nbsp;&nbsp;</span>Trapezoidal rule</a></span><ul class="toc-item"><li><span><a href="#The-composite-version-of-the-trapezoidal-rule" data-toc-modified-id="The-composite-version-of-the-trapezoidal-rule-3.3.1"><span class="toc-item-num">3.3.1&nbsp;&nbsp;</span>The composite version of the trapezoidal rule</a></span></li></ul></li><li><span><a href="#Quadrature-Accuracy-and-Errors" data-toc-modified-id="Quadrature-Accuracy-and-Errors-3.4"><span class="toc-item-num">3.4&nbsp;&nbsp;</span>Quadrature Accuracy and Errors</a></span><ul class="toc-item"><li><span><a href="#Error-analysis-(qualitative)" data-toc-modified-id="Error-analysis-(qualitative)-3.4.1"><span class="toc-item-num">3.4.1&nbsp;&nbsp;</span>Error analysis (qualitative)</a></span></li><li><span><a href="#Error-analysis-(mathematical)-[$\star$]" data-toc-modified-id="Error-analysis-(mathematical)-[$\star$]-3.4.2"><span class="toc-item-num">3.4.2&nbsp;&nbsp;</span>Error analysis (mathematical) [$\star$]</a></span></li></ul></li><li><span><a href="#Simpson's-rule-[Review]" data-toc-modified-id="Simpson's-rule-[Review]-3.5"><span class="toc-item-num">3.5&nbsp;&nbsp;</span>Simpson's rule [Review]</a></span><ul class="toc-item"><li><span><a href="#Implementing-Simpson's-rule" data-toc-modified-id="Implementing-Simpson's-rule-3.5.1"><span class="toc-item-num">3.5.1&nbsp;&nbsp;</span>Implementing Simpson's rule</a></span></li><li><span><a href="#The-composite-version-of-Simpson's-Rule" data-toc-modified-id="The-composite-version-of-Simpson's-Rule-3.5.2"><span class="toc-item-num">3.5.2&nbsp;&nbsp;</span>The composite version of Simpson's Rule</a></span></li><li><span><a href="#Simpson's-rule-error-[$\star$]" data-toc-modified-id="Simpson's-rule-error-[$\star$]-3.5.3"><span class="toc-item-num">3.5.3&nbsp;&nbsp;</span>Simpson's rule error [$\star$]</a></span></li></ul></li><li><span><a href="#Weddle's-rule-(extrapolated-Simpson's-rule)-[$\star$]" data-toc-modified-id="Weddle's-rule-(extrapolated-Simpson's-rule)-[$\star$]-3.6"><span class="toc-item-num">3.6&nbsp;&nbsp;</span>Weddle's rule (extrapolated Simpson's rule) [$\star$]</a></span><ul class="toc-item"><li><span><a href="#Observations" data-toc-modified-id="Observations-3.6.1"><span class="toc-item-num">3.6.1&nbsp;&nbsp;</span>Observations</a></span></li></ul></li><li><span><a href="#Newton-Cotes-quadrature-rules-[$\star\star$]" data-toc-modified-id="Newton-Cotes-quadrature-rules-[$\star\star$]-3.7"><span class="toc-item-num">3.7&nbsp;&nbsp;</span>Newton-Cotes quadrature rules [$\star\star$]</a></span><ul class="toc-item"><li><span><a href="#(N=1)-Trapezoidal" data-toc-modified-id="(N=1)-Trapezoidal-3.7.1"><span class="toc-item-num">3.7.1&nbsp;&nbsp;</span>(N=1) Trapezoidal</a></span></li><li><span><a href="#(N=2)-Simpson's-rule" data-toc-modified-id="(N=2)-Simpson's-rule-3.7.2"><span class="toc-item-num">3.7.2&nbsp;&nbsp;</span>(N=2) Simpson's rule</a></span></li><li><span><a href="#Observations" data-toc-modified-id="Observations-3.7.3"><span class="toc-item-num">3.7.3&nbsp;&nbsp;</span>Observations</a></span></li><li><span><a href="#Open-vs-Closed-Newton-Cotes-formulae" data-toc-modified-id="Open-vs-Closed-Newton-Cotes-formulae-3.7.4"><span class="toc-item-num">3.7.4&nbsp;&nbsp;</span>Open vs Closed Newton-Cotes formulae</a></span></li></ul></li><li><span><a href="#(Richardson)-extrapolation-and-Romberg-integration--[$\star\star$]" data-toc-modified-id="(Richardson)-extrapolation-and-Romberg-integration--[$\star\star$]-3.8"><span class="toc-item-num">3.8&nbsp;&nbsp;</span>(Richardson) extrapolation and Romberg integration  [$\star\star$]</a></span><ul class="toc-item"><li><span><a href="#Observations" data-toc-modified-id="Observations-3.8.1"><span class="toc-item-num">3.8.1&nbsp;&nbsp;</span>Observations</a></span></li></ul></li><li><span><a href="#Adaptive-quadrature--[$\star$]" data-toc-modified-id="Adaptive-quadrature--[$\star$]-3.9"><span class="toc-item-num">3.9&nbsp;&nbsp;</span>Adaptive quadrature  [$\star$]</a></span><ul class="toc-item"><li><span><a href="#Algorithm" data-toc-modified-id="Algorithm-3.9.1"><span class="toc-item-num">3.9.1&nbsp;&nbsp;</span>Algorithm</a></span></li><li><span><a href="#Implementation" data-toc-modified-id="Implementation-3.9.2"><span class="toc-item-num">3.9.2&nbsp;&nbsp;</span>Implementation</a></span></li><li><span><a href="#Application-to-a-simple-problem" data-toc-modified-id="Application-to-a-simple-problem-3.9.3"><span class="toc-item-num">3.9.3&nbsp;&nbsp;</span>Application to a simple problem</a></span></li><li><span><a href="#Application-to-a-complex-problem" data-toc-modified-id="Application-to-a-complex-problem-3.9.4"><span class="toc-item-num">3.9.4&nbsp;&nbsp;</span>Application to a complex problem</a></span></li></ul></li><li><span><a href="#Quadrature-method-comparison" data-toc-modified-id="Quadrature-method-comparison-3.10"><span class="toc-item-num">3.10&nbsp;&nbsp;</span>Quadrature method comparison</a></span><ul class="toc-item"><li><span><a href="#Comments" data-toc-modified-id="Comments-3.10.1"><span class="toc-item-num">3.10.1&nbsp;&nbsp;</span>Comments</a></span></li></ul></li><li><span><a href="#Gaussian-quadrature--[$\star\star$]" data-toc-modified-id="Gaussian-quadrature--[$\star\star$]-3.11"><span class="toc-item-num">3.11&nbsp;&nbsp;</span>Gaussian quadrature  [$\star\star$]</a></span><ul class="toc-item"><li><span><a href="#Gauss-Legendre-quadrature" data-toc-modified-id="Gauss-Legendre-quadrature-3.11.1"><span class="toc-item-num">3.11.1&nbsp;&nbsp;</span>Gauss-Legendre quadrature</a></span></li></ul></li><li><span><a href="#Implementation" data-toc-modified-id="Implementation-3.12"><span class="toc-item-num">3.12&nbsp;&nbsp;</span>Implementation</a></span><ul class="toc-item"><li><span><a href="#Changing-integration-limits" data-toc-modified-id="Changing-integration-limits-3.12.1"><span class="toc-item-num">3.12.1&nbsp;&nbsp;</span>Changing integration limits</a></span></li><li><span><a href="#Other-Gaussian-quadrature-families" data-toc-modified-id="Other-Gaussian-quadrature-families-3.12.2"><span class="toc-item-num">3.12.2&nbsp;&nbsp;</span>Other Gaussian quadrature families</a></span></li></ul></li><li><span><a href="#Higher-dimensions--[$\star$]" data-toc-modified-id="Higher-dimensions--[$\star$]-3.13"><span class="toc-item-num">3.13&nbsp;&nbsp;</span>Higher dimensions  [$\star$]</a></span></li></ul></li><li><span><a href="#Summary" data-toc-modified-id="Summary-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>Summary</a></span><ul class="toc-item"><li><span><a href="#What-do-you-need-to-focus-on?" data-toc-modified-id="What-do-you-need-to-focus-on?-4.1"><span class="toc-item-num">4.1&nbsp;&nbsp;</span>What do you need to focus on?</a></span></li></ul></li></ul></div></section>
<section id="interpolation">
<h2>Interpolation<a class="headerlink" href="#interpolation" title="Permalink to this heading">#</a></h2>
</section>
<section id="review">
<h2>Review<a class="headerlink" href="#review" title="Permalink to this heading">#</a></h2>
<p>Recall that we often wish to approximate data, e.g. in 1D this might be a series of <span class="math notranslate nohighlight">\(y\)</span> values at <span class="math notranslate nohighlight">\(x\)</span> locations:</p>
<div class="math notranslate nohighlight">
\[ (x_i, y_i),\;\;\;\;\;\; i=0,\ldots,N,\]</div>
<p>The data may be known to be exact (e.g. we may wish to approximate a complex function, which we can evaluate exactly, by a simpler expression say), or it may have acknowledged errors from measurement/observational techniques, with known or unknown <a class="reference external" href="https://en.wikipedia.org/wiki/Error_bar">error bars</a>.</p>
<br>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Interpolation"><em>Interpolation</em></a> generally assumes that these data points are <em>exact</em> (e.g. no measurement errors) and at <em>distinct</em> <span class="math notranslate nohighlight">\(x\)</span> locations, i.e. there is no ambiguity in a mapping from <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(y\)</span> (which there would be if we had multiple <span class="math notranslate nohighlight">\(y\)</span> values for the same <span class="math notranslate nohighlight">\(x\)</span>; we will see this scenario in the case of curve-fitting covered below. The same <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> pairs exactly repeated obviously means repeated data and depending on application all the exact replicas might be removed).</p>
<br>
<p>The requirement for distinct <span class="math notranslate nohighlight">\(x\)</span> locations means that we have a constraint on the <span class="math notranslate nohighlight">\(x_i\)</span>’s which can be written as</p>
<div class="math notranslate nohighlight">
\[x_0 &lt; x_1 &lt; \ldots &lt; x_N,\]</div>
<p>[Note that sometimes we may have control over the <span class="math notranslate nohighlight">\(x\)</span> locations, but sometimes we won’t - we’ll just be given arbitrary data - we’ll cover both cases below].</p>
<br>
<p>The process of interpolation involves finding the function <span class="math notranslate nohighlight">\(f\)</span> such that</p>
<div class="math notranslate nohighlight">
\[y_i = f(x_i),\;\;\;\;\;\; \forall i\]</div>
<p>and recall that we have a lot of choice for how we construct the interpolating or curve-fitting function <span class="math notranslate nohighlight">\(f\)</span>.</p>
<section id="some-arbitrary-test-data">
<h3>Some arbitrary test data<a class="headerlink" href="#some-arbitrary-test-data" title="Permalink to this heading">#</a></h3>
<p>Let’s first invent a small set of arbitrary data which we shall seek to interpolate throughout this lecture using different methods, and define a function that will save us from typing the same plotting commands multiple times.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Invent some raw data - we will use the notation (xi,yi) for the</span>
<span class="c1"># given data, where xi and yi are of length N+1 (N=len(xi)-1)</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">])</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>

<span class="c1"># We will want to overlay a plot of the raw data a few times below so </span>
<span class="c1"># let&#39;s do this via a function that we can call repeatedly</span>
<span class="c1"># [Note that I&#39;ve been a bit lazy in later lectures and really should</span>
<span class="c1"># do this sort of thing more often to make code easier to read - apologies]</span>
<span class="k">def</span> <span class="nf">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;plot x vs y on axes ax, </span>
<span class="sd">    add axes labels and turn on grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;raw data&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

<span class="c1"># For clarity we are going to add a small margin to all the plots.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># plot the raw data</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>

<span class="c1"># add a figure title</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Our simple raw data&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Add a legend</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">);</span>
<span class="c1"># loc=&#39;best&#39; means we let matplotlib decide the best place for the</span>
<span class="c1"># legend to go.  For other options see </span>
<span class="c1">#  https://matplotlib.org/api/_as_gen/matplotlib.pyplot.legend.html</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/38572805534890ecc7c2b9245c9375062eddc1dfb922a31c148e1bb5af9034b0.png" src="../_images/38572805534890ecc7c2b9245c9375062eddc1dfb922a31c148e1bb5af9034b0.png" />
</div>
</div>
</section>
<section id="simple-interpolation-example">
<h3>Simple interpolation example<a class="headerlink" href="#simple-interpolation-example" title="Permalink to this heading">#</a></h3>
<p>One of the simplest examples of interpolation is to simply fit a straight line between every two successive data points.</p>
<p>This is termed <strong>piecewise-linear</strong> interpolation, and the resulting function is called a <strong>piecewise-linear interpolant</strong>.</p>
<p>This is an example of the more general <strong>piecewise-polynomial</strong> interpolation - a piecewise quadratic discontinuous function was given in the example image above.</p>
<p>[Note that we will return to piecewise polynomial interpolation a bit later.]</p>
<p>Of course the default approach to plotting effectively performs piecewise-linear interpolation as we shall now see.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Plot a piecewise-linear approximation.</span>
<span class="c1"># We get this simply by connecting the points with straight lines</span>
<span class="c1"># and this is the default behaviour of the plotting routine so simply</span>
<span class="c1"># involves a call to &#39;plot&#39; with our data.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w linear interpolant&#39;</span><span class="p">)</span>

<span class="c1"># Overlay raw data</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>

<span class="c1"># Add a legend</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="c1"># add a figure title</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Raw data and its p/w linear interpolant&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/be30753c988575ac36c085ab2b0291c65821fdde1fa769cb1e13d4e7c8bcd332.png" src="../_images/be30753c988575ac36c085ab2b0291c65821fdde1fa769cb1e13d4e7c8bcd332.png" />
</div>
</div>
</section>
</section>
<section id="polynomial-interpolation-revisited">
<h2>Polynomial interpolation (revisited)<a class="headerlink" href="#polynomial-interpolation-revisited" title="Permalink to this heading">#</a></h2>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h3>
<p>Recall that given a set of <span class="math notranslate nohighlight">\(N+1\)</span> data points <span class="math notranslate nohighlight">\((x_i, y_i)\)</span> (with distinct <span class="math notranslate nohighlight">\(x_i\)</span>’s).</p>
<p>We can use these <span class="math notranslate nohighlight">\(N+1\)</span> pieces of distinct information to construct a polynomial with <span class="math notranslate nohighlight">\(N+1\)</span> free parameters, i.e. a polynomial of degree <span class="math notranslate nohighlight">\(N\)</span>:</p>
<div class="math notranslate nohighlight">
\[ P_N(x) := \alpha_0 + \alpha_1 x + \alpha_2 x^2 + \alpha_3 x^3 + \ldots \alpha_N x^N, \]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_0, \, \alpha_1, \, \ldots, \, \alpha_N\)</span> are the coefficients of our polynomial.</p>
<br>
<br>
<p>The exact matching of the number of pieces of distinct data with the number of free parameters tells us that</p>
<br>
<blockquote>
<div><p><strong>The interpolating polynomial of the least degree is unique.</strong></p>
</div></blockquote>
</section>
<section id="expansion-over-basis-functions-e-g-monomials">
<h3>Expansion over basis functions (e.g. monomials)<a class="headerlink" href="#expansion-over-basis-functions-e-g-monomials" title="Permalink to this heading">#</a></h3>
<p>Note that we can also interpret the polynomial interpolant above as a <em>linear combination</em> of a <a href="https://en.wikipedia.org/wiki/Basis_(linear_algebra)"><em>basis</em></a> made up of single-term polynomials:</p>
<div class="math notranslate nohighlight">
\[1, \; x, \; x^2, \; \ldots, \; x^N.\]</div>
<p>These single term polynomials are also referred to as <a class="reference external" href="https://en.wikipedia.org/wiki/Monomial"><em>monomials</em></a>.</p>
<br>
<br>
<p>More generally we can write our interpolation function <span class="math notranslate nohighlight">\(f\)</span> as</p>
<div class="math notranslate nohighlight">
\[f(x) = \sum_{i=0}^N \alpha_i \phi_i(x) \]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha_i\)</span> for <span class="math notranslate nohighlight">\(i=0,\,\ldots, N\)</span> are the finite number of <em>weights</em> we need to find.</p></li>
<li><p><span class="math notranslate nohighlight">\(\phi_i(x)\)</span> for <span class="math notranslate nohighlight">\(i=0,\,\ldots, N\)</span> are a finite number of prescribed <em>basis functions</em></p></li>
</ul>
<br>
<p>For the polynomial interpolation we are currently considering <span class="math notranslate nohighlight">\(\phi_i(x) = x^i\)</span> of course.</p>
</section>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this heading">#</a></h3>
<p>Recall the naive way of recovering the coefficients in polynomial interpolation …</p>
<p>in the case of three data points where we seek to find a quadratic function, substituting the data into the quadratic yields three linear equations which we can write as the linear system</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
1 &amp; x_0 &amp; x_0^2 \\
1 &amp; x_1 &amp; x_1^2 \\
1 &amp; x_2 &amp; x_2^2
\end{pmatrix}
\begin{pmatrix}
\alpha_0\\
\alpha_1\\
\alpha_2
\end{pmatrix}
=
\begin{pmatrix}
y_0\\
y_1\\
y_2
\end{pmatrix} \;\;\;\;\;\;\;\text{or equivalently in matrix notation} \;\;\;\;\;\; V\boldsymbol{\alpha} =\boldsymbol{y}.
\end{split}\]</div>
<p>If we solve this system by inverting the matrix (<span class="math notranslate nohighlight">\(V\)</span>) we have our quadratic polynomial coefficients:  <span class="math notranslate nohighlight">\(\boldsymbol{\alpha} = V^{-1}\boldsymbol{y}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># three data point example</span>
<span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]</span>
<span class="n">yi</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]</span>

<span class="c1"># use a function to construct the matrix above</span>
<span class="c1"># note than numpy already has a function to do this</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;V = </span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>

<span class="c1"># use a numpy linear algebra solver to solve the system</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

<span class="c1"># output the coefficients for our quadratic we have computed</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Our coefficients a = </span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<span class="c1"># show that they are the same as is obtained from </span>
<span class="c1"># numpy&#39;s polyfit function (for a quadratic)</span>
<span class="c1"># (which of course they should be, given we argued that this polynomial is unique)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The output from np.polyfit(x, y, 2) = </span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="c1"># Note that the order is reversed because numpy.poly* assumes decreasing</span>
<span class="c1"># rather than the increasing powers of x which we have used above</span>

<span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

<span class="c1"># plot the raw data</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>

<span class="c1"># x locations at which to evaluate and plot the quadratic polynomial</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># Set up a polynomial from the coefficients using numpy rather than writing out.</span>
<span class="c1"># Use numpy.flip to reverse the coefficients as poly1d assume decreasing rather than</span>
<span class="c1"># increasing powers - look at documentation</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Which agrees with us as long as we reverse the order of our coefficients:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;np.flip(a, 0) = </span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>

<span class="c1"># the p2 here is a function so evaluate it at our x locations</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">p2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># and plot</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Quadratic&#39;</span><span class="p">)</span>

<span class="c1"># add a figure title</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Polynomial approx to three data points&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="c1"># Add a legend</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="c1"># set bounds</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>V = 
[[1.   0.3  0.09]
 [1.   0.5  0.25]
 [1.   0.8  0.64]]

 Our coefficients a = 
[-1.8         8.86666667 -7.33333333]

The output from np.polyfit(x, y, 2) = 
 [-7.33333333  8.86666667 -1.8       ]

Which agrees with us as long as we reverse the order of our coefficients:
np.flip(a, 0) = 
[-7.33333333  8.86666667 -1.8       ]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 1.0)
</pre></div>
</div>
<img alt="../_images/726eeeb6e93ca0d6c6486534562fae67c6f439be3e53915be36f10744cd36cb0.png" src="../_images/726eeeb6e93ca0d6c6486534562fae67c6f439be3e53915be36f10744cd36cb0.png" />
</div>
</div>
</section>
<section id="lagrange-polynomial">
<h3>Lagrange polynomial<a class="headerlink" href="#lagrange-polynomial" title="Permalink to this heading">#</a></h3>
<p>Recall that we asked the question previously - can we do better?</p>
<p>Can we avoid the need to form and invert a linear system to find our coefficient?</p>
<p>The answer was yes and the <a class="reference external" href="http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html">Lagrange polynomial</a> was a method to do this that required us to select a better set of basis functions.</p>
<br>
<p>Given a set of <span class="math notranslate nohighlight">\((N+1)\)</span> points as above, the Lagrange polynomial is defined as the linear combination</p>
<div class="math notranslate nohighlight">
\[L(x) := \sum_{i=0}^{N} y_i \ell_i(x),\]</div>
<p>where the <span class="math notranslate nohighlight">\(\ell_i(x)\)</span> are a new choice for our basis functions known as the <em>Lagrange basis polynomials</em> and are defined by the product</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ell_i(x) := \prod_{\begin{smallmatrix}0\le m\le N\\ m\neq i\end{smallmatrix}} \frac{x-x_m}{x_i-x_m} = \frac{(x-x_0)}{(x_i-x_0)} \cdots \frac{(x-x_{i-1})}{(x_i-x_{i-1})} \frac{(x-x_{i+1})}{(x_i-x_{i+1})} \cdots \frac{(x-x_N)}{(x_i-x_N)},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(0\le i\le N\)</span>,</p>
<p>and the <span class="math notranslate nohighlight">\(y_i\)</span> are the <span class="math notranslate nohighlight">\(N+1\)</span> weights/coefficients corresponding to this basis.</p>
<br>
<p>Uniqueness of the interpolating polynomial of minimum degree means that the result from the use of monomials of Lagrange basis polynomials means that both approaches yield identical interpolating polynomials.</p>
<p>For example, let’s use this polynomial</p>
<div class="math notranslate nohighlight">
\[f(x) = P_N(x) = 2 + 3x + 4x^2\]</div>
<p>to evaluate some <span class="math notranslate nohighlight">\(y\)</span> values for three equally spaced <span class="math notranslate nohighlight">\(x\)</span> values:</p>
<p>we thus have the <span class="math notranslate nohighlight">\((x,y)\)</span> data pairs <span class="math notranslate nohighlight">\((0,2)\)</span>, <span class="math notranslate nohighlight">\((1,9)\)</span>, <span class="math notranslate nohighlight">\((2,24)\)</span>.</p>
<br>
<p>The Lagrange polynomial can be immediately written down:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}L(x) &amp; = 2 \ell_0(x) + 9  \ell_1(x) + 24 \ell_2(x) \\[20pt]
&amp;= 2\frac{(x-1)}{(0-1)}\frac{(x-2)}{(0-2)} 
+ 9\frac{(x-0)}{(1-0)}\frac{(x-2)}{(1-2)} 
+ 24\frac{(x-0)}{(2-0)}\frac{(x-1)}{(2-1)}
\end{align*} 
\end{split}\]</div>
<p>and either by expanding and collecting terms, of visually, we can establish that this is identical to the original function.</p>
<p>[We’ll come back to this example and expansion a bit later].</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">P</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">+</span> <span class="mf">3.</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">4.</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">L</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> \
<span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> \
<span class="o">+</span> <span class="mi">24</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$P_N(x)$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$L(x)$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Compare two polynomial approximations&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f590f5d6fd0&gt;
</pre></div>
</div>
<img alt="../_images/6c380a3719cc3539cb1888b582fcb34fa6b78d0dfa420b33688a96f2d6b6a8ee.png" src="../_images/6c380a3719cc3539cb1888b582fcb34fa6b78d0dfa420b33688a96f2d6b6a8ee.png" />
</div>
</div>
</section>
</section>
<section id="using-scipy-interpolate">
<h2>Using scipy.interpolate<a class="headerlink" href="#using-scipy-interpolate" title="Permalink to this heading">#</a></h2>
<p>Recall that we can use <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.lagrange.html">scipy.interpolate.lagrange</a>
from Python’s <a class="reference external" href="http://www.scipy.org">SciPy</a> library to generate the Lagrange polynomial.</p>
<p>First our three point example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Our raw data from earlier - you can also test on our three data point example</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">24</span><span class="p">])</span>

<span class="c1"># Create the Lagrange polynomial for the given points.</span>
<span class="n">lp</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">lagrange</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
<span class="c1"># recall above that we executed &#39;import scipy.interpolate as si&#39;</span>
<span class="c1"># and so this line is calling the &#39;lagrange&#39; function from the </span>
<span class="c1"># &#39;interpolate&#39; sub-package within scipy.</span>

<span class="c1"># Evaluate this function at a high resolution (100 points here) so that </span>
<span class="c1"># we get a smooth well-resolved line when we plot our polynomial</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># set up the figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># actually plot (x,y)=(x,lp(x)) on the axes with the label ax1</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Lagrange interpolating polynomial&#39;</span><span class="p">)</span>

<span class="c1"># Overlay raw data on the same axes</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Lagrange interpolating polynomial (SciPy)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Add a legend</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/45ea101b9d0d537c8317d49293f467385a37d42a83080bf65e16770405d2f0a4.png" src="../_images/45ea101b9d0d537c8317d49293f467385a37d42a83080bf65e16770405d2f0a4.png" />
</div>
</div>
<p>and our larger data set from earlier</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Our raw data from earlier - you can also test on our three data point example</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">])</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>

<span class="c1"># Create the Lagrange polynomial for the given points.</span>
<span class="n">lp</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">lagrange</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
<span class="c1"># recall above that we executed &#39;import scipy.interpolate as si&#39;</span>
<span class="c1"># and so this line is calling the &#39;lagrange&#39; function from the </span>
<span class="c1"># &#39;interpolate&#39; sub-package within scipy.</span>

<span class="c1"># Evaluate this function at a high resolution (100 points here) so that </span>
<span class="c1"># we get a smooth well-resolved line when we plot our polynomial</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">9.1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># set up the figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># actually plot (x,y)=(x,lp(x)) on the axes with the label ax1</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Lagrange interpolating polynomial&#39;</span><span class="p">)</span>

<span class="c1"># Overlay raw data on the same axes</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Lagrange interpolating polynomial (SciPy)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Add a legend</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/e3ed837be4a15fa2131a3b4bde6acc42ef425b454ca38f91261bb090eda1f5c3.png" src="../_images/e3ed837be4a15fa2131a3b4bde6acc42ef425b454ca38f91261bb090eda1f5c3.png" />
</div>
</div>
<p>An implementation of the Lagrange basis functions and thus the Lagrange polynomial was a homework exercise when we considered interpolation in the Computational Mathematics module.</p>
<p>It turns out that there is yet another way of writing the (unique) interpolating polynomial that results in an algorithm that is arguable easier to implement - this is termed the Newton polynomial.</p>
</section>
<section id="newton-polynomial-star">
<h2>Newton polynomial  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#newton-polynomial-star" title="Permalink to this heading">#</a></h2>
<p>Calculating the Newton polynomial (also called <a class="reference external" href="http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html">Newton’s divided difference interpolation polynomial</a>) yields the same polynomial as the Lagrange polynomial method (remember that the polynomial of minimum degree to pass through each data point is unique), but is arguably easier to implement (and this implementation is a useful coding exercise - see homework).</p>
<br>
<p>To derive this approach we write our degree <span class="math notranslate nohighlight">\(N\)</span> polynomial in the following form</p>
<div class="math notranslate nohighlight">
\[ P_N(x) = a_0 +(x-x_0)a_1 + (x-x_0)(x-x_1)a_2 + \cdots + \left[(x-x_0)(x-x_1)\ldots(x-x_{N-1})\right]a_N,\]</div>
<p>note that this is indeed a degree <span class="math notranslate nohighlight">\(N\)</span> polynomial and as before was have <span class="math notranslate nohighlight">\(N+1\)</span> free parameters  <span class="math notranslate nohighlight">\(a_0, a_1, \ldots, a_N\)</span>, which we need to find using the <span class="math notranslate nohighlight">\(N+1\)</span> pieces of information we have in the given data.</p>
<p>Efficient derivation of an algorithm to compute the Newton polynomial follows from noticing that we can write this polynomial in a <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)"><em>recursive form</em></a>.</p>
<p>Consider for example a case with <span class="math notranslate nohighlight">\(N=3\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
P_3(x) &amp;= a_0 +(x-x_0)a_1 + (x-x_0)(x-x_1)a_2 + (x-x_0)(x-x_1)(x-x_2)a_3\\[5pt]
&amp;= a_0 +(x-x_0)[a_1 + (x-x_1)[a_2 + (x-x_2)a_3]].
\end{align}
\end{split}\]</div>
<p>Notice that substituting in the <span class="math notranslate nohighlight">\(x_i\)</span> values leads to a set of simultaneous equations where we can easily evaluate the unknowns <span class="math notranslate nohighlight">\(a_0, a_1, \ldots\)</span> using what is termed ‘back (or forward) substitution’.</p>
<p>We’ll see an example of this now …</p>
<ol class="arabic simple">
<li><p>Substitute <span class="math notranslate nohighlight">\(x=x_0\)</span>: We have <span class="math notranslate nohighlight">\(a_0 = P_3(x_0)\)</span>, and we know that our interpolant <span class="math notranslate nohighlight">\(P_3(x)\)</span> evaluated at <span class="math notranslate nohighlight">\(x_0\)</span> must return <span class="math notranslate nohighlight">\(y_0\)</span>. Hence,</p></li>
</ol>
<br>
<div class="math notranslate nohighlight">
\[a_0 = y_0.\]</div>
<br>
<ol class="arabic simple" start="2">
<li><p>Now substitute <span class="math notranslate nohighlight">\(x=x_1\)</span>: We have <span class="math notranslate nohighlight">\(P_3(x_1) = a_0 +(x_1-x_0)a_1 = y_0 +(x_1-x_0)a_1 \)</span>, the LHS of this is <span class="math notranslate nohighlight">\(y_1\)</span>, and we know everything on the RHS as we have already calculated <span class="math notranslate nohighlight">\(a_0 = y_0\)</span>. We can thus trivially rearrange to yield</p></li>
</ol>
<br>
<div class="math notranslate nohighlight">
\[ a_1 = \frac{(y_1 - y_0)}{(x_1-x_0)}.\]</div>
<br>
<ol class="arabic simple" start="3">
<li><p>Substituting <span class="math notranslate nohighlight">\(x=x_2\)</span> yields</p></li>
</ol>
<br>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
&amp; y_2 = P_3(x_2) = a_0 +(x_2-x_0)[a_1 + (x_2-x_1)a_2] = y_0 + (x_2-x_0)\left[ \frac{(y_1 - y_0)}{(x_1-x_0)} + (x_2-x_1)a_2\right]\\[5pt]
&amp;\implies a_2 = \frac{ \frac{(y_2 - y_0)}{(x_2-x_0)} - \frac{(y_1 - y_0)}{(x_1-x_0)}}{x_2-x_1}.
\end{align*}
\end{split}\]</div>
<br>
<ol class="arabic simple" start="4">
<li><p>And so on …</p></li>
</ol>
<p>To define an algorithm for this method in general let’s first introducing the following <a class="reference external" href="https://en.wikipedia.org/wiki/Divided_differences"><em>divided difference</em></a> notation</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{alignat*}{2}
\Delta y_i &amp;= \frac{y_i-y_0}{x_i-x_0},\;\;    &amp;&amp; i=1,2,\ldots, N,\\[10pt]
\Delta^2 y_i &amp;= \frac{\Delta y_i-\Delta y_1}{x_i-x_1},\;\;    &amp;&amp; i=2, 3,\ldots, N,\\[10pt]
&amp;\vdots\\[5pt]
\Delta^N y_N &amp;= \frac{\Delta^{N-1} y_N-\Delta^{N-1} y_{N-1}}{x_N-x_{N-1}}.
\end{alignat*}
\end{split}\]</div>
<p>With a bit of thought we can hopefully see from the above example that the coefficients of the interpolating polynomial in the general case are given by</p>
<div class="math notranslate nohighlight">
\[a_0=y_0,\;\;\;\;\; a_1 = \Delta y_1, \;\;\;\;\; a_2 = \Delta^2 y_2, \;\;\;\;\; \ldots \;\;\;\;\; a_N = \Delta^N y_N.\]</div>
<p>See the homework exercise for an implementation of functions to construct and evaluate the Newton polynomial.</p>
</section>
<section id="approximating-a-function">
<h2>Approximating a function<a class="headerlink" href="#approximating-a-function" title="Permalink to this heading">#</a></h2>
<p>Rather than approximating/interpolating arbitrary discrete data given to us somehow (e.g. from observations, or from a very expensive computer code which has been run previously), we can of course use the same methods to approximate a given function.</p>
<p>We may want to do this in order to approximate a complex/expensive function with a simpler, cheaper interpolating function.</p>
<p>Our “function” may be a large expensive PDE solver for example.</p>
<br>
<p>Note that to avoid confusion I will use <span class="math notranslate nohighlight">\(f\)</span> as the given function we wish to approximate and <span class="math notranslate nohighlight">\(f_h\)</span> as the interpolating function.</p>
</section>
<section id="a-simple-example">
<h2>A simple example<a class="headerlink" href="#a-simple-example" title="Permalink to this heading">#</a></h2>
<p>For example, consider the function <span class="math notranslate nohighlight">\(y(x)=x^3\)</span> with data provided at  equally spaced points.</p>
<p>Let’s see what happens if we evaluate with Lagrange polynomials of degree 0, 1 and 2.</p>
<p>[Note that since in this case we are given the underlying function, we can in principle choose the locations and number of data points, so for the degree 0, 1 and 2 Lagrange polynomials we first need to evaluate the underlying function 1, 2 and 3 times respectively. For simplicity below we just choose these to be evenly distributed in our <span class="math notranslate nohighlight">\(x\)</span> domain of interest].</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this is the function we are going to approximate with low degree polynomials</span>
<span class="k">def</span> <span class="nf">func_x3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span>

<span class="c1"># as we will plot our approximation several times let&#39;s write a small function to do this</span>
<span class="k">def</span> <span class="nf">plot_approximation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function that plots an original function and its Lagrange polynomial approximation. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : callable</span>
<span class="sd">        Original function</span>
<span class="sd">    xi : array_like</span>
<span class="sd">        The x-component of the data</span>
<span class="sd">    ax : matplotlib axes</span>
<span class="sd">        The axes to plot on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Relatively fine x points for plotting our functions</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="c1"># Plot the original function</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Original function&#39;</span><span class="p">)</span>

    <span class="c1"># construct and plot the Lagrange polynomial</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">lagrange</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
    <span class="c1"># evaluate and plot the Lagrange polynomial at the x points</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Lagrange poly. interpolant&#39;</span><span class="p">)</span>

    <span class="c1"># shade the region between the two to emphasise the difference</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">lp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># add some axis labels</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x), \; P_N(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

    <span class="c1"># and add on top the interpolation points</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>

    <span class="c1"># and a legend</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>


<span class="c1"># set up our figs for plotting - we want three subplots arranged in a 1x3 grid</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax3</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># add some padding otherwise axes the labels can overlap with the next subplot</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> 

<span class="c1"># Plot the L0 degree 0 Lagrange poly and visualise the error</span>
<span class="n">plot_approximation</span><span class="p">(</span><span class="n">func_x3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">,</span> <span class="p">]),</span> <span class="n">ax1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Approximating a cubic with a constant&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Plot the L1 degree 1 Lagrange poly and visualise the error</span>
<span class="n">plot_approximation</span><span class="p">(</span><span class="n">func_x3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]),</span> <span class="n">ax2</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Approximating a cubic with a linear&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Plot the L2 degree 2 Lagrange poly and visualise the error</span>
<span class="n">plot_approximation</span><span class="p">(</span><span class="n">func_x3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]),</span> <span class="n">ax3</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Approximating a cubic with a quadratic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/98ebe38495bfa4cc4d83754767a1c444835f6d49f50972044a3e9a6eb302e0eb.png" src="../_images/98ebe38495bfa4cc4d83754767a1c444835f6d49f50972044a3e9a6eb302e0eb.png" />
</div>
</div>
</section>
<section id="error-in-lagrange-interpolation">
<h2>Error in Lagrange interpolation<a class="headerlink" href="#error-in-lagrange-interpolation" title="Permalink to this heading">#</a></h2>
<p>Note that it can be proven that in the case where we are interpolating a known function (e.g. a complicated non-polynomial function such as <span class="math notranslate nohighlight">\(\exp\)</span> or <span class="math notranslate nohighlight">\(\sin\)</span>) by a simpler polynomial, the error at any point we evaluate the interpolant at is proportional to:</p>
<ul class="simple">
<li><p>(1) the distance of that point from any of the data points (which makes sense as the error is obviously zero at the data points),</p></li>
<li><p>(2) and to the <span class="math notranslate nohighlight">\((N+1)\)</span>-th derivative of that function evaluated at <em>some</em> location within the bounds of the data.</p></li>
</ul>
<p>i.e. the more complicated (sharply varying) the function is, the higher the error <em>could</em> be.</p>
<p>Note the similarities here with the Taylor series expansion.</p>
<p>This result is sometimes called the <a class="reference external" href="https://en.wikipedia.org/wiki/Polynomial_interpolation#Interpolation_error"><em>Lagrange remainder theorem</em></a>.</p>
<p>We won’t prove this here, but it will be useful in later lectures if we write it down now.</p>
<section id="aside-the-lagrange-remainder-theorem-star">
<h3>Aside: The Lagrange Remainder Theorem  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#aside-the-lagrange-remainder-theorem-star" title="Permalink to this heading">#</a></h3>
<p>For <span class="math notranslate nohighlight">\(N\ge 0\)</span>, let <span class="math notranslate nohighlight">\(f(x)\)</span> be a function with at least <span class="math notranslate nohighlight">\(N+1\)</span> continuous derivatives over the interval <span class="math notranslate nohighlight">\([a,b]\)</span>,</p>
<p>(the mathematical way of writing this is <span class="math notranslate nohighlight">\(f \in C^{N+1}[a,b]\)</span> - see <a class="reference external" href="http://mathworld.wolfram.com/C-kFunction.html">http://mathworld.wolfram.com/C-kFunction.html</a> for more details on this if interested)</p>
<p>and let <span class="math notranslate nohighlight">\(\;\;x_0&lt;x_1&lt;\ldots&lt;x_N\;\;\)</span> be <span class="math notranslate nohighlight">\(N+1\)</span> distinct points in <span class="math notranslate nohighlight">\([a,b]\)</span>.</p>
<p>Then the degree (<span class="math notranslate nohighlight">\(\le\)</span>) <span class="math notranslate nohighlight">\(N\)</span> polynomial interpolating <span class="math notranslate nohighlight">\(f(x)\)</span> at these points, <span class="math notranslate nohighlight">\(P_N(x)\)</span>, satisfies</p>
<div class="math notranslate nohighlight">
\[ f(x) = P_N(x) + R_N(x) \;\;\;\;\;\; \text{or} \;\;\;\;\;\; R_N(x) = f(x) - P_N(x) \;\;\;\;\;\; \forall x\in[a,b],\]</div>
<p>where <span class="math notranslate nohighlight">\(R_N(x)\)</span> is the <em>remainder</em>, or the <a class="reference external" href="https://en.wikipedia.org/wiki/Polynomial_interpolation#Interpolation_error"><em>interpolation error</em></a>, and takes the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*} 
R_N(x) &amp; = \frac{(x-x_0)(x-x_1)\cdots(x-x_N)}{(N+1)!} \, f^{(N+1)}(c_x) \\[10pt]
&amp; = \Psi_N(x)\,\frac{f^{(N+1)}(c_x)}{(N+1)!},
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(c_x\)</span> is <em>some</em> value/point/location between the maximum and minimum values of <span class="math notranslate nohighlight">\(x_0, \ldots, x_N\)</span> and <span class="math notranslate nohighlight">\(x\)</span>,</p>
<p>and where</p>
<div class="math notranslate nohighlight">
\[ \Psi_N(x) := \prod^N_{i=0} (x - x_i) = (x-x_0)(x-x_1)\cdots(x-x_N). \]</div>
<br>
<p>This gives us an expression for the error, but we don’t know what <span class="math notranslate nohighlight">\(c_x\)</span> is and so it’s not that helpful.</p>
<br>
<p><strong>However, we can use this result to derive an upper bound on the error:</strong></p>
<p>If you want you can think of the unknown <span class="math notranslate nohighlight">\(c_x\)</span> as being some value <span class="math notranslate nohighlight">\(c_x \in (a,b)\)</span>, and by setting</p>
<div class="math notranslate nohighlight">
\[M:=\max_{x\in(a,b)}\, \left| f^{(N+1)}(x) \right|,\]</div>
<p>i.e. defining <span class="math notranslate nohighlight">\(M\)</span> to be the <em>maximum</em> value of the (<span class="math notranslate nohighlight">\(N+1\)</span>)-th derivative over our interval,</p>
<br>
<p>then we are left with the error <strong>bound</strong> that no longer depends on this unknown <span class="math notranslate nohighlight">\(c_x\)</span>:</p>
<br>
<div class="math notranslate nohighlight">
\[\begin{split}
\boxed{
\left| f(x) - P_N(x) \right| \le \frac{1}{(N+1)!}\, M\, \left|\Psi_N(x)\right|,  \\[20pt]
M:=\max_{x\in(a,b)}\, \left| f^{(N+1)}(x) \right|, \\
\Psi_N(x) := \prod^N_{i=0} (x - x_i) = (x-x_0)(x-x_1)\cdots(x-x_N).
}
\end{split}\]</div>
</section>
<section id="observations-star">
<h3>Observations  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#observations-star" title="Permalink to this heading">#</a></h3>
<p>This looks complicated, but we can make multiple observations based on this quite easily
(some which just reinforce things that are obvious, or that we have seen already):</p>
<br>
<ul class="simple">
<li><p>(1) The error is zero at the nodes (as <span class="math notranslate nohighlight">\(\Psi_N(x)\)</span> vanishes at these points).</p></li>
</ul>
<br>
<ul class="simple">
<li><p>(2) The error is zero everywhere if <span class="math notranslate nohighlight">\(f\)</span> is a polynomial of degree <span class="math notranslate nohighlight">\(N\)</span> or less (as then <span class="math notranslate nohighlight">\(f^{N+1}(x)\equiv 0\)</span>), which is of course equivalent to saying that we can approximate a given polynomial function exactly if we match degrees.</p></li>
</ul>
<br>
<ul class="simple">
<li><p>(3) This result is only true for smooth functions and essentially says that smooth functions behave like polynomials (cf. a truncated <a class="reference external" href="https://en.wikipedia.org/wiki/Taylor_series">Taylor series</a> expansion) - this is why polynomial interpolation works for smooth functions.</p></li>
</ul>
<br>
<ul class="simple">
<li><p>(4) However, this mathematical result (and hence all of our observations based on it) are invalid when <span class="math notranslate nohighlight">\(f\)</span> has discontinuous derivatives (is not smooth) - because <span class="math notranslate nohighlight">\(f\)</span> no longer behaves like a polynomial (e.g. it can do what it likes between the known points).</p></li>
</ul>
<br>
<ul class="simple">
<li><p>(5) Functions with larger <span class="math notranslate nohighlight">\((N+1)\)</span>-st derivative will tend to have larger interpolation errors.</p></li>
</ul>
<br>
<ul class="simple">
<li><p>(6) For a given function <span class="math notranslate nohighlight">\(f\)</span>, minimising the interpolation error for a given choice on <span class="math notranslate nohighlight">\(N\)</span> is effectively the same as minimising <span class="math notranslate nohighlight">\(\left|\Psi_N(x)\right|\)</span> for <span class="math notranslate nohighlight">\(x\in [a,b]\)</span>.  In addition, the structure of the error (i.e. how it varies in space) is due to the spatial structure of <span class="math notranslate nohighlight">\(\Psi\)</span> (as the other terms do not depend on <span class="math notranslate nohighlight">\(x\)</span>).</p></li>
</ul>
<br>
<p>The final point is important - we will return to this shortly.</p>
</section>
<section id="example-star">
<h3>Example  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#example-star" title="Permalink to this heading">#</a></h3>
<p>What does this tell us for our example <span class="math notranslate nohighlight">\(f(x)=x^3\)</span>?</p>
<p>As for our plots above with this example, let’s assume <span class="math notranslate nohighlight">\([a,b]=[0.5, 3.5]\)</span> and compute the error (estimate or bound) based upon the above theory.</p>
<p>We need the maximum value of the appropriate (i.e. dependent on our polynomial degree) degree derivative over the interval:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
N &amp; = 0: \;\;\;\; &amp; \max_{x\in(a,b)}f'(x) &amp; = \left. 3x^2 \right|_{x = 3.5} = 36.75,\\[15pt]
N &amp; = 1: \;\;\;\; &amp; \max_{x\in(a,b)}f''(x) &amp; = \left. 6x \right|_{x = 3.5} = 21,\\[15pt]
N &amp; = 2: \;\;\;\; &amp; \max_{x\in(a,b)}f'''(x) &amp; =  6, \\[15pt]
N &amp; = 3: \;\;\;\; &amp; \max_{x\in(a,b)}f^{(4)}(x) &amp; = 0. 
\end{align*}
\end{split}\]</div>
<p>Let’s now evaluate the actual error between the function and the interpolating polynomials and see how well these error estimates agree, or bound this error.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>

<span class="k">def</span> <span class="nf">func_x3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span>

<span class="k">def</span> <span class="nf">plot_errors</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>   
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># M contains the maximum derivative values, as computed above;</span>
    <span class="c1"># a component (the N-th) of which appear as one factor in our error estimate.</span>
    <span class="n">M</span> <span class="o">=</span> <span class="p">[</span><span class="mf">36.75</span><span class="p">,</span> <span class="mf">21.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]</span>

    <span class="c1"># for the approximation with a Lagrange polynomial</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">lagrange</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>

    <span class="c1"># plot the error between the function f(x) and the Lagrange polynomial over [0.5,3.5]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">lp</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Error - actual&#39;</span><span class="p">)</span>

    <span class="c1"># compute the Psi function defined above, here using &quot;list comprehension&quot;</span>
    <span class="n">Psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># our error estimate is (1/(N+1)!) * M * |Psi|.  Plot this:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">factorial</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Psi</span><span class="p">),</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Error bound estimate&#39;</span><span class="p">)</span>

    <span class="c1"># add labels and legend</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    
<span class="c1"># set up our figs for plotting - we want three subplots arranged in a 1x3 grid</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax3</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># add some padding otherwise axes labels overlap</span>

<span class="c1"># L0</span>
<span class="n">plot_errors</span><span class="p">(</span><span class="n">func_x3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">,</span> <span class="p">]),</span> <span class="n">ax1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Theoretical vs exact error - constant&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># L1</span>
<span class="n">plot_errors</span><span class="p">(</span><span class="n">func_x3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]),</span> <span class="n">ax2</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Theoretical vs exact error - linear&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># L2</span>
<span class="n">plot_errors</span><span class="p">(</span><span class="n">func_x3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]),</span> <span class="n">ax3</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Theoretical vs exact error - quadratic&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/a46cfe6f7536e3a91d1716eee06282dbdd827c0b1c11fbe4f0e14d03fcf3d70c.png" src="../_images/a46cfe6f7536e3a91d1716eee06282dbdd827c0b1c11fbe4f0e14d03fcf3d70c.png" />
</div>
</div>
</section>
<section id="comments-star">
<h3>Comments  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#comments-star" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Our error bound is indeed an <strong>upper bound</strong> on the actual error.</p></li>
<li><p>Both the actual error and the error bound are zero at the data locations.</p></li>
<li><p>For this example (i.e. a ‘simple’ cubic function), our error bound is actually exactly equal to the real error in the case of the quadratic approximation - why is this?</p></li>
</ol>
<br>
<p>[When an error bound value is very close to the actual error we call it a <em>tight</em> bound - tighter bounds are obviously more useful in practice although not always necessary for proving theoretical results - <a class="reference external" href="https://en.wikipedia.org/wiki/Upper_and_lower_bounds">https://en.wikipedia.org/wiki/Upper_and_lower_bounds</a>].</p>
</section>
</section>
<section id="a-more-problematic-example-star">
<h2>A more problematic example [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#a-more-problematic-example-star" title="Permalink to this heading">#</a></h2>
<p>[This is an illustrative example to demonstrate how things can go wrong, especially when using high-degree approximating polynomials.]</p>
<br>
<p>Approximating the <a class="reference external" href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon">Runge function</a>:</p>
<div class="math notranslate nohighlight">
\[f(x) := \frac{1}{1 + 25 x^2},\]</div>
<p>using equally spaced data points in the interval <span class="math notranslate nohighlight">\([-1,1]\)</span> is a famous example demonstrating how/where polynomial interpolation can go wrong!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define the runge function</span>
<span class="k">def</span> <span class="nf">runge</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">25.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">plot_approximation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to plot exact function f (e.g. Runge) and its Lagrange polynomial approximation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : callable</span>
<span class="sd">        The Runge function</span>
<span class="sd">    xi : array_like</span>
<span class="sd">        The x-component of the data</span>
<span class="sd">    ax : matplotlib axes</span>
<span class="sd">        The axes to plot on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Runge function&#39;</span><span class="p">)</span>

    <span class="n">lp</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">lagrange</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Poly. approx.&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>


<span class="c1"># the problem gets worse at higher degree - list of degrees to consider</span>
<span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>

<span class="c1"># set up our figs for plotting</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="c1"># this turns the 2D array of axes into a 1D vector we can easily call in the loop below</span>
<span class="n">axs</span> <span class="o">=</span> <span class="n">axs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># add some padding otherwise axes labels overlap</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">h_pad</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># enumerate is a useful way to loop over something (here degrees) and have </span>
<span class="c1"># an automatic counter - here i which we use to identify the correct axis</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">degree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">degrees</span><span class="p">):</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plot_approximation</span><span class="p">(</span><span class="n">runge</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Degree </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">degree</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span>---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[10], line 31
     28 degrees = [1, 2, 3, 5, 9, 12, 15, 20]
     30 # set up our figs for plotting
---&gt; 31 fig, axs = plt.subplots(2, np.int(len(degrees)/2), figsize=(12, 8))
     32 # this turns the 2D array of axes into a 1D vector we can easily call in the loop below
     33 axs = axs.reshape(-1)

File /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/numpy/__init__.py:319, in __getattr__(attr)
    314     warnings.warn(
    315         f&quot;In the future `np.{attr}` will be defined as the &quot;
    316         &quot;corresponding NumPy scalar.&quot;, FutureWarning, stacklevel=2)
    318 if attr in __former_attrs__:
--&gt; 319     raise AttributeError(__former_attrs__[attr])
    321 if attr == &#39;testing&#39;:
    322     import numpy.testing as testing

AttributeError: module &#39;numpy&#39; has no attribute &#39;int&#39;.
`np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
    https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
</pre></div>
</div>
</div>
</div>
<section id="id1">
<h3>Observations  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>We see that for this problem, with increasing numbers of evenly spaced data points, the corresponding Lagrange polynomials, while doing a better and better job of approximating the underlying exact function <em>towards the middle</em> of the interval, do an increasingly bad job towards the <em>ends of the interval</em>.</p></li>
<li><p><strong>Take home message:</strong>  Try to avoid high-degree interpolants when the data is evenly spaced - as high-degree polynomials have a tendency to oscillate strongly between data points, especially at the ends.</p></li>
<li><p>So interpolation here in regions of the domain would give huge errors. Imagine further what would happen if you tried to use one of these Lagrange polynomials to estimate a value for the Runge function slightly outside the <span class="math notranslate nohighlight">\([-1,1]\)</span> interval considered here (i.e. to <strong>extrapolate</strong>) - the result would clearly be terrible. This is therefore <strong>also</strong> a good example of why extrapolation in general should be undertaken with extreme caution!</p></li>
</ul>
</section>
<section id="an-explanation-star">
<h3>An explanation  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#an-explanation-star" title="Permalink to this heading">#</a></h3>
<p>The reason for this behaviour is a consequence of two factors:</p>
<ul class="simple">
<li><p>Although smooth, the magnitude of the derivative of this function grows with <span class="math notranslate nohighlight">\(N\)</span> [see homework exercise].</p></li>
<li><p>The behaviour of the <span class="math notranslate nohighlight">\(\Psi\)</span> quantity is such that, relatively speaking, with evenly spaced data points <span class="math notranslate nohighlight">\(\Psi(x)\)</span> is much larger in the outer sub-intervals than it is the middle of the domain - as we can see in the following plot.</p></li>
</ul>
<p>One of the homework exercises involves plotting the error bound - and the byproduct of multiplying things together which are very large/small is an error bound which we can indeed show gets very large with <span class="math notranslate nohighlight">\(N\)</span> and with the error largest at the end points.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot Psi for different N values:</span>
<span class="n">Ns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">20</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">Ns</span><span class="p">:</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xii</span><span class="p">)</span> <span class="k">for</span> <span class="n">xii</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Psi</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span> <span class="mf">1.e-10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Psi</span><span class="p">))</span> <span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;N=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">)</span> 
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\Psi(x)/\max({\Psi})$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Relative size of $\Psi$ across our interval&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xii</span><span class="p">)</span> <span class="k">for</span> <span class="n">xii</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Psi</span> <span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;N=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\Psi(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Absolute size of $\Psi$ across our interval&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="chebyshev-nodes-star">
<h2>Chebyshev nodes  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#chebyshev-nodes-star" title="Permalink to this heading">#</a></h2>
<p>There were three components making up the error bound - the factorial of <span class="math notranslate nohighlight">\(N+1\)</span>, a bound on the <span class="math notranslate nohighlight">\((N+1)\)</span>-st derivative of the function, and <span class="math notranslate nohighlight">\(\Psi\)</span>. For a given function and polynomial degree, we have no control over the first two, but we do have some ability to control the third, and we saw above that the behaviour of <span class="math notranslate nohighlight">\(\Psi\)</span> is indeed a problem as <span class="math notranslate nohighlight">\(N\)</span> grows.</p>
<p>The above example can be “fixed” (or at least we can attempt to do a better job) by seeking to minimise <span class="math notranslate nohighlight">\(\Psi(x)\)</span> over our entire interval (including the outer sub-intervals where above and in the homework we see there’s a clear issue).</p>
<p>For a fixed <span class="math notranslate nohighlight">\(N\)</span>, the only thing we have the ability to change is to choose different <span class="math notranslate nohighlight">\(x_i\)</span> data points, i.e. to sample our function at non-uniformly spaced <em>locations</em>.</p>
<p>Note that by the definition/construction of <span class="math notranslate nohighlight">\(\Psi\)</span>, these <em>locations</em> are the <em>roots</em> of <span class="math notranslate nohighlight">\(\Psi\)</span>, i.e. the locations where <span class="math notranslate nohighlight">\(\Psi\)</span> is zero.</p>
<br>
<p>So said another way, we want to find/select the polynomial <span class="math notranslate nohighlight">\(\Psi\)</span> that is smallest over our interval; the optimal sampling data points for our interpolation process will then be the roots of this polynomial.</p>
<p>It turns out that
<a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials#Minimal_%E2%88%9E-norm"><em>Chebyshev polynomials</em></a> have this minimal property, and hence our optimal sample points are the roots of these Chebyshev polynomials - since they are so important these points have their own name: <a class="reference external" href="https://en.wikipedia.org/wiki/Chebyshev_nodes"><em>Chebyshev nodes</em></a>.</p>
<p>The Chebyshev nodes in the interval <span class="math notranslate nohighlight">\((-1,1)\)</span> are given by the formula</p>
<div class="math notranslate nohighlight">
\[x_i = \cos \left (\frac{2i - 1}{2N}\pi \right ), \;\;\;\; i = 1, \ldots, N,\]</div>
<p>and as we will see in the following example, evaluating our function at these non-uniform locations and using this data to construct our interpolating polynomial fixes the problem we saw above for the case where we used evenly spaced data.</p>
<p>In the next cell we again compute and plot the Lagrange polynomial interpolant for differing <span class="math notranslate nohighlight">\(N\)</span>, but simply change the location of the data sampling points <code class="docutils literal notranslate"><span class="pre">xi</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we don&#39;t need to consider quite so many cases now to prove the point that</span>
<span class="c1"># things have improved substantially.</span>
<span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>

<span class="c1"># set up our figs for plotting</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># add some padding otherwise axes labels overlap</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">degree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">degrees</span><span class="p">):</span>
    <span class="c1"># use the Chebyshev nodes instead</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">degree</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="c1"># compute and plot the Lagrange polynomial using Chebyshev nodes as data locations</span>
    <span class="n">plot_approximation</span><span class="p">(</span><span class="n">runge</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># recall that this function also computes L_p</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Degree </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">degree</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="c1"># add another figure to plot Chebyshev node locations</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Locations of the Chebyshev nodes in the degree 20 case&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>We see that rather than being evenly distribute the data points are now clustered towards the extremes of the domain.</p>
<br>
</section>
<section id="chebyshev-polynomial-interpolation-star">
<h2>Chebyshev polynomial interpolation  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#chebyshev-polynomial-interpolation-star" title="Permalink to this heading">#</a></h2>
<p>This in turn leads us to a new set of basis functions which we could use as the basis for our polynomial interpolation.</p>
<p>In the same way that the values of the underlying function at our data point locations were, by construction, the weights for the Lagrange basis functions we defined above, the values of the underlying function at the non-uniform Chebyshev nodes are the weights for an interpolant which uses Chebyshev polynomials as basis functions [see homework exercise].</p>
<p>Summing, the resulting function is called the <em>Chebyshev polynomial interpolant</em>.</p>
<p>Chebyshev nodes/interpolation have many nice theoretical properties, which we won’t cover here.</p>
<p>Note that the construction of these basis functions is a homework exercise, where the exact details are explained in the question.</p>
</section>
<section id="piecewise-polynomial-interpolation">
<h2>Piecewise polynomial interpolation<a class="headerlink" href="#piecewise-polynomial-interpolation" title="Permalink to this heading">#</a></h2>
<p>An alternative approach to overcome the issues identified above which attempted to fit a <em>single</em> <em>high-degree</em> polynomial to multiple data points, is to split the data into pieces and fit a lower degree polynomial through each of these.</p>
<p>The piecewise (p/w) linear interpolation we saw near the start of this lecture would of course be an example of this.</p>
<section id="piecewise-linear-interpolant">
<h3>Piecewise-linear interpolant<a class="headerlink" href="#piecewise-linear-interpolant" title="Permalink to this heading">#</a></h3>
<p>The implementation of piecewise (p/w) linear interpolation would simply take two data points <span class="math notranslate nohighlight">\((x_i,y_i)\)</span> and <span class="math notranslate nohighlight">\((x_{i+1},y_{i+1})\)</span> in turn and fit a linear polynomial between them:</p>
<div class="math notranslate nohighlight">
\[P_1^i(x) = \frac{ y_{i+1} - y_i }{ x_{i+1} - x_i }(x - x_i) + y_i,\]</div>
<p>the superscript <span class="math notranslate nohighlight">\(i\)</span> is included to emphasise here that we are only considering one (the <span class="math notranslate nohighlight">\(i\)</span>-th) sub-interval.</p>
<p>This is easy to implement ourselves using this formula; we could reuse our Lagrange interpolation code, or indeed as we saw above simply plotting the data we get this result as well.</p>
<p>Alternatively we could just use the <code class="docutils literal notranslate"><span class="pre">numpy.polyfit</span></code> function to fit the appropriate degree polynomial to the data; we will see more on this below.</p>
</section>
<section id="piecewise-quadratic-interpolant">
<h3>Piecewise-quadratic interpolant<a class="headerlink" href="#piecewise-quadratic-interpolant" title="Permalink to this heading">#</a></h3>
<p>We can extend the linear example above by fitting a quadratic to three data points.</p>
<p>So for every 3 sets of points we fit a quadratic - to keep things simple we therefore require <span class="math notranslate nohighlight">\(3+2\times n\)</span> data points, for some integer <span class="math notranslate nohighlight">\(n\)</span> (i.e. the first set of three, and then sets of two extra as we reuse the last entry from the previous set of three as the first of the new set).  We therefore need to add a point to our example data set from above to satisfy this constraint.</p>
<p>This time we will make use of <code class="docutils literal notranslate"><span class="pre">numpy.polyfit</span></code> to construct each quadratic for simplicity.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add an extra point to our data so that we have three complete sets of data</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">])</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>

<span class="c1"># construct the interpolant at these x points for plotting</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>

<span class="c1"># initialise the value of our interpolant at x to zero</span>
<span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># loop over collections of three data points from (xi,yi), i is the mid value</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># use polyfit to construct a local quadratic polynomial fit to data at i-1, i, i+1</span>
    <span class="n">P2_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">yi</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># use polyval to evaluate P2_loc at the x values for x in [x_{i-1},x_{i+1}]</span>
    <span class="n">P2</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">P2_loc</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w linear&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w quadratic&#39;</span><span class="p">)</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;p/w linear and p/w quadratic approximations&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="observations">
<h3>Observations<a class="headerlink" href="#observations" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>An obvious drawback of this we see from both the p/w linear and p/w quadratic examples above is that we lose <em>smoothness</em> - the interpolant now has jumps in its derivative (sharp corners).</p></li>
<li><p>Since the degree two polynomial that fits through three data points is unique, we could also of course have used our Lagrange polynomial code rather than polyfit in the implementation above (ditto the linear case fit to two points). We used polyfit just to demonstrate/practice using other standard Python (NumPy) functions.</p></li>
<li><p>Note that there are p/w interpolating options which preserve smoothness to varying degrees; these include <a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">cubic splines</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite polynomials</a> which we will introduce briefly next.</p></li>
</ul>
</section>
</section>
<section id="piecewise-polynomial-interpolation-via-an-appropriate-set-of-basis-functions">
<h2>Piecewise-polynomial interpolation via an appropriate set of basis functions<a class="headerlink" href="#piecewise-polynomial-interpolation-via-an-appropriate-set-of-basis-functions" title="Permalink to this heading">#</a></h2>
<section id="the-idea">
<h3>The idea<a class="headerlink" href="#the-idea" title="Permalink to this heading">#</a></h3>
<p>Recall that in terms of basis functions (<span class="math notranslate nohighlight">\(\phi_i(x)\)</span>) we saw above how we can write a polynomial in several different ways.</p>
<p>Can we find an appropriate basis that allows us to represent a piece-wise polynomial?</p>
<p>Note that this is a vital step in the finite element method which we shall return to in a later lecture.</p>
<br>
<p>Let’s consider the expansion of our interpolating function from earlier:</p>
<div class="math notranslate nohighlight">
\[f(x) = \sum_{i=0}^N \alpha_i \phi_i(x), \]</div>
<p>what are the basis functions <span class="math notranslate nohighlight">\(\phi_i(x)\)</span> that recreate the piecewise linear interpolant?</p>
<br>
<p>A key observation is that with piecewise polynomials, linear say, it’s only the local data values that determine the behaviour of the interpolant in between the data points.</p>
<br>
<p>Note that with monomials, Lagrange basis functions etc, they are defined and have values at all <span class="math notranslate nohighlight">\(x\)</span> values, and hence a single data point value and its corresponding basis function influences the interpolant everywhere</p>
<p>(although as we will see shortly, we can if we wish specify our basis functions to be zero almost everywhere, in which case this observation is no longer true).</p>
</section>
<section id="example-revisiting-a-quadratic-example-we-ve-already-seen">
<h3>Example - revisiting a quadratic example we’ve already seen<a class="headerlink" href="#example-revisiting-a-quadratic-example-we-ve-already-seen" title="Permalink to this heading">#</a></h3>
<p>E.g. for our earlier example quadratic function <span class="math notranslate nohighlight">\(P(x)\)</span> we can consider each of the three monomial and Lagrange basis polynomials individually over the interval covered by three data points and demonstrate that with the correctly chosen weights we recover <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>For completeness, we also demonstrate this for the Newton polynomial expansion …</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First let&#39;s demonstrate how to build up our desired quadratic poly using</span>
<span class="c1"># monomial basis functions.</span>
<span class="c1"># The weights here are given by the known polynomial coefficients, i.e. 2, 3, 4</span>
<span class="c1"># while the basis functions are the constant (1), the linear (x) and the quadratic (x**2)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">P</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">+</span> <span class="mf">3.</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">4.</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">p0</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">p1</span> <span class="o">=</span>  <span class="n">x</span>
<span class="n">p2</span> <span class="o">=</span>  <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$p_0=1$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$p_1=x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$p_2=x^2$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">p0</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p1</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">p2</span><span class="p">,</span> <span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\sum \alpha_i p_i(x)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;P vs $\sum \alpha_i p_i(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$P(x)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># now let&#39;s use an expansion over the Lagrange basis functions</span>
<span class="c1"># We know that the Lagrange basis functions are chosen specially</span>
<span class="c1"># so that the corresponding weights are the data points, i.e. here</span>
<span class="c1"># alpha_i = P(x_i), with x_i = 0, 1, and 2 - this gives weights</span>
<span class="c1"># 2, 9 and 24.</span>
<span class="c1"># The basis functions are this time each quadratics - </span>
<span class="c1"># but they special quadratics # that are one at one x location, and zero at the other two:</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">P</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">+</span> <span class="mf">3.</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">4.</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">l0</span> <span class="o">=</span>  <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> 
<span class="n">l1</span> <span class="o">=</span>  <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> 
<span class="n">l2</span> <span class="o">=</span>  <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l0</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$\ell_0(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b--&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$\ell_1(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b--&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$\ell_2(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b--&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">l0</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">l1</span> <span class="o">+</span> <span class="mi">24</span><span class="o">*</span><span class="n">l2</span><span class="p">,</span> <span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$L(x)$&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;P vs L&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$P(x)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># now in the case of the Newton polynomial, for completeness</span>
<span class="c1"># The basis functions are really just shifted versions of the monomial case,</span>
<span class="c1"># and the weights are then known from the above formula</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">P</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">+</span> <span class="mf">3.</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">4.</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">n0</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
<span class="n">n1</span> <span class="o">=</span>  <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span>
<span class="n">n2</span> <span class="o">=</span>  <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">a0</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># y0</span>
<span class="n">a1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># (y1-y0)/(x1-x0)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">24</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">9</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># ((y2-y0)/(x2-x0) - (y1-y0)/(x1-x0)) / (x2-x1)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$n_0(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$n_1(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;$n_2(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a0</span><span class="o">*</span><span class="n">n0</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">n1</span> <span class="o">+</span> <span class="n">a2</span><span class="o">*</span><span class="n">n2</span><span class="p">,</span> <span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$N(x)$&#39;</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;P vs N&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$P(x)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="hat-functions-and-p-w-linear-interpolation-expansions">
<h3>Hat functions and p/w linear interpolation/expansions<a class="headerlink" href="#hat-functions-and-p-w-linear-interpolation-expansions" title="Permalink to this heading">#</a></h3>
<p>For p/w linear interpolants with a bit of thought we can come up with some appropriate basis functions, which only contribute to the full interpolant locally.</p>
<br>
<p>These are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\phi_i(x) = 
\begin{cases}
\frac{x - x_{i-1}}{\Delta x_{i-1}}, &amp;\text{if}\;\;\; x\in e_{i-1}\equiv[x_{i-1},x_{i}] \\[5pt]
\frac{x_{i+1} - x}{\Delta x_{i}}, &amp;\text{if}\;\;\; x\in e_{i}\equiv[x_{i},x_{i+1}] \\[5pt]
0, &amp; \text{otherwise} \\
\end{cases}
\end{split}\]</div>
<br>
<p>which have the name hat (or chapeau) functions, and look like the following.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/fem_basis_functions1.svg"><img alt="../_images/fem_basis_functions1.svg" src="../_images/fem_basis_functions1.svg" width="75%" /></a>
</figure>
</section>
<section id="some-code-to-return-the-hat-basis-functions">
<h3>Some code to return the hat/basis functions<a class="headerlink" href="#some-code-to-return-the-hat-basis-functions" title="Permalink to this heading">#</a></h3>
<p>Let’s implement a function that returns the <span class="math notranslate nohighlight">\(i\)</span>-th hat function on a mesh.  You can try playing with the value for <span class="math notranslate nohighlight">\(i\)</span> and seeing how it changes the plot - this code should work find if you don’t have uniform x spacing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hat_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Linear continuous basis function at node i.</span>
<span class="sd">    Returns a function for later use in quadrature rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  
                  <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">,</span>
                <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hat</span>

<span class="c1"># let&#39;s plot what this function returns</span>
<span class="c1"># first set up the nodes, a fine mesh to use to plot and the axes</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_4$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_5$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_6$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_7$&#39;</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;P1 basis function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># you can change the following to be in [0,n] to change what the </span>
<span class="c1"># function returns for a given node number</span>
<span class="n">node</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="c1"># it&#39;s returned a function phi, so just evaluate this on the mesh</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">phi</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>To see that this does what we want in terms of delivering p/w linear interpolation let’s add two of these basis functions</p>
<p>Let’s assume our <span class="math notranslate nohighlight">\((x,y)\)</span> data is <span class="math notranslate nohighlight">\((x_3,4)\)</span> and <span class="math notranslate nohighlight">\((x_4,7)\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># let&#39;s plot what this function returns</span>
<span class="c1"># first set up the nodes, a fine mesh to use to plot and the axes</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_4$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_5$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_6$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_7$&#39;</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;P1 basis function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="n">phi_l</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">phi_r</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>

<span class="c1"># plot on a fine mesh, only between the considered $x$ locations [3,4]</span>
<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">phi_l</span><span class="p">(</span><span class="n">x_fine</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">phi_r</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">4</span><span class="p">]],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>So we see that when only considered between the data point locations, we indeed have the correct linear - what does this interpolant do outside these data points?</p>
<p>Now let’s use our basis functions to construct the piecewise linear function <span class="math notranslate nohighlight">\(f_h(x)\)</span>, where the required weights are just given by the function <span class="math notranslate nohighlight">\(f\)</span> evaluates at the node locations (<code class="docutils literal notranslate"><span class="pre">y_nodes</span> <span class="pre">=</span> <span class="pre">f(x_nodes)</span></code>), for a more complex <span class="math notranslate nohighlight">\(f\)</span> function.</p>
<p>In this implementation our function returns the values of <span class="math notranslate nohighlight">\(f_h(x)\)</span> at a prescribed array of <span class="math notranslate nohighlight">\(x\)</span> locations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># start from an arbitrary function we wish to approximate/interpolate</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># discrete data</span>
<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># if we have 4 nodes, including at the ends of our domain, then we have 4-1=3 elements/cells</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>
<span class="c1"># and the element size is the total interval length divided by the number of elements</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">N_elements</span>
<span class="c1"># construct the node locations</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">N_nodes</span><span class="p">)</span>

<span class="c1"># and evaluate our function at these points - these will be our weights</span>
<span class="n">y_nodes</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>

<span class="c1"># now a function to reconstruct the p/w linear function</span>
<span class="k">def</span> <span class="nf">pwlinear</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">y_nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to return f_h(x) at locations given in x, </span>
<span class="sd">    with top hat functions on a mesh given by x_nodes, and</span>
<span class="sd">    corresponding weights given in y_nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># loop over x values, equivalently the basis functions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="c1"># which mesh node is directly to the left of x[i] ?</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x_nodes</span> <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># because of the greater than or equals above, deal with problem of hitting last node</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># add together the contributions from the two hat functions at this x location - </span>
        <span class="c1"># the hat functions centred on &quot;node&quot; (to the left)</span>
        <span class="n">phi_node</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
        <span class="c1"># and &quot;node+1&quot; (to the right)</span>
        <span class="n">phi_node_plus_1</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
        <span class="c1"># now take the weighted sum of these two hat functions</span>
        <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">*</span><span class="n">phi_node</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">y_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">phi_node_plus_1</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">f_h</span> <span class="o">=</span> <span class="n">pwlinear</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">y_nodes</span><span class="p">,</span> <span class="n">x_fine</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="c1">#ax1.set_xlabel(&#39;$x$&#39;, fontsize=16)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Interpolant reconstructed using hat functions&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f_h</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;p/w linear using hat functions&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">),</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>So as expected the expansion of these hat (basis) functions goes through the values given by the weights, with straight lines in between.</p>
<p>We can expand this to p/w higher order polynomial interpolants, e.g. by using appropriate quadratic functions only defined as being non-zero in between appropriate data locations [cf. the quadratic example above]</p>
</section>
<section id="support-of-basis-functions">
<h3>Support of basis functions<a class="headerlink" href="#support-of-basis-functions" title="Permalink to this heading">#</a></h3>
<p>An important aspect of the finite element method (which we’ll go over properly in later lecture) is appreciating when the basis functions and in particular the products of basis functions, e.g.</p>
<div class="math notranslate nohighlight">
\[\phi_i \, \phi_j\,,\]</div>
<p>are non-zero.</p>
<p>We call the area a function is non-zero its <em>support</em>, and with the FEM we are looking for this area to be finite and for each basis function for this to be confined to a small portion of the overall domain - the mathematical term is <a class="reference external" href="https://mathworld.wolfram.com/CompactSupport.html"><em>compact support</em></a>.</p>
<br>
<br>
<p>For a given value of <span class="math notranslate nohighlight">\(\,i\)</span>, based upon the above schematic for what values of <span class="math notranslate nohighlight">\(\,j\,\)</span> is the product non-zero anywhere (alternatively, for what choices of <span class="math notranslate nohighlight">\(j\)</span>, given <span class="math notranslate nohighlight">\(i\)</span>, is the product zero everywhere?).</p>
<br>
<br>
<p>Similarly note that the derivative of a basis function <span class="math notranslate nohighlight">\(\,\phi_{i,x}\,\)</span>, has the same (finite) support as <span class="math notranslate nohighlight">\(\,\phi_i\,\)</span> and hence the same compact support result holds for the products</p>
<div class="math notranslate nohighlight">
\[\phi_{i}\,\phi_{j,x}\,, \;\;\;\;\; \phi'_{i}\,\phi_{j}\,,\;\;\;\;\;\text{and}\;\;\;\; \phi'_{i}\,\phi'_{j}\,,\]</div>
<p>where the subscript “comma <span class="math notranslate nohighlight">\(x\)</span>” and the primes in the line above are just notation to indicate the <span class="math notranslate nohighlight">\(x\)</span> derivatives of the basis functions.</p>
<br>
<p>To appreciate this, first you should think about what the derivatives of these hat functions look like - this is a homework exercise.</p>
</section>
</section>
<section id="cubic-splines-star-star">
<h2>Cubic splines [<span class="math notranslate nohighlight">\(\star\star\)</span>]<a class="headerlink" href="#cubic-splines-star-star" title="Permalink to this heading">#</a></h2>
<p>This approach interpolates data with a piecewise cubic polynomial, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a>.</p>
<p>Note that as opposed to the p/w quadratic example above, a cubic spline assumes a cubic polynomial <strong>within</strong> each interval between two data points.</p>
<p>Due to the use of a cubic polynomial within each interval, this approach can now be made to be twice continuously differentiable (i.e. first as well as second order derivatives are continuous).</p>
<section id="algorithm-sketch-star-star">
<h3>Algorithm sketch  [<span class="math notranslate nohighlight">\(\star\star\)</span>]<a class="headerlink" href="#algorithm-sketch-star-star" title="Permalink to this heading">#</a></h3>
<p>The idea behind cubic splines comes from something physical:</p>
<p>Pass a thin beam or elastic ruler between the data points (often termed <em>knots</em> when talking about splines), the shape you get is a cubic spline.</p>
<p>The term spline comes form the name of the <a class="reference external" href="https://en.wikipedia.org/wiki/Flat_spline">thin flexible strip</a> used by draftsmen for engineering design before computers.</p>
<p>The deflection of the beam can be computed by solving a <a class="reference external" href="https://en.wikipedia.org/wiki/Euler%E2%80%93Bernoulli_beam_theory">fourth-degree differential equation</a>.  Since we assume that no force is applied between the knots (data points), this <em>fourth</em>-degree equation is equal to zero between knots and hence the solution is a <em>cubic</em> between them. Over the entire range of points the deflection is therefore piecewise cubic.  Hence the name <em>cubic spline</em>!</p>
<p>The first and second derivatives are continuous across the knots.</p>
<p>Given <span class="math notranslate nohighlight">\(N+1\)</span> data points, i.e. <span class="math notranslate nohighlight">\(N\)</span> intervals, we have a cubic on each interval. Each cubic has four free parameters. To uniquely define all of these parameters we therefore need <span class="math notranslate nohighlight">\(4N\)</span> pieces of information. The cubic passing through the data at the two ends of each interval gives <span class="math notranslate nohighlight">\(2N\)</span> pieces of information. Continuity of the first derivative between each interval gives <span class="math notranslate nohighlight">\(N-1\)</span> pieces of information, and continuity of the second derivative between each interval gives another <span class="math notranslate nohighlight">\(N-1\)</span> pieces of information. [Note that we assume we don’t know the exact derivative (of <span class="math notranslate nohighlight">\(f\)</span>), and hence the actual value of the derivatives of the spline are not constructed to match those of <span class="math notranslate nohighlight">\(f\)</span>].</p>
<p>We are therefore missing two pieces of information and we have several choices for what to do here.</p>
<p><em>Natural</em> cubic splines set the second derivative to zero at the start of the first interval and at the end of the last interval. This option is called <em>natural</em> since it is what would occur naturally in the beam analogy.
See <code class="docutils literal notranslate"><span class="pre">bc_type</span></code> under the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.html">Scipy documentation</a> for more options.</p>
<p>Due to the coupling between intervals a linear system needs to be solved (as written here: <a class="reference external" href="http://mathworld.wolfram.com/CubicSpline.html">http://mathworld.wolfram.com/CubicSpline.html</a>) to compute the <span class="math notranslate nohighlight">\(4N\)</span> parameters - this is generally in the form of a tridiagonal system. We will cover the solution of linear systems such as these in L3.</p>
<p>Rather than implementing ourselves we will make use of the SciPy function <a class="reference external" href="https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.interpolate.CubicSpline.html#scipy.interpolate.CubicSpline">scipy.interpolate.CubicSpline</a>.</p>
<p>[If you’re feeling brave there is a <strong>homework exercise</strong> asking you to implement cubic spline interpolation.].</p>
<p>Let’s see what it does for our data set case, as well as the problematic Runge function in the two cells below - we see that it performs well.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># consider the above example data again</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">])</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>

<span class="c1"># use SciPy to compute the cubic spline</span>
<span class="n">Pcs</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

<span class="c1"># Note we would get the same result with</span>
<span class="c1"># Pcs = si.interp1d(xi, yi, &#39;cubic&#39;, fill_value=&#39;extrapolate&#39;)</span>
<span class="c1"># and with</span>
<span class="c1"># Pcs = si.UnivariateSpline(xi, yi, s=0, k=3)</span>
<span class="c1"># where s is a smoothing parameter - s&gt;0 means we won&#39;t necessarily go through data exactly</span>
<span class="c1"># and k is the spline degree - 3 = cubic, 1 and we are back to p/w linear</span>

<span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">9.1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># Scipy actually formed a function Pcs for us that we need to evaluate at x to plot</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pcs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cubic Spline&#39;</span><span class="p">)</span>

<span class="c1"># Overlay raw data</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cubic spline approximation to our data&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s test on the Runge function which caused problems from Lagrange interpolation</span>
<span class="k">def</span> <span class="nf">runge</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">25.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>


<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">)</span>

<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">Pcs</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pcs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cubic spline&#39;</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cubic spline approximation to Runge function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># add the second subplot</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">)</span>

<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span>
<span class="n">Pcs</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pcs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cubic spline&#39;</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cubic spline approximation to Runge function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="piecewise-cubic-hermite-interpolating-polynomial-pchip-star-star">
<h2>Piecewise Cubic Hermite Interpolating Polynomial (PCHIP)  [<span class="math notranslate nohighlight">\(\star\star\)</span>]<a class="headerlink" href="#piecewise-cubic-hermite-interpolating-polynomial-pchip-star-star" title="Permalink to this heading">#</a></h2>
<p>If we drop the requirement for continuity over second derivatives with the cubic spline above (and hence the conditions that were used to fix all the free parameters in the cubic) we can choose the remaining free parameters to achieve a different goal …</p>
<p>If the (continuous) slopes between intervals are chosen in order for the interpolant to <strong>preserve monotonicity</strong> of the data then we have what is termed a <a class="reference external" href="https://uk.mathworks.com/help/matlab/ref/pchip.html"><em>p/w cubic Hermite interpolating polynomial</em></a> or a <a class="reference external" href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline"><em>cubic Hermite spline</em></a>.</p>
<p><em>Monotonicity</em> here means that the interpolant remains within the bounds of the <span class="math notranslate nohighlight">\(y\)</span>-data - <a class="reference external" href="https://en.wikipedia.org/wiki/Monotone_cubic_interpolation">https://en.wikipedia.org/wiki/Monotone_cubic_interpolation</a></p>
<p>We will make use of <a class="reference external" href="https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.interpolate.PchipInterpolator.html#scipy.interpolate.PchipInterpolator">scipy.interpolate.PchipInterpolator</a></p>
<p>Some properties:</p>
<ul class="simple">
<li><p>The interpolator preserves monotonicity in the interpolation data and does not overshoot if the data is not smooth.</p></li>
<li><p>The first derivatives are guaranteed to be continuous, but the second derivatives may jump at the <span class="math notranslate nohighlight">\(x_i\)</span> locations. So while being monotonic/bounded, the result is a bit less smooth than for cubic splines.</p></li>
</ul>
<p>Let’s see what it does for our data set case, and the problematic Runge function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># consider the above example data again</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">])</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>

<span class="n">Pchip</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

<span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">9.1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pchip</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PCHIP&#39;</span><span class="p">)</span>

<span class="c1"># Overlay raw data</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;PCHIP approximation to data, demonstrating monotonicity w.r.t. data&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s test on the Runge function which caused problems from Lagrange interpolation</span>
<span class="k">def</span> <span class="nf">runge</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">25.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>


<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">Pchip</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pchip</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PCHIP&#39;</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;PCHIP approximation to Runge function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># second subplot</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span>
<span class="n">Pchip</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pchip</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PCHIP&#39;</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;PCHIP approximation to Runge function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<section id="id2">
<h3>Observations<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Clearly within each subinterval the interpolant does not stray beyond the (<span class="math notranslate nohighlight">\(y\)</span>) bounds of the data at either end of the data (note that the simple p/w linear interpolant also has this property).</p></li>
<li><p>Note the impact of the monotonicity property on our ability to represent the peak in the Runge case.</p></li>
<li><p>Of course this problem would go away if we had a data point at the middle (which we have if we choose an odd number of data points):</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">Pchip</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pchip</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PCHIP&#39;</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">runge</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;PCHIP approximation to Runge function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="compare-interpolation-methods">
<h2>Compare interpolation methods<a class="headerlink" href="#compare-interpolation-methods" title="Permalink to this heading">#</a></h2>
<p>We’ve discussed a lot of different methods to interpolate data in this lecture. Let’s compare them:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># consider the above example data again</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">])</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>

<span class="c1"># some of the interpolators we&#39;ve seen in this lecture, evaluated using </span>
<span class="c1"># SciPy for consistency but we know that our own codes agree with those we implemented</span>
<span class="n">Plinear</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
<span class="n">PL</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">lagrange</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
<span class="n">Pcs</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
<span class="n">Pchip</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

<span class="c1"># set up figure</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">9.1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">PL</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Plinear</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w linear&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pchip</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PCHIP&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Pcs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cubic spline&#39;</span><span class="p">)</span>

<span class="c1"># Overlay raw data</span>
<span class="n">plot_raw_data</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Comparison of interpolation methods&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="quadrature">
<h2>Quadrature<a class="headerlink" href="#quadrature" title="Permalink to this heading">#</a></h2>
</section>
<section id="id3">
<h2>Review<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h2>
<p>Recall that we are seeking to calculate the area under a curve (assuming a function of one variable)</p>
<p>[volume under a surface for a function of two variables] ….</p>
<div class="math notranslate nohighlight">
\[ I := \int_{a}^{b} f\left ( x \right )\,dx, \]</div>
<p>This is the the <em>definite</em> <a class="reference external" href="http://en.wikipedia.org/wiki/Integral"><em>integral</em></a> over <span class="math notranslate nohighlight">\([a,b]\)</span> of the function <span class="math notranslate nohighlight">\(f(x)\)</span>.</p>
<p>Recall the fundamental property of a definite integral that is vital for quadrature:</p>
<div class="math notranslate nohighlight">
\[\int_{a}^{b} f\left ( x \right )\,dx = \int_{a}^{c} f\left ( x \right )\,dx + \int_{c}^{b} f\left ( x \right )\,dx,\]</div>
<p>where <span class="math notranslate nohighlight">\(c\)</span> is a point between <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>.</p>
<br>
<p>We can extend this to the finite number of points</p>
<div class="math notranslate nohighlight">
\[ a = x_0\, &lt; \,x_1\,&lt;\,x_2\,&lt;\,\ldots\,&lt;\,x_{n-1}\,&lt;x_n = b,\]</div>
<p>and then our desired integral can be written as, and thus calculated using:</p>
<div class="math notranslate nohighlight">
\[\int_{a}^{b} f\left ( x \right )\,dx = \sum_{i=0}^{n-1}  \int_{x_i}^{x_{i+1}} f\left ( x \right )\,dx,\]</div>
<p>where the <span class="math notranslate nohighlight">\(i\)</span>-th interval is defined as <span class="math notranslate nohighlight">\([x_i,x_{i+1}]\)</span> and hence <span class="math notranslate nohighlight">\(i\)</span> runs from 0 to <span class="math notranslate nohighlight">\(n-1\)</span>, and</p>
<div class="math notranslate nohighlight">
\[\bigcup\limits_{i=0}^{n-1} \, [x_i,x_{i+1}] = [a,b].\]</div>
<p>Let’s first quickly review some methods we say in Computational Mathematics</p>
</section>
<section id="the-midpoint-rule">
<h2>The Midpoint rule<a class="headerlink" href="#the-midpoint-rule" title="Permalink to this heading">#</a></h2>
<p>The <em>midpoint rule</em> is perhaps the simplest quadrature rule.</p>
<p>For reasons that should be obvious from the next figure it is sometimes also called the <em>rectangle method</em>.</p>
<p>Consider one of the subintervals <span class="math notranslate nohighlight">\(\,[x_i, x_{i+1}].\)</span></p>
<p>The midpoint rule approximates the integral over this (the <span class="math notranslate nohighlight">\(i\)</span>-th) subinterval by the area of a <em>rectangle</em>, with a base of length <span class="math notranslate nohighlight">\(\,(x_{i+1}-x_i)\,\)</span> and a height given by the value of <span class="math notranslate nohighlight">\(\,f(x)\,\)</span> at the midpoint of that interval (i.e. at <span class="math notranslate nohighlight">\(\,x=(x_{i+1}+x_i)/2\)</span>):</p>
<div class="math notranslate nohighlight">
\[ I_M^{(i)} := (x_{i+1}-x_i) \;\; \times \;\; f \left ( \frac {x_{i+1}+x_i} {2} \right ), \;\;\;\;\;\;\text{for}
\;\;\;\;\;\; 0\le i \le n-1.\]</div>
<p>The midpoint estimate of <span class="math notranslate nohighlight">\(I\)</span> then simply involves summing up over all the subintervals:</p>
<div class="math notranslate nohighlight">
\[I_M := \sum_{i=0}^{n-1} \, f \left ( \frac {x_{i+1}+x_i} {2} \right )\, (x_{i+1}-x_i).\]</div>
<br>
<p>Let’s write some code to plot the idea as well as compute an estimate of the integral using the midpoint rule.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this is a matplotlib function that allows us to easily plot rectangles</span>
<span class="c1"># which will be useful for visualising what the midpoint rule does</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>


<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="c1"># Get the value of pi from numpy and generate equally spaced values from 0 to pi.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Label axis.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)=\sin(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Approximating a function with rectangles&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Overlay a grid.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">number_intervals</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">I_M</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                            <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">I_M</span> <span class="o">+=</span> <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># use an explicit show here to force the figure to appear before the following print.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The sum of the areas of the rectangles is (I_M): </span><span class="si">{:.12f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">I_M</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">midpoint_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Our implementation of the midpoint quadrature rule.</span>
<span class="sd">    </span>
<span class="sd">    a and b are the end points for our interval of interest.</span>
<span class="sd">    </span>
<span class="sd">    &#39;function&#39; is the function of x \in [a,b] which we can evaluate as needed.</span>
<span class="sd">    </span>
<span class="sd">    number_intervals is the number of subintervals/bins we split [a,b] into.</span>
<span class="sd">    </span>
<span class="sd">    Returns the integral of function(x) over [a,b].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">number_intervals</span>

    <span class="c1"># Some examples of some asserts which might be useful here - </span>
    <span class="c1"># you should get into the habit of using these sorts of checks as much as is possible/sensible.</span>
    <span class="k">assert</span> <span class="n">interval_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
    
    <span class="c1"># Initialise to zero the variable that will contain the cumulative sum of all the areas</span>
    <span class="n">I_M</span> <span class="o">=</span> <span class="mf">0.0</span>
    
    <span class="c1"># Find the first midpoint -- i.e. the centre point of the base of the first rectangle</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">interval_size</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="c1"># and loop until we get past b, creating and summing the area of each rectangle</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">):</span>
        <span class="c1"># Find the area of the current rectangle and add it to the running total</span>
        <span class="c1"># this involves an evaluation of the function at the subinterval midpoint</span>
        <span class="n">I_M</span> <span class="o">+=</span> <span class="n">interval_size</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span>
        <span class="c1"># Move the midpoint up to the next centre of the interval</span>
        <span class="n">mid</span> <span class="o">+=</span> <span class="n">interval_size</span>

    <span class="c1"># Return our running total result</span>
    <span class="k">return</span> <span class="n">I_M</span>

<span class="c1"># check the function runs and agrees with our first version used to generate the schematic plot of the method above:</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;midpoint_rule(0, np.pi, np.sin, number_intervals=5) = &#39;</span><span class="p">,</span> <span class="n">midpoint_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="trapezoidal-rule">
<h2>Trapezoidal rule<a class="headerlink" href="#trapezoidal-rule" title="Permalink to this heading">#</a></h2>
<p>If we change the shape of the rectangle to a trapezoid (i.e. the top of the shape now being a linear line fit defined by the values of the function at the two end points of the subinterval, rather than the constant value used in the midpoint rule), we arrive at the trapezoid, or trapezoidal, rule.</p>
<p>The trapezoid rule approximates the integral by the area of a trapezoid with base <span class="math notranslate nohighlight">\((x_{i+1}-x_i)\)</span> and the left- and right-hand-sides equal to the values of the function at the two end points.</p>
<p>In this case the area of the shape approximating the integral over one subinterval, is given by:</p>
<div class="math notranslate nohighlight">
\[I_T^{(i)} := (x_{i+1}-x_i) \;\; \times \;\; 
\left( \frac {f\left ( x_{i+1}\right ) + f \left (x_{i} \right )} {2} \right)
\;\;\;\;\;\;\text{for}
\;\;\;\;\;\; 0\le i \le n-1.\]</div>
<p>The trapezoidal estimate of <span class="math notranslate nohighlight">\(I\)</span> then simply involves summing up over all the subintervals:</p>
<div class="math notranslate nohighlight">
\[I_T := \sum_{i=0}^{n-1}\,   \left(\frac{f(x_{i+1}) + f(x_{i})}{2}\right )\, (x_{i+1}-x_i). \]</div>
<p>Let’s write some code to plot the idea and compute an estimate of the integral.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this is a matplotlib function that allows us to plot polygons</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>


<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="c1"># Get the value of pi from numpy and generate equally spaced values from 0 to pi.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Label axis.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\sin(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Approximating function with trapezoids&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Overlay a grid.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">number_intervals</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">I_T</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="p">[</span>
                  <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]]),</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">I_T</span> <span class="o">+=</span> <span class="p">((</span><span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The sum of the areas of the trapezoids is (I_T): </span><span class="si">{:.12f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">I_T</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<section id="the-composite-version-of-the-trapezoidal-rule">
<h3>The composite version of the trapezoidal rule<a class="headerlink" href="#the-composite-version-of-the-trapezoidal-rule" title="Permalink to this heading">#</a></h3>
<p>Of course if we think about what we’re doing here we recognise that we can save some computational time (specifically function evaluations, which could each be very expensive so in some situations this may be especially worthwhile.).</p>
<p>Above we wrote down the mathematical expression for the scheme:</p>
<div class="math notranslate nohighlight">
\[I_T := \sum_{i=0}^{n-1}\,   \left(\frac{f(x_{i+1}) + f(x_{i})}{2}\right )\, (x_{i+1}-x_i),\]</div>
<p>(and this is <em>exactly</em> what we implemented in our code).</p>
<p>But notice that under the assumption that the <span class="math notranslate nohighlight">\(x\)</span> spacing of the data is uniform (say, <span class="math notranslate nohighlight">\(\Delta x\)</span>) this is exactly equivalent to</p>
<div class="math notranslate nohighlight">
\[I_T := [f(x_0) + 2f(x_1) + 2f(x_2) + \ldots + 2f(x_{n-1}) + f(x_n)]\frac{\Delta x}{2},\]</div>
<p>which emphasises that we can implement a version of the rule which keeps the number of function evaluations to a minimum, i.e. which reduces the cost of the naive implementation.</p>
<p>Note that this idea (minimising function evaluations) can of course also be generalised to the case where the <span class="math notranslate nohighlight">\(x\)</span> points are not equally spaced, we just can’t write the final expression in such a simple form (specifically we can’t pull out the factor <span class="math notranslate nohighlight">\(\Delta x\)</span> and have just “1” and “2” multipliers of the function values).</p>
<p>The method implemented in this manner is termed the <em>composite trapezoidal rule</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">composite_trapezoidal_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Our implementation of the trapezoidal quadrature rule - composite version&quot;&quot;&quot;</span>
    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">number_intervals</span>
    <span class="k">assert</span> <span class="n">interval_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
    <span class="n">I_T</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># Use the composite form of the rule</span>
    <span class="c1"># note that with some thought we can minimise the multiplications by 2, as well as by</span>
    <span class="c1"># the interval_size:</span>
    <span class="n">I_T</span> <span class="o">+=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">):</span>
        <span class="n">I_T</span> <span class="o">+=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>
    <span class="n">I_T</span> <span class="o">+=</span> <span class="n">function</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="c1"># Return our running total result</span>
    <span class="k">return</span> <span class="n">I_T</span> <span class="o">*</span> <span class="n">interval_size</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;composite_trapezoidal_rule(0, np.pi, np.sin, number_intervals=5) = &#39;</span><span class="p">,</span> 
      <span class="n">composite_trapezoidal_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="quadrature-accuracy-and-errors">
<h2>Quadrature Accuracy and Errors<a class="headerlink" href="#quadrature-accuracy-and-errors" title="Permalink to this heading">#</a></h2>
<p>Another observation here is that in this particular case of half a sine wave, the trapezoid rule always <em>under-estimates</em> the area, whereas the midpoint rule <em>over-estimates</em>.</p>
<p>We noted that, perhaps surprisingl, the midpoint rule is more accurate than the trapezoid rule - the reason for this is not immediately obvious from the discussions and the images above.</p>
<br>
<p>Note that the accuracy of a quadrature rule is predicted by examining its behaviour in practice with <em>polynomials</em>.</p>
<p>We say that the <strong>degree of accuracy</strong> or the <strong>degree of precision</strong> of a quadrature rule is equal to <span class="math notranslate nohighlight">\(M\)</span> if it is exact for all polynomials of degree up to and including <span class="math notranslate nohighlight">\(M\)</span>, but not exact for some polynomial of degree <span class="math notranslate nohighlight">\(M+1\)</span>.</p>
<p>Clearly both the midpoint and trapezoid rules will give the exact result for both constant and linear functions,</p>
<p>but they are not exact for quadratics</p>
<p>[you could test our codes yourself on the function <span class="math notranslate nohighlight">\(x^2\)</span> to demonstrate this].</p>
<p>Therefore, they both have a degree of precision of 1.</p>
<section id="error-analysis-qualitative">
<h3>Error analysis (qualitative)<a class="headerlink" href="#error-analysis-qualitative" title="Permalink to this heading">#</a></h3>
<p>For the “concave-down” (i.e. the first half of a sine wave) function we chose above, notice from the plot that the trapezoidal rule will <strong>consistently underestimate</strong> the area under the curve, as the line segments approximating the function are always under the concave function curve.</p>
<p>In contrast, the mid-point rule will have parts of each rectangle above and below the curve, hence to a certain extent the <strong>errors will cancel</strong> each other out.</p>
<p>This is why, <em>for this particular example</em>, the errors in the mid-point rule turn out to be approximately half those in the trapezoidal rule.</p>
<p>While this result turns out to be <em>generally</em> true for smooth functions, we can always come up with (counter) examples where the trapezoid rule will win (can you think of an example?).</p>
<p>Taylor series analysis can be used to formally construct upper bounds on the quadrature error for both methods.</p>
<p>We know that the error when integrating constant and linear functions is zero for our two rules, so let’s first consider an example of integrating a quadratic polynomial.</p>
<p>We know analytically that</p>
<div class="math notranslate nohighlight">
\[\int_{0}^{1} x^{2}\,dx = \left.\frac{1}{3}x^3\right|_0^1=\frac {1}{3}.\]</div>
<p>Whereas numerically the midpoint rule on a single interval gives an approximation of</p>
<p>\begin{equation}
I_M = 1 \left(\frac {1}{2}\right)^{2} = \frac {1}{4},
\end{equation}</p>
<p>while the trapezoidal rule gives</p>
<p>\begin{equation}
I_T = 1 \frac {0+1^{2}}{2} = \frac {1}{2}.
\end{equation}</p>
<p>The error for <span class="math notranslate nohighlight">\(I_M\)</span> is therefore <span class="math notranslate nohighlight">\(1/3 - 1/4 = 1/12\)</span>, while the error for <span class="math notranslate nohighlight">\(I_T\)</span> is <span class="math notranslate nohighlight">\(1/3 - 1/2 = -1/6\)</span>.</p>
<p>Therefore, the midpoint rule is twice as accurate as the trapezoid rule:</p>
<div class="math notranslate nohighlight">
\[|E_M| = \frac{1}{2} |E_T|,\]</div>
<p>where <span class="math notranslate nohighlight">\(|E|\)</span> indicates the error (the absolute value of the difference from the exact solution).</p>
<p>This is the case for this simple example, and we can see from the actual error values printed above that it also appears to be approximately true for the sine (which note is not a simple polynomial) case as well.</p>
<p>We will make use of this knowledge to generate new more accurate quadrature rules below [can you think of a way we might try to do this?], but first let’s sketch how you can go about a more rigorous analysis/estimation of errors.</p>
</section>
<section id="error-analysis-mathematical-star">
<h3>Error analysis (mathematical) [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#error-analysis-mathematical-star" title="Permalink to this heading">#</a></h3>
<p>We are approximating</p>
<div class="math notranslate nohighlight">
\[ I := \int_{a}^{b} f\left ( x \right )\,dx, \]</div>
<p>with a quadrature rule of the form (in the case of the Trapezoidal rule)</p>
<div class="math notranslate nohighlight">
\[I_T :=  \left(\frac{f(b) + f(a)}{2}\right )\, (b-a).\]</div>
<p>More generally (and we will develop this idea formally below where we talk about the family of Newton-Cotes quadrature rules) what we are actually doing with the midpoint and trapezoidal rules is first approximating the function <span class="math notranslate nohighlight">\(f(x)\)</span> with a <em>polynomial interpolant</em>, <span class="math notranslate nohighlight">\(P_N(x)\)</span>, over each (sub-)interval, and our approximation to the integral is given by</p>
<div class="math notranslate nohighlight">
\[
I_N := \int_a^b\,P_N(x)\,dx  \approx I,
\]</div>
<p>where <span class="math notranslate nohighlight">\(P_N(x)\)</span> is the degree <span class="math notranslate nohighlight">\(N\)</span> interpolating polynomial, and for which due to its simple form we are able to write down an expression which evaluates its integral exactly.  For the midpoint case <span class="math notranslate nohighlight">\(N=0\)</span>, while for the trapezoidal case <span class="math notranslate nohighlight">\(N=1\)</span>.</p>
<p>Note that there is a bit of <strong>scope for confusion</strong> here as we are clearly going to have (at least) two possibilities to try and improve the accuracy of our approximate integral: change the number of subintervals (<span class="math notranslate nohighlight">\(n\)</span>), or the polynomial order (<span class="math notranslate nohighlight">\(N\)</span>).</p>
<p>Let’s assume for the time being that we have a single interval that spans all of <span class="math notranslate nohighlight">\([a,b]\)</span>, i.e. assume that <span class="math notranslate nohighlight">\(n=1\)</span>.</p>
<p>Later we will apply our analysis to a subinterval <span class="math notranslate nohighlight">\([x_i,x_{i+1}]\)</span> and sum the corresponding subinterval errors to obtain an error for the version of each quadrature rule evaluated over multiple sub-intervals.</p>
<p>Recall from earlier that the error in polynomial interpolation can be written as</p>
<div class="math notranslate nohighlight">
\[ f(x) - P_N(x) =: R_N(x) = \frac{(x-x_0)(x-x_1)\cdots(x-x_N)}{(N+1)!} f^{(N+1)}(c_x) = \Psi_N(x)\frac{f^{(N+1)}(c_x)}{(N+1)!}, \]</div>
<p>where <span class="math notranslate nohighlight">\(c_x\)</span> is <em>some</em> value/point between the maximum and minimum of <span class="math notranslate nohighlight">\(x_0, \ldots, x_N\)</span> and <span class="math notranslate nohighlight">\(x\)</span>,</p>
<p>and where</p>
<div class="math notranslate nohighlight">
\[ \Psi_N(x) := \prod^N_{i=0} (x - x_i) = (x-x_0)(x-x_1)\cdots(x-x_N). \]</div>
<p>This means that our quadrature error satisfies</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
E_N 
&amp;= I - I_N = \int_{a}^{b} f\left ( x \right )\, dx - \int_a^b\,P_N\left ( x \right )\,dx \\[5pt]
&amp;= \int_{a}^{b} f\left ( x \right ) - P_N\left ( x \right ) \, dx\\[5pt] 
&amp;= \int_{a}^{b} R_N\left ( x \right )\, dx.
\end{align*}
\end{split}\]</div>
<section id="trapezoidal-rule-error-one-interval">
<h4>Trapezoidal rule error (one interval)<a class="headerlink" href="#trapezoidal-rule-error-one-interval" title="Permalink to this heading">#</a></h4>
<p>The trapezoidal rule follows from taking <span class="math notranslate nohighlight">\(N=1\)</span> in which case we have the interpolation error over the interval <span class="math notranslate nohighlight">\([a,b]\)</span>:</p>
<div class="math notranslate nohighlight">
\[R_1(x) = (x - a) (x - b) \frac{f''(c_x)}{2},\]</div>
<p>for some <span class="math notranslate nohighlight">\(c_x\in[a,b]\)</span>, and thus</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
E_T \equiv E_1 
&amp; = \int_a^b (x - a) (x - b) \frac{f''(c_x)}{2} \,dx \\[5pt]
&amp; = \frac{f''(c_x)}{2}  \int_a^b (x - a) (x - b) \,dx \\[5pt]
&amp; = \frac{f''(c_x)}{2}  \int_a^b x^2 - (a+b)x + ab  \,dx \\[5pt]
&amp; = \frac{f''(c_x)}{2}  \left[\frac{1}{3}x^3 - \frac{(a+b)}{2}x^2 + abx \right]_a^b\\[5pt]
&amp; = \frac{f''(c_x)}{2}  \left(\frac{1}{3}(b^3 - a^3) - \frac{(a+b)}{2}(b^2 - a^2) + ab(b - a) \right)\\[5pt]
&amp; = \frac{f''(c_x)}{12}  \left(2 (b^3 - a^3) - 3(a+b)(b^2 - a^2) + 6ab(b - a) \right)\\[5pt]
&amp; = \frac{f''(c_x)}{12}  \left(2 (b^3 - a^3) - 3(b^3 - a^3 +ab^2-a^2b)+ 6ab^2 - 6a^2b \right)\\[5pt]
&amp; = \frac{f''(c_x)}{12}  \left( a^3 - 3a^2b + 3ab^2 -b^3 \right)\\[5pt]
&amp; = -\frac{(b-a)^3}{12} f''(c_x).
\end{align*}
\end{split}\]</div>
</section>
<section id="id4">
<h4>Observations<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h4>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f''&gt;0\)</span> (i.e. the function is concave up), then this tells us that the error is negative (as we assume <span class="math notranslate nohighlight">\(b&gt;a\)</span>) and the trapezoidal rule in this case over-estimates the true value.</p></li>
<li><p>Similarly, if it is concave down (<span class="math notranslate nohighlight">\(f''&lt;0\)</span>) then the estimate is an under-estimate (as we saw above).</p></li>
<li><p>Over a single interval the error is cubically dependent on the interval size (interval_size = <span class="math notranslate nohighlight">\(b-a\)</span>).</p></li>
</ul>
</section>
<section id="trapezoidal-rule-error-multiple-sub-intervals">
<h4>Trapezoidal rule error (multiple sub-intervals)<a class="headerlink" href="#trapezoidal-rule-error-multiple-sub-intervals" title="Permalink to this heading">#</a></h4>
<p>The trapezoidal rule over multiple sub-intervals took the form</p>
<div class="math notranslate nohighlight">
\[ \int_{a}^{b} f\left ( x \right )\, dx \approx \sum_{i=0}^{n-1}\,   \left(\frac{f(x_{i+1}) + f(x_{i})}{2}\right )\, (x_{i+1}-x_i),\]</div>
<p>where the LHS can be written as</p>
<div class="math notranslate nohighlight">
\[ I := \int_{a}^{b} f\left ( x \right )\, dx = \sum_{i=0}^{n-1}\,   \int_{x_i}^{x_{i+1}}\,f\left ( x \right )\,dx, \]</div>
<p>and the RHS is equivalent to</p>
<div class="math notranslate nohighlight">
\[ I_T^n \equiv I_1^n := \sum_{i=0}^{n-1}\, \int_{x_i}^{x_{i+1}} \,P_1 \left ( x \right )\,dx, \]</div>
<p>the superscript <span class="math notranslate nohighlight">\(n\)</span> here is used to remind us that we are dealing with the version of the rule over <span class="math notranslate nohighlight">\(n\)</span> subintervals.</p>
<p>The error is therefore</p>
<div class="math notranslate nohighlight">
\[ E_1^n = I - I_1^n = \sum_{i=0}^{n-1}\, \int_{x_i}^{x_{i+1}} \, f \left ( x \right ) - P_1 \left ( x \right )\,dx, \]</div>
<p>i.e. the sum of the errors in the integral of the function over each subinterval.  But we can reapply our result above on the error over an arbitrary interval <span class="math notranslate nohighlight">\([a,b]\)</span> to the subinterval <span class="math notranslate nohighlight">\([x_i,x_{i+1}]\)</span> to obtain</p>
<div class="math notranslate nohighlight">
\[ E_T^n \equiv E_1^n = -\sum_{i=0}^{n-1}\, \frac{(x_{i+1}-x_i)^3}{12} f''\left(c_{x_i}\right), \]</div>
<p>for some <span class="math notranslate nohighlight">\(c_{x_i}\in[x_i,x_{i+1}]\)</span>.</p>
<p>If we assume uniform intervals then <span class="math notranslate nohighlight">\(x_{i+1}-x_i = \Delta x\)</span> and <span class="math notranslate nohighlight">\(n \Delta x = (b-a)\)</span>, and so we can rewrite this as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*} 
E_1^n &amp; = -\sum_{i=0}^{n-1}\, \frac{(x_{i+1}-x_i)^3}{12} f''\left(c_{x_i}\right) \\[5pt]
&amp; = - \sum_{i=0}^{n-1}\, \frac{\Delta x^3}{12} f''\left(c_{x_i}\right) \\[5pt]
&amp; = - \frac{\Delta x^3}{12} \sum_{i=0}^{n-1}\,f''\left(c_{x_i}\right) \\[5pt]
&amp; = - \frac{\Delta x^2}{12} \,\Delta x\, \sum_{i=0}^{n-1}\,f''\left(c_{x_i}\right) \\[5pt]
&amp; = - \frac{\Delta x^2}{12} \,\frac{(b-a)}{n}\, \sum_{i=0}^{n-1}\,f''\left(c_{x_i}\right) \\[5pt]
&amp;= -\frac{1}{12} \Delta x^2 (b-a) \frac{1}{n} \sum_{i=0}^{n-1}\,  f''\left(c_{x_i}\right).
\end{align*}
\end{split}\]</div>
<p>We can interpret the <span class="math notranslate nohighlight">\((1/n)\sum_{i=0}^{n-1}\,  f''\left(c_{x_i}\right)\)</span> term, where <span class="math notranslate nohighlight">\(c_{x_i}\)</span> for each <span class="math notranslate nohighlight">\(i\)</span> is some unknown value within each subinterval, as being a kind of average value for the second-derivative over our <em>full</em> interval <span class="math notranslate nohighlight">\([a,b]\)</span>, and as <span class="math notranslate nohighlight">\(n\)</span> is increased it converges to the average value (basically because there is a tighter and tighter constraint on each of the unknown <span class="math notranslate nohighlight">\(c_{x_i}\)</span> values).</p>
<p>This expression then indeed proves that the Trapezoidal rule is second-order accurate in the interval size <span class="math notranslate nohighlight">\(\Delta x\)</span> (or equivalently the number of subintervals).</p>
<p>Note that we can turn this error estimate into an <em>error bound</em> by replacing the average value of the second-derivative with its maximum absolute value (an average of as set always being less than or equal to its maximum absolute value):</p>
<div class="math notranslate nohighlight">
\[ \left| E_1^n \right| \le \frac{1}{12} \Delta x^2 (b-a) \max_{x\in[a,b]}\, \left| f''(x) \right|, \]</div>
<p>or as <span class="math notranslate nohighlight">\(n \Delta x = (b-a)\)</span></p>
<div class="math notranslate nohighlight">
\[ 
\boxed{\left| E_1^n \right| \le \frac{(b-a)^3}{12n^2}  \max_{x\in[a,b]}\, \left| f''(x) \right|} 
\]</div>
<br>
<p>Note further that in the limit of a large number of subintervals the mathematical expression for the average value of the second-derivative actually converges to the integral of <span class="math notranslate nohighlight">\(f''\)</span> over <span class="math notranslate nohighlight">\([a,b]\)</span>, divided by <span class="math notranslate nohighlight">\((b-a)\)</span>, which by the <a class="reference external" href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus#Second_part">fundamental theorem of calculus</a> is equal to <span class="math notranslate nohighlight">\((f'(b) - f'(a))/(b-a)\)</span> and therefore in this asymptotic limit we have</p>
<div class="math notranslate nohighlight">
\[ E_1^n = -\frac{1}{12} \Delta x^2 \left( f'(b) - f'(a) \right). \]</div>
</section>
<section id="midpoint-rule-error">
<h4>Midpoint rule error<a class="headerlink" href="#midpoint-rule-error" title="Permalink to this heading">#</a></h4>
<p>We won’t go through the same derivation for the midpoint rule here (but see the homework exercise).</p>
<p>We will simply state that the formal analysis for the midpoint rule indeed arrives at an error estimate which is exactly half that of the Trapezoidal rule, i.e.</p>
<div class="math notranslate nohighlight">
\[ 
\boxed{
\left| E_M^n \right| \le \frac{(b-a)^3}{24n^2}  \max_{x\in[a,b]}\, \left| f''(x) \right|} 
\]</div>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Riemann_sum">https://en.wikipedia.org/wiki/Riemann_sum</a> for “confirmation” of both of these error bounds - both Midpoint and Trapezoid are listed under the Methods section.</p>
<br>
<p>Note also that, as argued above, the actual signs of the Midpoint and Trapezoidal rule errors will be opposite to one another.</p>
<p>This hints to the fact that if we sum suitable multiples of the two estimates of the integral we obtain for Midpoint and Trapezoidal, we should to a certain extent be able to cancel out this error. We will do this next.</p>
</section>
</section>
</section>
<section id="simpson-s-rule-review">
<h2>Simpson’s rule [Review]<a class="headerlink" href="#simpson-s-rule-review" title="Permalink to this heading">#</a></h2>
<p>Knowing the error estimates from the two rules explored so far opens up the potential for us to combine them in an appropriate manner to create a new quadrature rule, generally more accurate than either one separately.</p>
<p>Suppose <span class="math notranslate nohighlight">\(I_S\)</span> indicates an unknown, but more accurate, estimate of the integral over an interval.</p>
<p>Then, as seen above, as <span class="math notranslate nohighlight">\(I_T\)</span> has an error that is approximately <span class="math notranslate nohighlight">\(-2\)</span> times the error in <span class="math notranslate nohighlight">\(I_M\)</span>, the following relation must hold approximately:</p>
<div class="math notranslate nohighlight">
\[I_S - I_T \approx -2 \left ( I_S - I_M\right ).\]</div>
<p>This follows from the fact that <span class="math notranslate nohighlight">\(\,I - I_T \approx -2 \left ( I - I_M\right )\)</span>, provided that <span class="math notranslate nohighlight">\(I_S\)</span> is closer to <span class="math notranslate nohighlight">\(I\)</span> than either of the other two estimates.</p>
<p>Replacing this approximately equals sign with actual equality defines <span class="math notranslate nohighlight">\(I_S\)</span> for us in terms of things we know.</p>
<p>We can rearrange this to give an expression for <span class="math notranslate nohighlight">\(I_S\)</span> that yields a more accurate estimate of the integral than either <span class="math notranslate nohighlight">\(I_M\)</span> or <span class="math notranslate nohighlight">\(I_T\)</span>:</p>
<div class="math notranslate nohighlight">
\[I_S := \frac{2}{3}I_M + \frac{1}{3}I_T.\]</div>
<p>What we’re doing here is using the fact that we know something about (the <em>leading order</em> behaviour of the) two errors, and we can therefore combine them to cancel this error to a certain extent.</p>
<p>This estimate will generally be more accurate than either <span class="math notranslate nohighlight">\(M\)</span> or <span class="math notranslate nohighlight">\(T\)</span> alone. The error won’t actually be zero in general as we’re only cancelling out the leading order term in the error, but a consequence is that we will be left with higher-degree terms in the error expansion of the new quadrature rule which should be smaller (at least in the asymptotic limit), and converge faster.</p>
<p>The resulting quadrature method in this case is known as <a class="reference external" href="http://en.wikipedia.org/wiki/Simpson%27s_rule">Simpson’s rule</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
I_S &amp;:= \frac{2}{3}I_M + \frac{1}{3}I_T \\[5pt]
&amp;= \frac{2}{3}  (b-a)f\left ( \frac{a+b}{2}\right ) + \frac{1}{3}(b-a)\frac{(f(a) + f(b))}{2} \\[5pt]
&amp; = \frac{(b-a)}{6}\left( f \left ( a\right ) + 4f \left ( c\right ) + f\left ( b\right )\right),
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are the end points of an interval and <span class="math notranslate nohighlight">\(c = \left ( a+b\right )/2\)</span> is the midpoint.</p>
<p>Note that an alternate derivation of the same rule involves fitting a <em>quadratic function</em> (i.e. <span class="math notranslate nohighlight">\(P_2(x)\)</span> rather than the constant and linear approximations already considered) that interpolates the integral at the two end points of the interval, <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, as well as at the midpoint, <span class="math notranslate nohighlight">\(c = \left ( a+b\right )/2\)</span>, and calculating the integral under that polynomial approximation.</p>
<p>See the homework exercise, and note that we’ll come back to this idea a bit later when we introduce the Newton-Cotes family of quadrature rules.</p>
<p>Let’s plot what this method is doing and compute the integral for our sine case.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this is a matplotlib function that allows us to plot polygons</span>
<span class="c1"># use this to plot the straight sides, and add an approximate</span>
<span class="c1"># quadratic at the top.</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Get the value of pi from numpy and generate equally spaced values from 0 to pi.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Label axis.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;sin(x)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Approximating a function with shapes with quadratic tops&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Overlay a grid.</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">number_intervals</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">I_S</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
    <span class="c1"># use a non-closed Polygon to visualise the straight sides of each interval </span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])]]),</span>
                          <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># add the quadratic top - fit a quadratic using numpy</span>
    <span class="n">poly_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span>
                            <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">poly_coeff</span><span class="p">)</span>
    <span class="c1"># plot the quadratic using 20 plotting points within the interval </span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">20</span><span class="p">),</span>
             <span class="n">p1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mi">20</span><span class="p">)),</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># add in the area of the interval shape to our running total using Simpson&#39;s formula</span>
    <span class="n">I_S</span> <span class="o">+=</span> <span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mf">6.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span>
                                     <span class="n">f</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Simpson&#39;s rule approximation (I_S): </span><span class="si">{:.12f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">I_S</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<section id="implementing-simpson-s-rule">
<h3>Implementing Simpson’s rule<a class="headerlink" href="#implementing-simpson-s-rule" title="Permalink to this heading">#</a></h3>
<p>Note in the above image the approximation of the quadratic over each subinterval is very good - visually it looks exact but of course it isn’t as we can exactly approximate a trigonometric function with a polynomial.</p>
<p>This is confirmed by the very accurate approximation to the integral.</p>
<p>But note that here we have had to additionally evaluate the function at the midpoints of the subintervals; we need to bear this in mind when comparing methods. With 5 subintervals the number of function evaluations we have used so far is: Midpoint - 5; Trapezoidal (the composite version) - 6; Simpson’s - 11 (that’s for the naive approach where we don’t re-use function evaluations).</p>
<p>Of course the agreement (visually and quantitatively) won’t be quite so good for complicated, rapidly varying functions.</p>
</section>
<section id="the-composite-version-of-simpson-s-rule">
<h3>The composite version of Simpson’s Rule<a class="headerlink" href="#the-composite-version-of-simpson-s-rule" title="Permalink to this heading">#</a></h3>
<p>If we assume that our interval <span class="math notranslate nohighlight">\([a,b]\)</span> has been split up into <span class="math notranslate nohighlight">\(n\)</span> intervals (or <span class="math notranslate nohighlight">\(n+1\)</span> data points) we can save some function evaluations by writing Simpson’s Rule in the following form (note here we do not introduce any additional midpoint function evaluations)</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
I_{S} 
&amp; = \frac{\Delta x}{3}\left[ f \left ( x_0\right ) + 4f \left ( x_1\right ) + 2f\left ( x_2\right ) + 4f \left ( x_3\right ) + \cdots + 2 f \left ( x_{n-2}\right )  + 4 f \left ( x_{n-1}\right ) +  f \left ( x_{n}\right ) \right]\\[5pt]
&amp; = \frac{\Delta x}{3}\left[ f \left ( x_0\right ) + 2\sum_{i=1}^{n/2 - 1} f\left(x_{2i}\right) + 4\sum_{i=1}^{n/2} f\left(x_{2i-1}\right)  +  f \left ( x_{n}\right ) \right].
\end{align*}
\end{split}\]</div>
<p>This is known as the <a class="reference external" href="http://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson.27s_rule">Composite Simpson’s rule</a>,
or more precisely the <em>composite Simpson’s 1/3 rule</em>.</p>
<p>This is the version of Simpson’s rule implemented by Scipy <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simps.html"><code class="docutils literal notranslate"><span class="pre">scipy.interpolate.simps</span></code></a>.</p>
<p>Note that this way of formulating Simpson’s rule (where we do not allow additional function evaluations at the midpoints of intervals - we assume we are only in a position to use the given data points) requires that <span class="math notranslate nohighlight">\(n\)</span> be even.</p>
<p>This way of writing the composite form in the case of <span class="math notranslate nohighlight">\(n=2\)</span> is equivalent to the formula over <span class="math notranslate nohighlight">\([a,b]\)</span> that introduced the additional midpoint location <span class="math notranslate nohighlight">\(c\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">composite_simpsons_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to evaluate the composite Simpson&#39;s rule only using</span>
<span class="sd">    function evaluations at (number_intervals + 1) points.</span>
<span class="sd">    </span>
<span class="sd">    This implementation requires that the number of subintervals (number_intervals) be even</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">number_intervals</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;number_intervals is not even&quot;</span>

    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">number_intervals</span>
    <span class="c1"># start with the two end member values</span>
    <span class="n">I_cS2</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># add in those terms with a coefficient of 4</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="c1"># and those terms with a coefficient of 2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">I_cS2</span> <span class="o">*</span> <span class="p">(</span><span class="n">interval_size</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Now let&#39;s test the Simpson&#39;s rule function.</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The exact area found by direct integration = 2&quot;</span><span class="p">)</span>
<span class="n">interval_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]</span>
<span class="n">errors_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="n">areas_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="n">areas_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="n">errors_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="n">areas_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="n">errors_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">):</span>
    <span class="n">areas_S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">composite_simpsons_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">)</span>
    <span class="n">errors_S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">areas_S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Area </span><span class="si">{:&lt;4d}</span><span class="s1"> for Simpson = </span><span class="si">{:.16f}</span><span class="s1"> (error = </span><span class="si">{:.9e}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">number_intervals</span><span class="p">,</span> <span class="n">areas_S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errors_S</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="n">areas_M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">midpoint_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">)</span>
    <span class="n">errors_M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">areas_M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">areas_T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">composite_trapezoidal_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">)</span>
    <span class="n">errors_T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">areas_T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>      
    

<span class="c1"># plot</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">errors_S</span><span class="p">,</span> <span class="s1">&#39;ro-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simpson&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">errors_T</span><span class="p">,</span> <span class="s1">&#39;bo-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Trapezoidal&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">interval_sizes</span><span class="p">,</span> <span class="n">errors_M</span><span class="p">,</span> <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Midpoint&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;log(number_intervals)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;log(error)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Quadrature rule convergence&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="n">annotation</span><span class="o">.</span><span class="n">slope_marker</span><span class="p">((</span><span class="mf">5e1</span><span class="p">,</span> <span class="mf">2e-4</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> 
                        <span class="n">size_frac</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">pad_frac</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">text_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fontsize</span> <span class="o">=</span> <span class="mi">14</span><span class="p">))</span>
<span class="n">annotation</span><span class="o">.</span><span class="n">slope_marker</span><span class="p">((</span><span class="mf">5e1</span><span class="p">,</span> <span class="mf">5e-9</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> 
                        <span class="n">size_frac</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">pad_frac</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">text_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fontsize</span> <span class="o">=</span> <span class="mi">14</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<section id="id5">
<h4>Observations<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h4>
<ul class="simple">
<li><p>The errors are lower than for the midpoint and trapezoidal rules, and the method converge more rapidly - i.e. the relative improvement only gets better for more subintervals.</p></li>
<li><p>This expression now integrates up to cubics exactly (by construction), so it has order of precision 3 (with convergence order 4 as confirmed by the convergence plot above).</p></li>
<li><p>We’re getting down to errors close to machine precision now when we use 1000 subintervals. But remember we may well either have a relatively small number of data points, or want to minimise the number of function evaluations well below this relatively high number. This will mean that for problems with lots of variation, and/or in higher dimensions, that we still work to do in improving our quadrature methods.</p></li>
<li><p>Note that there is a little bit of ambiguity over what the number of sub-intervals and number of function evaluations there are in our implementation. Here we do not evaluate the function at the mid point of an interval, instead we combine two intervals to give us the required 3 data points. Mainly we do this to agree with the behaviour of SciPy. We need to remember this when we plot on the <span class="math notranslate nohighlight">\(x\)</span> axis either number of intervals (i.e. what exactly  do we mean by this), or if we plot number of function evaluations.</p></li>
</ul>
<p>We can check that our implementation agrees with SciPy’s:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The area found by direct integration = 2&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">composite_simpsons_rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Area </span><span class="si">{0:&lt;4d}</span><span class="s1"> interval(s), </span><span class="si">{1:&lt;4d}</span><span class="s1"> function evaluations = </span><span class="si">{2:.16f}</span><span class="s1"> (error = </span><span class="si">{3:.16e}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">area</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Let&#39;s call the SciPy routine to check we get ~ the same answers:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="c1"># we have to give the SciPy function i+1 data points, </span>
    <span class="c1"># to match the i subintervals specified in our implementation</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="simpson-s-rule-error-star">
<h3>Simpson’s rule error [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#simpson-s-rule-error-star" title="Permalink to this heading">#</a></h3>
<p>We can go through the exact same mathematical steps as for the trapezoidal rule above to compute the error in Simpson’s rule applied over the full interval <span class="math notranslate nohighlight">\([a,b]\)</span> (i.e. the error over a single interval):</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
E_S 
&amp;= I - I_2 \\[5pt]
&amp;= \int_{a}^{b} \, f\left ( x \right )\, dx - \int_a^b\,P_2\left ( x \right )\,dx \\[5pt]
&amp;= \int_{a}^{b} \, f\left ( x \right ) - P_2\left ( x \right ) \, dx\\[5pt] 
&amp;= \int_{a}^{b} \, R_2\left ( x \right )\, dx \\[5pt] 
&amp;\vdots \\[5pt]
&amp;=-\frac{1}{90}\left(\frac{b-a}{2}\right)^5 f^{(4)}\left(c_x\right).
\end{align*}
\end{split}\]</div>
<p>[Remember that a superscipt number in brackets indicates a derivative - here the fourth derivative of <span class="math notranslate nohighlight">\(f\)</span>.]</p>
<p>Note this isn’t a mistake - we have gained one order of accuracy over what might have been expected due to cancellation of the leading order term.</p>
<p>This is <em>a</em> reason for the popularity of Simpson’s rule.</p>
<p>Note that all Newton-Cotes quadrature rules (introduced in a few cells) of even order have this additional order of accuracy property.</p>
<p>Summing up over <span class="math notranslate nohighlight">\(n\)</span> subintervals yields the error bound</p>
<div class="math notranslate nohighlight">
\[ 
\boxed{
\left| E_S^n \right| \;\; \le \;\;\frac{\Delta x^4}{180}  (b-a) \max_{x\in[a,b]}\, \left| f^{(4)}(x) \right| \;\; =  \;\;\frac{(b-a)^5}{180n^4}  \max_{x\in[a,b]}\, \left| f^{(4)}(x) \right|
}\]</div>
<p>where the <span class="math notranslate nohighlight">\(\Delta x\)</span> and <span class="math notranslate nohighlight">\(n\)</span> here refer to the spacing between function evaluations, and the corresponding number of subintervals (i.e. the approach we took in <code class="docutils literal notranslate"><span class="pre">composite_simpsons_rule</span></code> where we do not perform additional function evaluations at the midpoints of subintervals, but rather span two subintervals).</p>
<p>The presence of the fourth derivative in the leading order error shows that Simpson integrates third-order polynomials exactly, i.e. its degree of precision is 4.</p>
<p>The presence of the <span class="math notranslate nohighlight">\(1/n^4\)</span> factor shows that for every doubling of <span class="math notranslate nohighlight">\(n\)</span>, or halving of <span class="math notranslate nohighlight">\(\Delta x\)</span>, the error drops by a factor of 16 (i.e. <span class="math notranslate nohighlight">\(2^4\)</span>) - the method is fourth-order accurate. This agrees with what we saw in the convergence plot above.</p>
</section>
</section>
<section id="weddle-s-rule-extrapolated-simpson-s-rule-star">
<h2>Weddle’s rule (extrapolated Simpson’s rule) [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#weddle-s-rule-extrapolated-simpson-s-rule-star" title="Permalink to this heading">#</a></h2>
<p>We noted above that Simpson’s rule is fourth-order accurate.</p>
<p>Suppose we take an approximation to <span class="math notranslate nohighlight">\(I\)</span> using <span class="math notranslate nohighlight">\(n\)</span> intervals with Simpson’s rule and call the result <span class="math notranslate nohighlight">\(I_S\)</span>, and then apply Simpson’s rule with double the number of intervals (<span class="math notranslate nohighlight">\(2n\)</span>) and call the result <span class="math notranslate nohighlight">\(I_{S_2}\)</span>.</p>
<p>Then we have two estimates for the integral where we expect <span class="math notranslate nohighlight">\(I_{S_2}\)</span> to be approximately <span class="math notranslate nohighlight">\(2^4=16\)</span> times more accurate than <span class="math notranslate nohighlight">\(S\)</span>. In particular, we expect the lowest (i.e. the leading) order error term in <span class="math notranslate nohighlight">\(I_{S_2}\)</span> to be precisely one sixteenth that of <span class="math notranslate nohighlight">\(I_S\)</span>.</p>
<p>Similar to how we derived Simpson’s rule by combining what we knew of the error for the midpoint and trapezoidal rules, with this knowledge we can combine the two estimates from Simpson’s rule to derive an even more accurate estimate of <span class="math notranslate nohighlight">\(I\)</span>:</p>
<p>Let’s call this more accurate rule <span class="math notranslate nohighlight">\(I_W\)</span>, which we can find by solving:</p>
<div class="math notranslate nohighlight">
\[I_W - I_S = 16 \left ( I_W - I_{S_2} \right ),\]</div>
<p>for <span class="math notranslate nohighlight">\(I_W\)</span>.</p>
<p>A bit of manipulation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
&amp; \;\;\; I_W - I_S = 16 \left ( I_W - I_{S_2} \right ) \\[5pt]
\implies &amp; \;\;\; I_W - I_S = 16 I_W - 16 I_{S_2} \\[5pt]
\implies &amp; \;\;\; 15 I_W  = 16 I_{S_2} - I_S \\[5pt]
\implies &amp; \;\;\; 15 I_W  = 15 I_{S_2} + (I_{S_2} - I_S) ,
\end{align*}
\end{split}\]</div>
<p>leads us to the expression</p>
<div class="math notranslate nohighlight">
\[ I_W = I_{S_2} + \frac {\left (I_{S_2} - I_S \right )}{15}.\]</div>
<p>This is known as <em>Weddle’s rule</em>, or the <em>extrapolated Simpson’s rule</em> because it uses two different values for the interval size and <em>extrapolates</em> from these two to obtain an even more accurate result.</p>
<p>Making a function for this rule is easy as we can just call our Simpson’s rule functions with two values for the number of intervals.</p>
<p>Doing this is a homework exercise and should yield the following updated convergence plot</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/weddle_convergence.png"><img alt="../_images/weddle_convergence.png" src="../_images/weddle_convergence.png" style="width: 75%;" /></a>
</figure>
<section id="id6">
<h3>Observations<a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>You can see our final rule is much more accurate for fewer required intervals.</p></li>
<li><p>Indeed we are down at the limits where round-off errors are clearly affecting our results and impacting on convergence rates.</p></li>
</ul>
</section>
</section>
<section id="newton-cotes-quadrature-rules-star-star">
<h2>Newton-Cotes quadrature rules [<span class="math notranslate nohighlight">\(\star\star\)</span>]<a class="headerlink" href="#newton-cotes-quadrature-rules-star-star" title="Permalink to this heading">#</a></h2>
<p>Taking the idea behind Simpson’s rule, which can be interpreted as (or derived by) fitting a quadratic Lagrange interpolating polynomial to <em>equally spaced</em> points over an interval, and extending to any order Lagrange polynomial leads to the <em>Newton-Cotes</em> family of quadrature rules.</p>
<p>[Of course the midpoint and trapezoidal rules fit within this description as well with the fitting of a constant and a linear polynomial.]</p>
<p>Assume we have <span class="math notranslate nohighlight">\(N+1\)</span> equally spaced data points <span class="math notranslate nohighlight">\((x_i,y_i)\)</span> [we will see examples where these points are not fixed in advance below]. We will assume we are dealing with the integration of a known function and so <span class="math notranslate nohighlight">\(y_i = f(x_i)\)</span>.</p>
<p><strong>Note we are trying to be careful about the distinction between <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(N\)</span> throughout this lecture!</strong></p>
<p>We know from earlier that we can fit an order <span class="math notranslate nohighlight">\(N\)</span> polynomial exactly through these points; we call this  polynomial <span class="math notranslate nohighlight">\(P_N(x)\)</span>.</p>
<p>Recall the Lagrange form of <span class="math notranslate nohighlight">\(P_N\)</span> was defined as</p>
<div class="math notranslate nohighlight">
\[L(x) := \sum_{i=0}^{N} y_i \ell_i(x),\]</div>
<p>with the <em>Lagrange basis polynomials</em>  defined by the product</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ell_i(x) := \prod_{\begin{smallmatrix}0\le m\le N\\ m\neq i\end{smallmatrix}} \frac{x-x_m}{x_i-x_m} = \frac{(x-x_0)}{(x_i-x_0)} \cdots \frac{(x-x_{i-1})}{(x_i-x_{i-1})} \frac{(x-x_{i+1})}{(x_i-x_{i+1})} \cdots \frac{(x-x_N)}{(x_i-x_N)},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(0\le i\le N\)</span>.</p>
<p>An approximation to our integral is then given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
I &amp;\approx \int_a^b\,P_N(x)\,dx,\\[10pt]
&amp;= \sum_{i=0}^{N}\, \left[\,f(x_i) \int_a^b\, \ell_i(x)\, dx\right],\\[10pt]
&amp;=\sum_{i=0}^{N}\, A_i \, f(x_i),
\end{align*}
\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[ A_i := \int_a^b\, \ell_i(x)\, dx, \;\;\;\; i = 0,1,\ldots,N. \]</div>
<p>Simply by varying <span class="math notranslate nohighlight">\(N\)</span> we can come up with quadrature rules of arbitrary order.</p>
<p>Let’s check we can recreate the schemes we have already seen via this approach.</p>
<section id="n-1-trapezoidal">
<h3>(N=1) Trapezoidal<a class="headerlink" href="#n-1-trapezoidal" title="Permalink to this heading">#</a></h3>
<p>If <span class="math notranslate nohighlight">\(N=1\)</span> (i.e. two data points) then the Lagrange basis functions are</p>
<div class="math notranslate nohighlight">
\[\ell_0(x) = \frac{x-x_1}{x_0-x_1}= \frac{x-b}{a-b}, \;\;\;\;\;\;\;\;
\ell_1(x) = \frac{x-x_0}{x_1-x_0} = \frac{x-a}{b-a},\]</div>
<p>with integrals</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
A_0 &amp; := \int_a^b\, \ell_0(x)\, dx =  \frac{1}{a-b}\int_a^b\, (x-b)\, dx  \\[5pt]
&amp;= \frac{1}{a-b}\left[\frac{x^2}{2} - b x\right]_a^b = \frac{1}{a-b} \left[\frac{b^2 - a^2}{2} - b (b-a)\right] \\[5pt]
&amp;= -\frac 12 (a+b) + b = \frac{b-a}2,
\end{align*}
\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
A_1 &amp; := \int_a^b\, \ell_1(x)\, dx =  \frac{1}{b-a}\int_a^b\, (x-a)\, dx  \\[5pt]
&amp;= \frac{1}{b-a}\left[\frac{x^2}{2} - a x\right]_a^b = \frac{1}{b-a} \left[\frac{b^2 - a^2}{2} -a (b-a)\right] \\[5pt]
&amp;= \frac 12 (b+a) - a = \frac{b-a}2,
\end{align*}
\end{split}\]</div>
<p>and so our quadrature rule over a single interval can be written as</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
I \approx \sum_{i=0}^{1}\, A_i \, f(x_i) = 
A_0 f(a) + A_1 f(b) = (b - a)\frac{(f(a) + f(b))}{2},
\end{align*}
\]</div>
<p>which we indeed recognise as the Trapezoidal scheme from earlier.</p>
</section>
<section id="n-2-simpson-s-rule">
<h3>(N=2) Simpson’s rule<a class="headerlink" href="#n-2-simpson-s-rule" title="Permalink to this heading">#</a></h3>
<p>If we go through the same steps with <span class="math notranslate nohighlight">\(N=2\)</span> we arrive at the 1/3 Simpson rule from earlier [a homework exercise asks you to do this].</p>
<p>[NB. We could also use the <em>method of undetermined coefficients</em> and Taylor Series - we will see this approach to constructing approximations to derivatives in a later Lecture.]</p>
</section>
<section id="id7">
<h3>Observations<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Recall that fitting high-order polynomials through many (evenly spaced) data points was found to be a bad idea in the context of interpolation (we saw this in an example which used the Runge function).</p></li>
<li><p>This will of course also compromise the corresponding quadrature rules, and so we should be very careful about the use of high-order Newton-Cotes based quadrature.</p></li>
</ul>
</section>
<section id="open-vs-closed-newton-cotes-formulae">
<h3>Open vs Closed Newton-Cotes formulae<a class="headerlink" href="#open-vs-closed-newton-cotes-formulae" title="Permalink to this heading">#</a></h3>
<p>Note that there are actually two types of Newton-Cotes formulae.</p>
<ol class="arabic simple">
<li><p>“Closed” rules make use of function evaluations at the end points of an interval (e.g. all the schemes we have seen so far apart from midpoint).</p></li>
<li><p>“Open” rules do not make use of the end points - so the midpoint rule would be an example of this type of rule amongst those that we’ve considered above.</p></li>
</ol>
<p>For more information on the rules and their error bounds see <a class="reference external" href="http://mathworld.wolfram.com/Newton-CotesFormulas.html">http://mathworld.wolfram.com/Newton-CotesFormulas.html</a></p>
<p>There are sometimes advantages to not using the end points (i.e. an open formula) - for example sometimes the function being integrated is singular there, and yet the integrand is finite (see the example from the homework and corresponding convergence plot below).</p>
<p>Also it is possible that for the same number of evaluation points an open rule may be more accurate - see the section on Gaussian quadrature below.</p>
<p>For a discussion of open vs closed rules (and more generally the selection of a quadrature rule) see Section 4.12 of ‘A First Course in Numerical Analysis’, by Anthony Ralston and Philip Rabinowitz.</p>
<p>One of the homework exercises asks you to implement an open rule (e.g. Milne’s rule) and compare it with Simpson’s rule to estimate the following problem that possesses a singularity at on the end points of the total integration interva.</p>
<div class="math notranslate nohighlight">
\[I := \int_0^1 \frac{1}{\sqrt{x}}\, dx.\]</div>
<p>You should find an error plot that looks something like this</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/open_vs_closed_newton_cotes.png"><img alt="../_images/open_vs_closed_newton_cotes.png" src="../_images/open_vs_closed_newton_cotes.png" style="width: 75%;" /></a>
</figure>
<p>We have lost our theoretical order of convergence for the open rule (and the closed rule of course gives garbage) - our analysis no longer applies since the function is singular at <span class="math notranslate nohighlight">\(x=0\)</span>, and our analysis based upon Taylor series does not hold for non-smooth functions (e.g. we cannot assume that higher-order terms in the Taylor series expansion can be ignored).  But still, the open rule is doing a whole lot better than the closed rule!</p>
</section>
</section>
<section id="richardson-extrapolation-and-romberg-integration-star-star">
<h2>(Richardson) extrapolation and Romberg integration  [<span class="math notranslate nohighlight">\(\star\star\)</span>]<a class="headerlink" href="#richardson-extrapolation-and-romberg-integration-star-star" title="Permalink to this heading">#</a></h2>
<p>Note in the above that to arrive at Simpson’s rule we combined what we knew about the leading order terms in the errors for the Midpoint and Trapezoidal rules, and sought a new (more accurate) method by combining appropriate multiples of the results from the Midpoint and Trapezoidal rules to cancel the leading order errors.</p>
<p>Similarly, we also used Simpson’s rule with two different interval sizes to derive the more accurate Weddle’s rule by seeking to cancel the leading order error terms [see homework].</p>
<p>Note that we could also have used Trapezoidal with two interval sizes (one half the other) to arrive at Simpson’s rule.</p>
<p>This procedure of combining two estimates from a scheme with different interval or cell sizes is called <a class="reference external" href="https://en.wikipedia.org/wiki/Richardson_extrapolation"><em>Richardson extrapolation</em></a>; we can apply it indefinitely to derive quadrature rules of any order.</p>
<p>This idea can also be used within a recursive integration method which uses the Trapezoidal scheme at its core.</p>
<p>This method is termed <a class="reference external" href="https://en.wikipedia.org/wiki/Romberg%27s_method"><em>Romberg’s method</em></a>.</p>
<p>Since the method operates recursively until an error tolerance is reached, the required number of function evaluations (and thus the locations where data is required) is not known a priori.</p>
<p>Hence, the implementation in SciPy takes as an argument the function to be integrated itself.</p>
<p>This is in contrast to the SciPy methods we have seen above which have generally taken the pre-computed function <em>values</em> at a fixed number of points, hence it is these values rather than the underlying function which are passed as arguments. Clearly this means that Romberg integration is not suitable for situations where we only have data points and no access to an underlying function.</p>
<p>Let’s call SciPy’s Romberg integration function on our <span class="math notranslate nohighlight">\(f(x) = \sin(x)\)</span> problem to see what it does:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># The argument &#39;show = True&#39; means that it prints out its progress across steps/levels</span>
<span class="n">I_R</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">romberg</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Romberg integration error = </span><span class="si">{:.16e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">I_R</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<section id="id8">
<h3>Observations<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>We achieved an error of around 1e-12 using 33 function evaluations.</p></li>
<li><p>Notice that for an error of ~1e-12 using <code class="docutils literal notranslate"><span class="pre">composite_simpsons_rule</span></code> we required around 1000 function evaluations; for an error of ~1e-12 with Weddle’s rule we needed around 250 function evaluations.</p></li>
<li><p>A drawback of this approach is that it uses equally spaced evaluations of the function, which we know from earlier is highly problematic for certain functions when we try to go to high order. In addition it may be more efficient to space our intervals (or data points/function evaluations) in some sense based on how the variability of the function varies across our interval - this is covered next.</p></li>
</ul>
</section>
</section>
<section id="adaptive-quadrature-star">
<h2>Adaptive quadrature  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#adaptive-quadrature-star" title="Permalink to this heading">#</a></h2>
<p>We have noted above drawbacks of using equally spaced evaluations of the function, and going to too high an order of quadrature methods.</p>
<p>Adaptive quadrature seeks to address this through the use of relatively low-order quadrature rules over subintervals that can vary in size, with the size based on how much variation there is at that location in the function being integrated.</p>
<p>We will demonstrate the idea below, making use of Simpson’s rule as the base low-order method.</p>
<section id="algorithm">
<h3>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this heading">#</a></h3>
<p>By the same argument that was used to derive Weddle’s rule from Simpson’s (and indeed similar to how we derived Simpson from Midpoint and Trapezoidal) we know that approximately</p>
<p>\begin{equation}
16(I - I_{S_2}) \approx I - I_{S} ;;;; \Rightarrow ;;;;
I - I_{S_2} \approx \frac {\left(I_{S_2} - I_{S} \right)}{15},
\end{equation}</p>
<p>i.e. the error between the <span class="math notranslate nohighlight">\(I_{S_2}\)</span> approximation of the integral and the true integral <span class="math notranslate nohighlight">\(I\)</span> is approximately <span class="math notranslate nohighlight">\(1/15\)</span> the difference in <span class="math notranslate nohighlight">\(I_{S_2}\)</span> and <span class="math notranslate nohighlight">\(I_{S}\)</span>.</p>
<p>Adaptive quadrature evaluates the integral with <span class="math notranslate nohighlight">\(I_S\)</span> and <span class="math notranslate nohighlight">\(I_{S_2}\)</span> over the entire interval <span class="math notranslate nohighlight">\([a,b]\)</span>.</p>
<p>If the error estimate provided by the formula above (<span class="math notranslate nohighlight">\((I_{S_2} - I_{S})/15\)</span>) is below a <em>user-defined tolerance</em> then <span class="math notranslate nohighlight">\(I_{S_2}\)</span> is returned as the numerical approximation to the integral (actually since we know <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S_2\)</span> we might as well return the more accurate Weddle approximation: <span class="math notranslate nohighlight">\(I_W = I_{S_2} + (I_{S_2} - I_{S})/15\)</span>).</p>
<p>Otherwise the interval is split into two and the same procedure is applied recursively to each of the two intervals, the final estimate of the integral being the sum of the recursively computed half intervals.</p>
<p>Note that the recursive implementation computes explicitly <span class="math notranslate nohighlight">\(I_{S}\)</span> from <span class="math notranslate nohighlight">\(a\)</span> to the midpoint <span class="math notranslate nohighlight">\(c\)</span> and adds <span class="math notranslate nohighlight">\(I_{S}\)</span> from <span class="math notranslate nohighlight">\(c\)</span> to <span class="math notranslate nohighlight">\(b\)</span> to provide <span class="math notranslate nohighlight">\(I_{S_2}\)</span> rather than calling the Simpson function with double the number of intervals, so that the <span class="math notranslate nohighlight">\(I_{S}\)</span> from <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(c\)</span> or from <span class="math notranslate nohighlight">\(c\)</span> to <span class="math notranslate nohighlight">\(b\)</span> can be used as <span class="math notranslate nohighlight">\(I_{S}\)</span> at the next recursive layer down.</p>
<p>At every recursive layer down we halve the tolerance so that when summed the estimated total error is below our prescribed tolerance.</p>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading">#</a></h3>
<p>See the homework exercise for an implementation based upon iterative calls to our Simpson’s rule function.</p>
</section>
<section id="application-to-a-simple-problem">
<h3>Application to a simple problem<a class="headerlink" href="#application-to-a-simple-problem" title="Permalink to this heading">#</a></h3>
<p>Let’s apply this idea to our simple function. The plot below demonstrates the locations of function evaluations.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/adaptive_quadrature_simple_example.png"><img alt="../_images/adaptive_quadrature_simple_example.png" src="../_images/adaptive_quadrature_simple_example.png" style="width: 75%;" /></a>
</figure>
<br>
<br>
<p>It’s pretty clear for this example that adaptive quadrature (based on Simpson’s rule) is not going to beat Simpson’s rule applied on equally spaced intervals.</p>
<p>But the story should be different for a more complex function with some regions of rapid variation, and others with more sedate variation - let’s see an example.</p>
</section>
<section id="application-to-a-complex-problem">
<h3>Application to a complex problem<a class="headerlink" href="#application-to-a-complex-problem" title="Permalink to this heading">#</a></h3>
<p>We see in the plot below a far more complex function where we really are making good use of the ability to evaluate the function in an adaptive manner.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="Chapter9/Figures/daptive_quadrature_example.png"><img alt="Chapter9/Figures/daptive_quadrature_example.png" src="Chapter9/Figures/daptive_quadrature_example.png" style="width: 75%;" /></a>
</figure>
<br>
<p>Again, this plot is showing the non-uniform, or adaptive, locations at which the function has been evaluated by the algorith.</p>
<p>Clearly this should help with the efficiency of the method, but let’s check this.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The above example uses the following more complex function </span>
<span class="c1"># (taken from Moin which quotes the exact integral as −0.56681975015)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate.</span>
<span class="sd">    </span>
<span class="sd">    This a more complicated example which has been taken from the book by Moin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span>
            <span class="p">(</span><span class="mf">0.01</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.001</span><span class="p">))</span> <span class="o">+</span>
            <span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>

<span class="c1"># refer to the homework for the code which actually integrates this function.</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="quadrature-method-comparison">
<h2>Quadrature method comparison<a class="headerlink" href="#quadrature-method-comparison" title="Permalink to this heading">#</a></h2>
<p>Let’s compare errors vs number of function evaluations for the more complicated problem used to demonstrate adaptive quadrature.</p>
<p>Recreating this comparison/graph is given in the homework solutions that asks you to implement adaptive quadrature.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/compare_quad_methods_complex_function.png"><img alt="../_images/compare_quad_methods_complex_function.png" src="../_images/compare_quad_methods_complex_function.png" style="width: 75%;" /></a>
</figure>
<section id="comments">
<h3>Comments<a class="headerlink" href="#comments" title="Permalink to this heading">#</a></h3>
<p>Note that given the higher-order Weddle rule isn’t obviously better than Simpson’s rule for this function, at least at moderate error levels and numbers of function evaluations, it isn’t a surprise that Romberg integration doesn’t do brilliantly for this complex example either.</p>
<p>However,  this is clearly a problem which is well-suited for adaptive quadrature, as we see in the plot of the function and locations of function evaluations above - for this problem the method really is taking advantage of the ability to vary the subinterval sizes.</p>
</section>
</section>
<section id="gaussian-quadrature-star-star">
<h2>Gaussian quadrature  [<span class="math notranslate nohighlight">\(\star\star\)</span>]<a class="headerlink" href="#gaussian-quadrature-star-star" title="Permalink to this heading">#</a></h2>
<p>The quadrature rules introduced above all had the form</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
I = \int_a^b\,f(x)\,dx \approx \sum_{i=0}^{N}\, A_i \, f(x_i),
\end{align*}
\]</div>
<p>where the <em>nodes</em> (or <em>abscissas</em>) <span class="math notranslate nohighlight">\(x_i\)</span> were fixed in advance (e.g. uniformly spaced with Newton-Cotes), and with the weights <span class="math notranslate nohighlight">\(A_i\)</span> then chosen such that polynomials up to a certain order could be integrated exactly.</p>
<p>In particular, for Newton-Cotes we used Lagrange interpolation such that with our <span class="math notranslate nohighlight">\(N+1\)</span> free parameters, <span class="math notranslate nohighlight">\(A_i\)</span>, we were able to integrate exactly polynomials of order <em>N</em> (or order <span class="math notranslate nohighlight">\(N+1\)</span> in the case of even <span class="math notranslate nohighlight">\(N\)</span>).</p>
<p>The idea behind Gaussian quadrature is to start from the same formula as above, but to consider both the weights <strong>and the nodes</strong> as free parameters with which to formulate quadrature rules.</p>
<p>We thus have <span class="math notranslate nohighlight">\(2N+2\)</span> free parameters in total which can be chosen to integrate polynomials of order <span class="math notranslate nohighlight">\(2N+1\)</span> exactly.</p>
<section id="gauss-legendre-quadrature">
<h3>Gauss-Legendre quadrature<a class="headerlink" href="#gauss-legendre-quadrature" title="Permalink to this heading">#</a></h3>
<p>To action this process for a polynomial of order <span class="math notranslate nohighlight">\(2N+1\)</span> we can simply require that the individual powers (i.e. the monomials) from 0 up to <span class="math notranslate nohighlight">\(2N + 1\)</span> are integrated exactly:</p>
<div class="math notranslate nohighlight">
\[\int_{-1}^{1} x^j \,dx = \sum_{i=0}^{N}\, A_i \, f(x_i) = \sum_{i=0}^{N}\, A_i \, x_i^j
\;\;\;\;\;\;\text{for}\;\;\;\;\;\;  j = 0, 1, \dots, 2 N + 1.\]</div>
<p>This will provide us with <span class="math notranslate nohighlight">\(2N+2\)</span> pieces of information with which to figure out the <span class="math notranslate nohighlight">\(2N+2\)</span> coefficients needed to define the method.</p>
<br>
<p>In the case of <span class="math notranslate nohighlight">\(N=1\)</span>, for example, we can perform these integrals.</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\(\;j = 0\)</span>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[LHS = \int_{-1}^{1} x^0 \,dx = \int_{-1}^{1} 1 \,dx = 2,\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[RHS = \sum_{i=0}^{N}\, A_i \, x_i^0 = A_0 + A_1. \]</div>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\(\;j = 1\)</span>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[LHS = \int_{-1}^{1} x^1 \,dx = \left. \frac{1}{2}x^2 \right|_{-1}^1 = 0,\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[RHS = \sum_{i=0}^{N}\, A_i \, x_i^1 = A_0x_0 + A_1x_1, \]</div>
<p>and so on, to yield the four simultaneous equations for our four free parameters <span class="math notranslate nohighlight">\(\{x_0, x_1, A_0, A_1\}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
j &amp; = 0  &amp; A_0 + A_2 &amp; = 2 \\[5pt]
j &amp; = 1  &amp; A_0 x_0 + A_2 x_1 &amp; = 0 \\[5pt]
j &amp; = 2  &amp; A_0 x_0^2 + A_2 x_1^2 &amp; = \frac{2}{3}\\[5pt]
j &amp; = 3  &amp; A_0 x_0^3 + A_2 x_1^3 &amp; = 0,
\end{align*}
\end{split}\]</div>
<p>which we can solve to yield:</p>
<div class="math notranslate nohighlight">
\[x_0 = -\frac{1}{\sqrt{3}}, \;\;\; x_1 = \frac{1}{\sqrt{3}}, \;\;\;
A_0 = 1,\;\;\; A_1 = 1,\]</div>
<p>and so our quadrature rule is</p>
<div class="math notranslate nohighlight">
\[\int_{-1}^1 f(x)\,dx \approx f\left( -\frac{1}{\sqrt{3}} \right) +  f\left( \frac{1}{\sqrt{3}} \right).\]</div>
<p>This is termed a <em>Gauss-Legendre</em> quadrature rule, as are all methods we can derive in this manner, with differing order based on the choice of <span class="math notranslate nohighlight">\(N\)</span> and starting from the requirement that</p>
<div class="math notranslate nohighlight">
\[\int_{-1}^{1} x^j \,dx = \sum_{i=0}^{N}\, A_i \, f(x_i) = \sum_{i=0}^{N}\, A_i \, x_i^j, \;\;\;\; \text{for} \;\;\;\; j = 0, 1, \dots, 2 N + 1.\]</div>
<p>For a table of rules see <a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss%E2%80%93Legendre_quadrature">https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss–Legendre_quadrature</a>.</p>
</section>
</section>
<section id="id9">
<h2>Implementation<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h2>
<p>A nice description of the process more generally can be found here <a class="reference external" href="https://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature">https://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature</a></p>
<p>We can use SciPy to compute either fixed order <a class="reference external" href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.integrate.fixed_quad.html#scipy.integrate.fixed_quad">scipy.integrate.fixed_quad</a> or fixed tolerance <a class="reference external" href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.integrate.quadrature.html">scipy.integrate.quadrature</a> Gaussian quadrature.</p>
<p>We can also access the Gauss-Legendre quadrature rule using <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leggauss.html">numpy.polynomial.legendre.leggauss</a> as we see below.</p>
<p>NB. we can check that the <span class="math notranslate nohighlight">\(x\)</span> values for degree 2 are indeed the <span class="math notranslate nohighlight">\(\pm 1/\sqrt{3}\)</span> we calculated above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># compute the Gauss-Legendre nodes and weights</span>
<span class="n">degree</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">xi</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggauss</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Nodes, xi: &#39;</span><span class="p">,</span><span class="n">xi</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Weights, w: &#39;</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># default print precision is 8 - let&#39;s get more s.f.s</span>
<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">degrees</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggauss</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">degree </span><span class="si">{0:1d}</span><span class="s1">: </span><span class="se">\n</span><span class="s1"> x = </span><span class="si">{1}</span><span class="s1"> </span><span class="se">\n</span><span class="s1"> w = </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<section id="changing-integration-limits">
<h3>Changing integration limits<a class="headerlink" href="#changing-integration-limits" title="Permalink to this heading">#</a></h3>
<p>Note that the above derivation, and hence the locations of the nodes, were with respect to an integration limit of <span class="math notranslate nohighlight">\([-1,1]\)</span>.</p>
<p>In order to evaluate an integral over a general interval <span class="math notranslate nohighlight">\([a,b]\)</span> a change of coordinates is required, but this it not difficult to come up with or implement:</p>
<p>An appropriate transformation between <span class="math notranslate nohighlight">\(x\in[a,b]\)</span> and <span class="math notranslate nohighlight">\(\xi\in[-1,1]\)</span> is:</p>
<div class="math notranslate nohighlight">
\[x = \frac{b+a}{2} + \frac{b-a}{2}\xi,\]</div>
<p>with the weights <span class="math notranslate nohighlight">\(\xi_i\)</span> then given from the process above, e.g.</p>
<div class="math notranslate nohighlight">
\[\xi_0 = -\frac{1}{\sqrt{3}}, \;\;\; \xi_1 = \frac{1}{\sqrt{3}},\]</div>
<p>the desired integral can then be evaluated via</p>
<div class="math notranslate nohighlight">
\[\int_a^b f(x)\,dx = \frac{b-a}{2} \sum_{i=0}^{N}\, A_i \, f\left( \frac{b+a}{2} + \frac{b-a}{2}\xi_i \right).\]</div>
<p>Let’s use this knowledge to write our own Gauss-Legendre quadrature function over a single interval and apply it to our simple example function, comparing our results to the SciPy function <code class="docutils literal notranslate"><span class="pre">scipy.integrate.fixed_quad</span></code>.</p>
<p>Note that the implementation of a composite version of Gauss-Legendre is a homework exercise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function we wish to integrate&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># interval to integrate over</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="k">def</span> <span class="nf">gauss_legendre</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to evaluate Gauss Legendre quadrature</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the Gauss-Legendre nodes and weights</span>
    <span class="n">xi</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggauss</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>

    <span class="c1"># Translate the node locations from the interval [-1, 1] to [a, b]</span>
    <span class="n">x</span> <span class="o">=</span>  <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">xi</span>
 
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="n">degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span> <span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">degree</span> <span class="ow">in</span> <span class="n">degrees</span><span class="p">:</span>
    <span class="n">I_gl</span> <span class="o">=</span>  <span class="n">gauss_legendre</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="n">I_sigl</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">fixed_quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">degree</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Integrals from our code and SciPy for degree </span><span class="si">{0}</span><span class="s1"> = </span><span class="si">{1}</span><span class="s1">, </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span><span class="n">I_gl</span><span class="p">,</span><span class="n">I_sigl</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="other-gaussian-quadrature-families">
<h3>Other Gaussian quadrature families<a class="headerlink" href="#other-gaussian-quadrature-families" title="Permalink to this heading">#</a></h3>
<p>We obtained the <em>Gauss-Legendre</em> family of quadrature rules from the requirement that</p>
<div class="math notranslate nohighlight">
\[\int_{-1}^{1} x^j \,dx = \sum_{i=0}^{N}\, A_i \, f(x_i) = \sum_{i=0}^{N}\, A_i \, x_i^j, \;\;\;\; \text{for} \;\;\;\; j = 0, 1, \dots, 2 N + 1.\]</div>
<br>    
<p>If we start the exercise again, but assume we wish to evaluate integrals taking the form</p>
<div class="math notranslate nohighlight">
\[\int_{-1}^{1} w(x)f(x)\,dx,\]</div>
<p>as accurately as possible, where <span class="math notranslate nohighlight">\(w(x)\)</span> is a weighting function, then
different choices of weighting function lead us to other families of quadrature rules which are each useful for accurately integrating different types of commonly encountered functions.</p>
<p>[We arrived at the Gauss-Legendre quadrature rules above through the simplest choice of <span class="math notranslate nohighlight">\(w(x)\equiv 1\)</span>.]</p>
<p>The idea and motivation behind this is that some functions <span class="math notranslate nohighlight">\(F(x)\)</span> which are not themselves close to, or well represented by, polynomials can be rewritten in the form <span class="math notranslate nohighlight">\(F(x) = w(x)f(x)\)</span> where <span class="math notranslate nohighlight">\(f(x)\)</span> <em>is</em> close to polynomial and <span class="math notranslate nohighlight">\(w(x)\)</span> is from a known family of functions.</p>
<p>For more information see <a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_quadrature">https://en.wikipedia.org/wiki/Gaussian_quadrature</a></p>
<p>We can generalise our <code class="docutils literal notranslate"><span class="pre">gauss_legendre</span></code> code above to implement rules with standard weighting functions by accessing the appropriate pre-computed nodes and weights using, e.g.,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebgauss.html#numpy.polynomial.chebyshev.chebgauss"><code class="docutils literal notranslate"><span class="pre">numpy.polynomial.chebyshev.chebgauss</span></code></a> or <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.laggauss.html#numpy.polynomial.laguerre.laggauss"><code class="docutils literal notranslate"><span class="pre">numpy.polynomial.laguerre.laggauss</span></code></a>, etc.</p>
</section>
</section>
<section id="higher-dimensions-star">
<h2>Higher dimensions  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#higher-dimensions-star" title="Permalink to this heading">#</a></h2>
<p>In higher dimensions similar ideas to those presented above can also be applied.</p>
<p>For further reading see <a class="reference external" href="https://en.wikipedia.org/wiki/Numerical_integration#Multidimensional_integrals">https://en.wikipedia.org/wiki/Numerical_integration#Multidimensional_integrals</a>.</p>
<p>Note that sometimes higher dimensional quadrature is called “cubature”: <a class="reference external" href="http://mathworld.wolfram.com/Cubature.html">http://mathworld.wolfram.com/Cubature.html</a>.</p>
<p>For a SciPy method see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.nquad.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.nquad.html</a>.</p>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>We have taken the opportunity to revisit interpolation/the approximation of functions, and covered some new methods…</p></li>
<li><p>in particular the use of “hat” functions as a basis for p/w linear interpolation.</p></li>
<li><p>We have also revisited quadrature …</p></li>
<li><p>covering more on error analysis,</p></li>
<li><p>and in particular further families of quadrature methods, including adaptive algorithms.</p></li>
</ul>
</section>
<section id="what-do-you-need-to-focus-on">
<h2>What do you need to focus on?<a class="headerlink" href="#what-do-you-need-to-focus-on" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>General familiarity with errors and their dependence on the specifics of the numerical method, the function being considered and the interval size (or mesh resolution).</p></li>
<li><p>The specifics of the hat functions used as a basis for p/w linear interpolation.</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Chapter9"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">9. Interpolation Quadrature 2</p>
      </div>
    </a>
    <a class="right-next"
       href="Homework.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Homework <a class="tocSkip"></p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Imperial College London
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>