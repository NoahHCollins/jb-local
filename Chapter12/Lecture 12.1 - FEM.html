

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>12.1 Finite Element Methods &#8212; Modelling and Numerical Methods</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Chapter12/Lecture 12.1 - FEM';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Homework" href="Homework.html" />
    <link rel="prev" title="12. Finite Element Methods" href="intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Modelling and Numerical Methods
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Part 1 - Analytical Background</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter1/intro.html">1. Intro to Vector/Tensor Calculus</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/Lecture%201.1%20-%20Intro%20to%20Vectors.html">1.1 Continuum Mechanics and Vector Calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/Lecture%201.2%20-%20Vector%20Transformations.html">1.2 Vector Transformations  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/Lecture%201.3%20-%20Intro%20to%20Tensors.html">1.3 Intro to Tensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/exercises.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter1/solutions.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter2/intro.html">2 Stress and Tensors</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter2/Lecture%202%20-%20Stress%20and%20Tensors.html">2.1 Stress and Tensors  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter2/exercises2.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter2/solutions2.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter3/intro.html">3. Kinematics and Strain</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter3/Lecture%203%20-%20Kinematics.html">3.1 Kinematics   <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter3/exercises3.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter3/solutions3.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter4/intro.html">4. Conservation Equations</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/Lecture%204.1%20-%20Conservation%20Equations.html">4.1 Conservation Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/Lecture%204.2%20-%20Rheology.html">4.2 Rheology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/exercises4.html">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter4/solutions4.html">Solutions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter5/intro.html">5. Dimensional Analysis</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter5/Lecture%205%20-%20Dimensions%20and%20Dimensional%20Analysis.html">5.1 Dimensions and Dimensional Analysis  <a class="tocSkip"></a></a></li>





<li class="toctree-l2"><a class="reference internal" href="../Chapter5/Worksheet.html">Worksheet  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter5/Solutions.html">Solutions  <a class="tocSkip"></a></a></li>

</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part 2 - Numerical Solutions</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter6/intro.html">6. Potential Flow</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter6/Lecture%206%20-%20Potential%20Flow.html">6.1 Potential Flow  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter6/Worksheet.html">Worksheet  <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter6/Solutions.html">Solutions  <a class="tocSkip"></a></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter7/intro.html">7. Navier-Stokes</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter7/Lecture%207.1%20-%20Navier-Stokes.html">7.1 Solving Navier-Stokes Numerically</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter7/Worksheet.html">Worksheet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter7/SolversIntro.html">Solvers</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter8/intro.html">8. Turbulence and Non-Newtonian Flows</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter8/Lecture%208.1%20-%20Turbulent%20and%20Non-Newtonian%20Flows.html">8.1 Turbulent and Non-Newtonian Flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter8/Worksheet.html">Worksheet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter8/Solutions.html">Solutions</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part 3 - Numerical Techniques</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter9/intro.html">9. Interpolation Quadrature 2</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter9/Lecture%209.1%20-%20interpolation%20quadrature.html">9.1 Interpolation &amp; Quadrature 2 <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter9/Homework.html">Homework <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter9/Solutions.html">Solutions <a class="tocSkip"></a></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter10/intro.html">10. ODE Solvers 2</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter10/Lecture%2010.1%20-%20ODE%20Solver.html">10.1 ODE solvers 2 <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter10/Homework.html">Homework <a class="tocSkip"></a></a></li>

<li class="toctree-l2"><a class="reference internal" href="../Chapter10/Solutions.html">Solutions <a class="tocSkip"></a></a></li>

</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter11/intro.html">11. PDE Solvers: Finite Difference Methods 2</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter11/Lecture%2011%20-%20PDE%20Solvers%20-%20Finite%20Difference%20Methods%202.html">11.1 PDE Solvers: Finite Difference Methods 2</a></li>

<li class="toctree-l2"><a class="reference internal" href="../Chapter11/Homework.html">Homework <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter11/Solutions.html">Solutions <a class="tocSkip"></a></a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">12. Finite Element Methods</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">12.1 Finite Element Methods <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="Homework.html">Homework <a class="tocSkip"></a></a></li>
<li class="toctree-l2"><a class="reference internal" href="Solutions.html">Solutions <a class="tocSkip"></a></a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2FChapter12/Lecture 12.1 - FEM.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/Chapter12/Lecture 12.1 - FEM.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>12.1 Finite Element Methods <a class="tocSkip"></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="finite-element-methods-a-class-tocskip">
<h1>12.1 Finite Element Methods <a class="tocSkip"><a class="headerlink" href="#finite-element-methods-a-class-tocskip" title="Permalink to this heading">#</a></h1>
<p>Lecture 12.1<br />
Matt Piggott</p>
<h2>Table of Contents<span class="tocSkip"></span></h2>
<div class="toc"><ul class="toc-item"><li><span><a href="#Introduction:-finite-elements-vs-volumes-vs-differences" data-toc-modified-id="Introduction:-finite-elements-vs-volumes-vs-differences-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Introduction: finite elements vs volumes vs differences</a></span></li><li><span><a href="#Approximating-a-function" data-toc-modified-id="Approximating-a-function-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Approximating a function</a></span><ul class="toc-item"><li><span><a href="#Piecewise-polynomials" data-toc-modified-id="Piecewise-polynomials-2.1"><span class="toc-item-num">2.1&nbsp;&nbsp;</span>Piecewise-polynomials</a></span></li><li><span><a href="#An-example" data-toc-modified-id="An-example-2.2"><span class="toc-item-num">2.2&nbsp;&nbsp;</span>An example</a></span></li><li><span><a href="#Interpolation-of-a-function-(Lagrange-polynomial---a-reminder)" data-toc-modified-id="Interpolation-of-a-function-(Lagrange-polynomial---a-reminder)-2.3"><span class="toc-item-num">2.3&nbsp;&nbsp;</span>Interpolation of a function (Lagrange polynomial - a reminder)</a></span><ul class="toc-item"><li><span><a href="#Comments" data-toc-modified-id="Comments-2.3.1"><span class="toc-item-num">2.3.1&nbsp;&nbsp;</span>Comments</a></span></li></ul></li><li><span><a href="#Interpolation-errors" data-toc-modified-id="Interpolation-errors-2.4"><span class="toc-item-num">2.4&nbsp;&nbsp;</span>Interpolation errors</a></span><ul class="toc-item"><li><span><a href="#Norms" data-toc-modified-id="Norms-2.4.1"><span class="toc-item-num">2.4.1&nbsp;&nbsp;</span>Norms</a></span></li><li><span><a href="#Error-bounds-formulae--[$\star$]" data-toc-modified-id="Error-bounds-formulae--[$\star$]-2.4.2"><span class="toc-item-num">2.4.2&nbsp;&nbsp;</span>Error bounds formulae  [$\star$]</a></span></li><li><span><a href="#Comments" data-toc-modified-id="Comments-2.4.3"><span class="toc-item-num">2.4.3&nbsp;&nbsp;</span>Comments</a></span></li></ul></li></ul></li><li><span><a href="#Basis-functions-[reminder-from-a-previous-lecture]" data-toc-modified-id="Basis-functions-[reminder-from-a-previous-lecture]-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Basis functions [reminder from a previous lecture]</a></span><ul class="toc-item"><li><span><a href="#Hat-functions" data-toc-modified-id="Hat-functions-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>Hat functions</a></span></li><li><span><a href="#Support-of-basis-functions" data-toc-modified-id="Support-of-basis-functions-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>Support of basis functions</a></span></li><li><span><a href="#Some-code-to-return-the-hat/basis-functions" data-toc-modified-id="Some-code-to-return-the-hat/basis-functions-3.3"><span class="toc-item-num">3.3&nbsp;&nbsp;</span>Some code to return the hat/basis functions</a></span></li><li><span><a href="#Unstructured-mesh-data-structures" data-toc-modified-id="Unstructured-mesh-data-structures-3.4"><span class="toc-item-num">3.4&nbsp;&nbsp;</span>Unstructured mesh data structures</a></span><ul class="toc-item"><li><span><a href="#Terminology" data-toc-modified-id="Terminology-3.4.1"><span class="toc-item-num">3.4.1&nbsp;&nbsp;</span>Terminology</a></span></li></ul></li></ul></li><li><span><a href="#$L^2$-projection-of-a-function" data-toc-modified-id="$L^2$-projection-of-a-function-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>$L^2$ projection of a function</a></span><ul class="toc-item"><li><span><a href="#Theory" data-toc-modified-id="Theory-4.1"><span class="toc-item-num">4.1&nbsp;&nbsp;</span>Theory</a></span><ul class="toc-item"><li><span><a href="#Finite-dimensional-example" data-toc-modified-id="Finite-dimensional-example-4.1.1"><span class="toc-item-num">4.1.1&nbsp;&nbsp;</span>Finite-dimensional example</a></span></li></ul></li><li><span><a href="#Theory---continued" data-toc-modified-id="Theory---continued-4.2"><span class="toc-item-num">4.2&nbsp;&nbsp;</span>Theory - continued</a></span></li><li><span><a href="#Link-to-the-finite-element-method" data-toc-modified-id="Link-to-the-finite-element-method-4.3"><span class="toc-item-num">4.3&nbsp;&nbsp;</span>Link to the finite element method</a></span></li><li><span><a href="#Implementation---the-mass-matrix" data-toc-modified-id="Implementation---the-mass-matrix-4.4"><span class="toc-item-num">4.4&nbsp;&nbsp;</span>Implementation - the mass matrix</a></span></li><li><span><a href="#Implementation-in-code" data-toc-modified-id="Implementation-in-code-4.5"><span class="toc-item-num">4.5&nbsp;&nbsp;</span>Implementation in code</a></span></li><li><span><a href="#Quadrature" data-toc-modified-id="Quadrature-4.6"><span class="toc-item-num">4.6&nbsp;&nbsp;</span>Quadrature</a></span><ul class="toc-item"><li><span><a href="#Application-of-Simpson's-rule-[$\star$]" data-toc-modified-id="Application-of-Simpson's-rule-[$\star$]-4.6.1"><span class="toc-item-num">4.6.1&nbsp;&nbsp;</span>Application of Simpson's rule [$\star$]</a></span></li></ul></li><li><span><a href="#Approximation-using-a-continuous-function" data-toc-modified-id="Approximation-using-a-continuous-function-4.7"><span class="toc-item-num">4.7&nbsp;&nbsp;</span>Approximation using a continuous function</a></span></li><li><span><a href="#Quality-of-approximation" data-toc-modified-id="Quality-of-approximation-4.8"><span class="toc-item-num">4.8&nbsp;&nbsp;</span>Quality of approximation</a></span></li><li><span><a href="#RMS-(root-mean-square)-vs-$L^2$-norm-[reminder-from-Comp-Math]" data-toc-modified-id="RMS-(root-mean-square)-vs-$L^2$-norm-[reminder-from-Comp-Math]-4.9"><span class="toc-item-num">4.9&nbsp;&nbsp;</span>RMS (root mean square) vs $L^2$ norm [reminder from Comp Math]</a></span></li></ul></li><li><span><a href="#Solving-boundary-value-problems-(BVPs)-using-the-FEM" data-toc-modified-id="Solving-boundary-value-problems-(BVPs)-using-the-FEM-5"><span class="toc-item-num">5&nbsp;&nbsp;</span>Solving boundary value problems (BVPs) using the FEM</a></span><ul class="toc-item"><li><span><a href="#The-fundamental-form-of-the-discretisation-ignoring-BCs" data-toc-modified-id="The-fundamental-form-of-the-discretisation-ignoring-BCs-5.1"><span class="toc-item-num">5.1&nbsp;&nbsp;</span>The fundamental form of the discretisation ignoring BCs</a></span><ul class="toc-item"><li><span><a href="#Weak-or-variational-form-of-problem" data-toc-modified-id="Weak-or-variational-form-of-problem-5.1.1"><span class="toc-item-num">5.1.1&nbsp;&nbsp;</span>Weak or variational form of problem</a></span></li><li><span><a href="#Discretisation-by-restricting-the-function-space-to-be-finite-dimensional" data-toc-modified-id="Discretisation-by-restricting-the-function-space-to-be-finite-dimensional-5.1.2"><span class="toc-item-num">5.1.2&nbsp;&nbsp;</span>Discretisation by restricting the function space to be finite-dimensional</a></span></li><li><span><a href="#Choice-of-basis-functions-(a.k.a.-choice-of-function-space-a.k.a.-choice-of-&quot;finite-element&quot;)" data-toc-modified-id="Choice-of-basis-functions-(a.k.a.-choice-of-function-space-a.k.a.-choice-of-&quot;finite-element&quot;)-5.1.3"><span class="toc-item-num">5.1.3&nbsp;&nbsp;</span>Choice of basis functions (a.k.a. choice of function space a.k.a. choice of "finite element")</a></span></li><li><span><a href="#Finite-element-approximation" data-toc-modified-id="Finite-element-approximation-5.1.4"><span class="toc-item-num">5.1.4&nbsp;&nbsp;</span>Finite element approximation</a></span></li><li><span><a href="#Terminology" data-toc-modified-id="Terminology-5.1.5"><span class="toc-item-num">5.1.5&nbsp;&nbsp;</span>Terminology</a></span></li><li><span><a href="#Implementation" data-toc-modified-id="Implementation-5.1.6"><span class="toc-item-num">5.1.6&nbsp;&nbsp;</span>Implementation</a></span></li></ul></li><li><span><a href="#A-simple-problem-with-homogeneous-Dirichlet-BCs" data-toc-modified-id="A-simple-problem-with-homogeneous-Dirichlet-BCs-5.2"><span class="toc-item-num">5.2&nbsp;&nbsp;</span>A simple problem with homogeneous Dirichlet BCs</a></span><ul class="toc-item"><li><span><a href="#Problem-description" data-toc-modified-id="Problem-description-5.2.1"><span class="toc-item-num">5.2.1&nbsp;&nbsp;</span>Problem description</a></span></li><li><span><a href="#Finite-element-approximation" data-toc-modified-id="Finite-element-approximation-5.2.2"><span class="toc-item-num">5.2.2&nbsp;&nbsp;</span>Finite element approximation</a></span></li><li><span><a href="#Comments" data-toc-modified-id="Comments-5.2.3"><span class="toc-item-num">5.2.3&nbsp;&nbsp;</span>Comments</a></span></li></ul></li></ul></li><li><span><a href="#Practical-implementation-of-the-FEM---local-assembly-over-elements" data-toc-modified-id="Practical-implementation-of-the-FEM---local-assembly-over-elements-6"><span class="toc-item-num">6&nbsp;&nbsp;</span>Practical implementation of the FEM - local assembly over elements</a></span><ul class="toc-item"><li><span><a href="#The-underlying-idea" data-toc-modified-id="The-underlying-idea-6.1"><span class="toc-item-num">6.1&nbsp;&nbsp;</span>The underlying idea</a></span></li><li><span><a href="#Local-assembly-for-the-mass-matrix" data-toc-modified-id="Local-assembly-for-the-mass-matrix-6.2"><span class="toc-item-num">6.2&nbsp;&nbsp;</span>Local assembly for the mass matrix</a></span></li><li><span><a href="#Example---projection" data-toc-modified-id="Example---projection-6.3"><span class="toc-item-num">6.3&nbsp;&nbsp;</span>Example - projection</a></span></li><li><span><a href="#Unstructured-mesh-data-structures-(the-connectivity-matrix)" data-toc-modified-id="Unstructured-mesh-data-structures-(the-connectivity-matrix)-6.4"><span class="toc-item-num">6.4&nbsp;&nbsp;</span>Unstructured mesh data structures (the connectivity matrix)</a></span></li><li><span><a href="#Quadrature-over-the-local-element-(change-of-variables-to-a-reference-element)" data-toc-modified-id="Quadrature-over-the-local-element-(change-of-variables-to-a-reference-element)-6.5"><span class="toc-item-num">6.5&nbsp;&nbsp;</span>Quadrature over the local element (change of variables to a reference element)</a></span></li><li><span><a href="#Transformation-to-the-reference-element" data-toc-modified-id="Transformation-to-the-reference-element-6.6"><span class="toc-item-num">6.6&nbsp;&nbsp;</span>Transformation to the reference element</a></span><ul class="toc-item"><li><span><a href="#Aside:-quadratic-basis-functions" data-toc-modified-id="Aside:-quadratic-basis-functions-6.6.1"><span class="toc-item-num">6.6.1&nbsp;&nbsp;</span>Aside: quadratic basis functions</a></span></li></ul></li><li><span><a href="#Local-assembly-for-integrands-that-involve-derivatives" data-toc-modified-id="Local-assembly-for-integrands-that-involve-derivatives-6.7"><span class="toc-item-num">6.7&nbsp;&nbsp;</span>Local assembly for integrands that involve derivatives</a></span></li></ul></li><li><span><a href="#Using-the-FEM-to-solve-time-dependent-PDEs" data-toc-modified-id="Using-the-FEM-to-solve-time-dependent-PDEs-7"><span class="toc-item-num">7&nbsp;&nbsp;</span>Using the FEM to solve time-dependent PDEs</a></span></li><li><span><a href="#Higher-dimensions-and-unstructured-meshes" data-toc-modified-id="Higher-dimensions-and-unstructured-meshes-8"><span class="toc-item-num">8&nbsp;&nbsp;</span>Higher dimensions and unstructured meshes</a></span></li><li><span><a href="#Final-comments" data-toc-modified-id="Final-comments-9"><span class="toc-item-num">9&nbsp;&nbsp;</span>Final comments</a></span></li><li><span><a href="#The-perodic-table-of-finite-elements" data-toc-modified-id="The-perodic-table-of-finite-elements-10"><span class="toc-item-num">10&nbsp;&nbsp;</span>The perodic table of finite elements</a></span></li></ul></div><section id="learning-objectives-a-class-tocskip">
<h2>Learning objectives <a class="tocSkip"><a class="headerlink" href="#learning-objectives-a-class-tocskip" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>To introduce the finite element method</p></li>
<li><p>To review how basis functions can be used to approximate functions,</p></li>
<li><p>and in turn how this idea can be used to <em><strong>project</strong></em> functions, as well as to <em><strong>solve</strong></em> differential equations</p></li>
<li><p>To understand how different types of BCs can be dealt with in the FEM</p></li>
<li><p>To understand the local <em><strong>assembly</strong></em> process which is the implementation approach that allows us to readily extend 1D FEM ideas to higher dimensions</p></li>
</ul>
<br>
<br>
<p>I’ll try to split the material up into three key topics</p>
<ul class="simple">
<li><p>Projection of a function (basically the FEM without the need to deal with any derivatives)</p></li>
<li><p>Solution of a BVP (the introduction of derivatives w.r.t. a single independent variable)</p></li>
<li><p>How local assembly can be used to achieve an implementation in code which readily extends things efficiently to complex tesselations of the domain in higher dimensions.</p></li>
</ul>
</section>
<section id="introductory-comments-a-class-tocskip">
<h2>Introductory comments <a class="tocSkip"><a class="headerlink" href="#introductory-comments-a-class-tocskip" title="Permalink to this heading">#</a></h2>
<p>Note that there are numerous ways that the finite element method can be introduced and derived.</p>
<p>A significant subset of these go about this task in a very abstract/mathematical way.</p>
<p>Here we will take a more practical perspective, but be warned if you pick up a random textbook it may well go about things in a very different manner. Ultimately though we will end up at the same place.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">precision</span> 6
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">si</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">sl</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">spla</span>
<span class="c1"># the following allows us to plot triangles indicating convergence order</span>
<span class="kn">from</span> <span class="nn">mpltools</span> <span class="kn">import</span> <span class="n">annotation</span>
<span class="c1"># as we&#39;re in 2D we will be doing some 3D plotting</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="c1"># and using some colormaps</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="c1"># some default font sizes for plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sans-serif&#39;</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.sans-serif&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Arial&#39;</span><span class="p">,</span> <span class="s1">&#39;Dejavu Sans&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="introduction-finite-elements-vs-volumes-vs-differences">
<h2>Introduction: finite elements vs volumes vs differences<a class="headerlink" href="#introduction-finite-elements-vs-volumes-vs-differences" title="Permalink to this heading">#</a></h2>
<p>The finite element method can be interpreted in a way that sets it somewhat apart from finite difference and finite volume methods.</p>
<p>In any numerical method our aim is generally to replace or approximate something that is continuous (infinite dimensional) with something that is discrete (finite dimensional). We need to do this in order to allow us to find the approximation on a finite computer.</p>
<p>FD and FV methods sought to approximate derivatives or fluxes in the underlying equation in terms of discrete (i.e. discretised) solution information, i.e. it “discretised the underlying equation”.
In 1D in particularly FD and FV aren’t that different conceptually and lead to similar and even identical discretisations.</p>
<p>The finite element method however is a little different - it takes an approach that approximates/discretises the numerical <em>solution</em> (function) but then asks that this solves the <em>exact</em> differential equation problem (in a weak sense).</p>
<p>It is this approach, which approximates the solution function and not the underlying equation, that is the reason that (a) the approach can (is often) explained in quite a theoretical way, and (b) many powerful/useful theoretical results on errors, stability etc can be obtained.</p>
<p>The exact solution to a differential equation is a continuous function. And this function lives in an infinite-dimensional space of all possible functions (that satisfy some appropriate constraints, e.g. on their smoothness) and which is defined everywhere in space and time (in the case of time-dependent PDEs).</p>
<p>To (attempt to) find the exact solution analytically we can take derivatives of candidate solution functions and look for the one which satisfies our underlying PDE.</p>
<p>What we want to do here is approximate (discretise) this complex continuous function in a way that it becomes finite-dimensional, but such that it is still differentiable and we are therefore able to ask that it still satisfies our exact problem (in an appropriate sense to be explained later).</p>
<p>Note the difference with FD methods where we look for discrete solution values which satisfy the discretised PDE at a series of distinct points where we have replaced the derivatives with finite difference approximations.</p>
<p>With FEM we will therefore arrive at a solution that is equally valid everywhere, rather than just at discrete points.</p>
<p>This may all sound a little abstract, but hopefully things will become clear as we work through examples.</p>
<p>Rather than diving straight into discretising a differential equation problem, we will start our discussion of the finite element method by first considering ways in which we can approximate/discretise a function (which we can think of as the exact solution to our differential equation).</p>
</section>
<section id="approximating-a-function">
<h2>Approximating a function<a class="headerlink" href="#approximating-a-function" title="Permalink to this heading">#</a></h2>
</section>
<section id="piecewise-polynomials">
<h2>Piecewise-polynomials<a class="headerlink" href="#piecewise-polynomials" title="Permalink to this heading">#</a></h2>
<p>One way to start a description of the finite element method is to consider how we can approximate functions.</p>
<p>Suppose we have a function <span class="math notranslate nohighlight">\(f(x)\)</span> and approximate it using a finite number of basis functions:</p>
<div class="math notranslate nohighlight">
\[f_h(x) = \sum_{i=0}^N \alpha_i \phi_i(x). \]</div>
<p>So <span class="math notranslate nohighlight">\(f_h(x)\approx f(x)\)</span> where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha_i\)</span> for <span class="math notranslate nohighlight">\(i=0,\,\ldots, N\)</span> are the finite number of <em>weights</em> we need to find.</p></li>
<li><p><span class="math notranslate nohighlight">\(\phi_i(x)\)</span> for <span class="math notranslate nohighlight">\(i=0,\,\ldots, N\)</span> are a finite number of prescribed <em>basis functions</em>.</p></li>
</ul>
<p>Note that while <span class="math notranslate nohighlight">\(f(x)\)</span> is continuous and potentially very complex (e.g. cannot be defined simply in terms of a finite number of parameters), the approximation <span class="math notranslate nohighlight">\(f_h(x)\)</span> is effectively finite-dimensional as it is completely described by the <span class="math notranslate nohighlight">\(N+1\)</span> weights (we assume the basis functions are chosen/given in advance).</p>
<p>Importantly, and different to the numerical solutions obtained with FD methods, the approximation <span class="math notranslate nohighlight">\(f_h(x)\)</span> is defined for all values of <span class="math notranslate nohighlight">\(x\)</span>,  and we can take its true derivatives that will also be defined everywhere (i.e. not need to use finite difference approximations of derivatives as we would with the FD method).</p>
<br>
<p>With this form of approximation there are actually a huge number of possibilities for us to proceed.</p>
<p>Firstly note that we haven’t said anything about the nature of the basis functions <span class="math notranslate nohighlight">\(\phi_i(x)\)</span>.</p>
<p>One option is for these to be so-called <em>global</em> functions, in that they are defined for all <span class="math notranslate nohighlight">\(x\)</span> and are potentially non-zero across the total range of <span class="math notranslate nohighlight">\(x\)</span> values, e.g. this would be the case with Fourier series approximations (or in the numerical solution of differential equations this would lead us to so-called <a class="reference external" href="https://en.wikipedia.org/wiki/Spectral_method"><em>spectral methods</em></a>).</p>
<p>However, an important aspect of the finite element method is that these basis functions are chosen to have <em>finite support</em>, i.e. they are only non-zero over a limited range of <span class="math notranslate nohighlight">\(x\)</span> values (we will see below that this is a property we seek in order to ultimately arrive at a point where we need to solve linear systems involving <em>sparse</em> rather than dense matrices).</p>
<p>In addition, we look for basis functions which are easy to integrate.  The finite element method generally makes use of piecewise polynomial basis functions, which leads to our approximation <span class="math notranslate nohighlight">\(f_h(x)\)</span> being a piecewise polynomial.</p>
</section>
<section id="an-example">
<h2>An example<a class="headerlink" href="#an-example" title="Permalink to this heading">#</a></h2>
<p>To help clarify these ideas let’s consider a continuous and relatively complex function:</p>
<div class="math notranslate nohighlight">
\[ f(x) = \sin(2\pi x) + \frac{3}{10}\cos(6\pi x^2).\]</div>
<p>First let’s plot this over the interval <span class="math notranslate nohighlight">\([0,1]\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span> <span class="p">,</span><span class="mf">1.</span> <span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Function approximation&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/5d3be4e65a4161089f67064dbe2e670c6b38ed4cf05ae5bf6a35a52bf57bfa59.png" src="../_images/5d3be4e65a4161089f67064dbe2e670c6b38ed4cf05ae5bf6a35a52bf57bfa59.png" />
</div>
</div>
</section>
<section id="interpolation-of-a-function-lagrange-polynomial-a-reminder">
<h2>Interpolation of a function (Lagrange polynomial - a reminder)<a class="headerlink" href="#interpolation-of-a-function-lagrange-polynomial-a-reminder" title="Permalink to this heading">#</a></h2>
<p>Perhaps the obvious way to approximate this with a sum over piecewise polynomials is to construct the piecewise linear interpolant, as we did in the lectures on interpolation.</p>
<p>We take a finite number of sample points (we assume 4 evenly distributed points in the examples below), and then for every pair of these find the linear polynomial that passes through or joins them.</p>
<p>We made the point in L1 that this is what you get if you plot the discrete data using default plotting options, but let’s remind ourselves how we can use <code class="docutils literal notranslate"><span class="pre">numpy.polyfit</span></code> to find the linear polynomial approximation in between each pair of sample points.</p>
<p>For each pair of points this will provide an infinite line - we only want to use each line between each appropraite pair of points:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># discrete data</span>
<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># if we have 4 nodes, including at the ends of our domain, then we have 4-1=3 elements/cells</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>
<span class="c1"># and the element size is the total interval length divided by the number of elements</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">N_elements</span>
<span class="c1"># construct the node locations</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">N_nodes</span><span class="p">)</span>
<span class="c1"># and evaluate our example function f(.) at these points</span>
<span class="n">y_nodes</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>
<span class="c1"># define a much finer mesh for plotting purposes</span>
<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span> <span class="p">,</span><span class="mf">1.</span> <span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="c1"># initialise the value of our interpolant at x_fine to zero </span>
<span class="c1"># [see interpolation lecture for a similar p/w quadratic example we considered]</span>
<span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x_fine</span><span class="p">)</span>
<span class="c1"># loop over each pair of data points </span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_elements</span><span class="p">):</span>
    <span class="c1"># use polyfit to construct a linear polynomial fit to the data at nodes i and i+1</span>
    <span class="n">P1_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">y_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># use polyval to evaluate P1_loc at the x_fine values, </span>
    <span class="c1"># but only for those values in the local interval [x_{i},x_{i+1}]</span>
    <span class="n">P1</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">P1_loc</span><span class="p">,</span> <span class="n">x_fine</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_fine</span> <span class="o">&gt;=</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_fine</span> <span class="o">&lt;=</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="c1">#ax1.set_xlabel(&#39;$x$&#39;, fontsize=16)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Function approximation&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="c1"># plot the exact function on a fine mesh</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;exact: $f(x)$&#39;</span><span class="p">)</span>
<span class="c1"># plot the p/w linear interpolant on a coarse mesh</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w linear interpolant: $\pi\,f(x)$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">),</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/678ecec92db0e1ec6eb87e5c55c7b0ff39db800f669573ec8853bbbc094938f8.png" src="../_images/678ecec92db0e1ec6eb87e5c55c7b0ff39db800f669573ec8853bbbc094938f8.png" />
</div>
</div>
<section id="comments">
<h3>Comments<a class="headerlink" href="#comments" title="Permalink to this heading">#</a></h3>
<p>NB. a common notation for an <em>interpolant</em> of a function <span class="math notranslate nohighlight">\(f\)</span>, is the function <span class="math notranslate nohighlight">\(\pi f\)</span> - think of <span class="math notranslate nohighlight">\(\pi\)</span> as an operator that turns a function <span class="math notranslate nohighlight">\(f\)</span> into its interpolant.</p>
<ul class="simple">
<li><p>Recall that an interpolant passes through the underlying function (or rather discrete data obtained from evaluating the function) exactly at the data points: <span class="math notranslate nohighlight">\(\pi f(x_i)=f(x_i)\)</span> <span class="math notranslate nohighlight">\(\forall i\)</span>.</p></li>
<li><p>We see this in the plot above with the blue dots.</p></li>
<li><p>But we will see below that this is <em>not</em> the only option available to us.</p></li>
</ul>
</section>
</section>
<section id="interpolation-errors">
<h2>Interpolation errors<a class="headerlink" href="#interpolation-errors" title="Permalink to this heading">#</a></h2>
<section id="norms">
<h3>Norms<a class="headerlink" href="#norms" title="Permalink to this heading">#</a></h3>
<p>Note that unless our function itself is linear, a linear interpolant will have errors in between the data points (where the approximation is by definition exact).</p>
<p>The difference</p>
<div class="math notranslate nohighlight">
\[ f - \pi f,\]</div>
<p>which is itself is a function of <span class="math notranslate nohighlight">\(x\)</span>, is called the <em>interpolation error</em>.</p>
<p>To judge if it is large or small we need a norm to turn it into a single number, i.e. we need to compute <span class="math notranslate nohighlight">\(\,\| f - \pi f \|\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(L^2\)</span> norm is often used for this purpose as it says something about the size of a function.</p>
<p>For a general function <span class="math notranslate nohighlight">\(v\)</span>, the <span class="math notranslate nohighlight">\(L^2\)</span> norm over a domain <span class="math notranslate nohighlight">\(I\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[\|v\|_{L^2(I)} = \left( \int_I\, v^2\, dx\right)^{1/2},\]</div>
<p>where <span class="math notranslate nohighlight">\(I\)</span> might be our entire domain, or a single sub-interval/element.</p>
</section>
<section id="error-bounds-formulae-star">
<h3>Error bounds formulae  [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#error-bounds-formulae-star" title="Permalink to this heading">#</a></h3>
<div class="toggle toggle-shown docutils container">
<p>We will state the following standard results without proving them.</p>
<p>Over a single element <span class="math notranslate nohighlight">\(e_i\)</span> we have the (linear) interpolation error bound</p>
<div class="math notranslate nohighlight">
\[\| f - \pi f\|_{L^2(e_i)} \leq C \, \Delta x_i^2 \, ||f''||_{L^2(e_i)}, \]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is a constant,
<span class="math notranslate nohighlight">\(e_i := [x_i,x_{i+1}]\)</span> and <span class="math notranslate nohighlight">\(\Delta x_i = x_{i+1} - x_{i}\)</span> (we’re assuming we’re in 1D here).</p>
<p>We can sum up this result over our entire domain:</p>
<div class="math notranslate nohighlight">
\[ \| f - \pi f\|_{L^2(I)} \leq C \sum_{i=0}^N \Delta x_i^2 \, ||f''||_{L^2(e_i)}.\]</div>
</div>
</section>
<section id="id1">
<h3>Comments<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>This is consistent with what we’ve seen before with Taylor series analysis in previous lectures - the error is zero for a p/w linear interpolant if <span class="math notranslate nohighlight">\(f\)</span> is linear (as the second derivative is zero), and is larger for a larger mesh spacing or a more complex function. The error converges at second order with mesh spacing.</p></li>
<li><p>It turns our that while being exact at the nodes, when considered in terms of the <span class="math notranslate nohighlight">\(L^2\)</span> (and other) norm we can do better</p></li>
<li><p>and remember we want/have a solution equally valid everywhere so we need to consider its quality away from the nodes as well.</p></li>
</ul>
</section>
</section>
<section id="basis-functions-reminder-from-a-previous-lecture">
<h2>Basis functions [reminder from a previous lecture]<a class="headerlink" href="#basis-functions-reminder-from-a-previous-lecture" title="Permalink to this heading">#</a></h2>
<p>To progress we need to introduce basis functions, which are a critical component of the finite element method.</p>
<p>So far we have considered a piecewise linear approximation to our function.</p>
<p>But how can we write this as an expansion of the form from earlier:</p>
<div class="math notranslate nohighlight">
\[f_h(x) = \sum_{j=0}^N \alpha_j \phi_j(x), \]</div>
<p>and what are the basis functions <span class="math notranslate nohighlight">\(\phi_j(x)\)</span> here?</p>
<p>[Why am I using <span class="math notranslate nohighlight">\(j\)</span> here for the sum rather than the more obvious <span class="math notranslate nohighlight">\(i\)</span> (they’re <em>dummy indices</em> so it of course doesn’t actually matter which I use) - we will see why later.]</p>
</section>
<section id="hat-functions">
<h2>Hat functions<a class="headerlink" href="#hat-functions" title="Permalink to this heading">#</a></h2>
<p>If you think about it the answer is the following</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\phi_i(x) = 
\begin{cases}
\frac{x - x_{i-1}}{\Delta x_{i-1}}, &amp;\text{if}\;\;\; x\in e_{i-1}\equiv[x_{i-1},x_{i}] \\[5pt]
\frac{x_{i+1} - x}{\Delta x_{i}}, &amp;\text{if}\;\;\; x\in e_{i}\equiv[x_{i},x_{i+1}] \\[5pt]
0, &amp; \text{otherwise} \\
\end{cases}
\end{split}\]</div>
<p>which have the name hat (or chapeau) functions, and look like the following.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/fem_basis_functions.svg"><img alt="../_images/fem_basis_functions.svg" src="../_images/fem_basis_functions.svg" width="75%" /></a>
</figure>
</section>
<section id="support-of-basis-functions">
<h2>Support of basis functions<a class="headerlink" href="#support-of-basis-functions" title="Permalink to this heading">#</a></h2>
<p>An important aspect of the finite element method is appreciating when the basis functions and the products of basis functions, e.g.</p>
<div class="math notranslate nohighlight">
\[\phi_i \, \phi_j\,,\]</div>
<p>are non-zero.</p>
<p>We call the area a function is non-zero its <em>support</em>, and with the FEM we are looking for this area to be finite and for each basis function for this to be confined to a small portion of the overall domain - the mathematical term is <a class="reference external" href="https://mathworld.wolfram.com/CompactSupport.html"><em>compact support</em></a>.</p>
<p>For a given value of <span class="math notranslate nohighlight">\(\,i\)</span>, based upon the above schematic for what values of <span class="math notranslate nohighlight">\(\,j\,\)</span> is the product non-zero anywhere (alternatively, for what choices of <span class="math notranslate nohighlight">\(j\)</span>, given <span class="math notranslate nohighlight">\(i\)</span>, is the product zero everywhere?).</p>
<p>Similarly note that the derivative of a basis function <span class="math notranslate nohighlight">\(\,\phi_{i,x}\,\)</span>, has the same (finite) support as <span class="math notranslate nohighlight">\(\,\phi_i\,\)</span> and hence the same result holds for the products</p>
<div class="math notranslate nohighlight">
\[\phi_{i}\,\phi_{j,x}\,, \;\;\;\;\; \phi'_{i}\,\phi_{j}\,,\;\;\;\;\;\text{and}\;\;\;\; \phi'_{i}\,\phi'_{j}\,,\]</div>
<p>where the subscript “comma <span class="math notranslate nohighlight">\(x\)</span>” and the primes in the line above are just notation to indicate the <span class="math notranslate nohighlight">\(x\)</span> derivatives of the basis functions.</p>
</section>
<section id="some-code-to-return-the-hat-basis-functions">
<h2>Some code to return the hat/basis functions<a class="headerlink" href="#some-code-to-return-the-hat-basis-functions" title="Permalink to this heading">#</a></h2>
<p>First let’s implement a function that returns the <span class="math notranslate nohighlight">\(i\)</span>-th hat function on a mesh.  You can try playing with the value for <span class="math notranslate nohighlight">\(i\)</span> and seeing how it changes the plot.</p>
<p>Second we show how we can make use of these basis functions to implement a function returning <span class="math notranslate nohighlight">\(f_h(x)\)</span> for given weights.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hat_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Linear continuous basis function at node i.</span>
<span class="sd">    Returns a function for later use in quadrature rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  
                  <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">,</span>
                <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hat</span>

<span class="c1"># let&#39;s plot what this function returns</span>
<span class="c1"># first set up the nodes, a fine mesh to use to plot and the axes</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_4$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_5$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_6$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_7$&#39;</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;P1 basis function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># you can change the following to be in [0,n] to change what the </span>
<span class="c1"># function returns for a given node number</span>
<span class="n">node</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="c1"># it&#39;s returned a function phi, so just evaluate this on the mesh</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">phi</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/5e15193f04d3bd74e461fcdbb253fea7394b3b504be8d245664e3c04cbc903cd.png" src="../_images/5e15193f04d3bd74e461fcdbb253fea7394b3b504be8d245664e3c04cbc903cd.png" />
</div>
</div>
<p>Now use this function which returns the “basis functions” to construct the piecewise linear function <span class="math notranslate nohighlight">\(f_h(x)\)</span>, where the required weights are just given by the function <span class="math notranslate nohighlight">\(f\)</span> evaluates at the node locations (<code class="docutils literal notranslate"><span class="pre">y_nodes</span> <span class="pre">=</span> <span class="pre">f(x_nodes)</span></code>).</p>
<p>In this implementation our function returns the values of <span class="math notranslate nohighlight">\(f_h(x)\)</span> at a prescribed array of <span class="math notranslate nohighlight">\(x\)</span> locations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># discrete data</span>
<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># if we have 4 nodes, including at the ends of our domain, then we have 4-1=3 elements/cells</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>
<span class="c1"># and the element size is the total interval length divided by the number of elements</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">N_elements</span>
<span class="c1"># construct the node locations</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">N_nodes</span><span class="p">)</span>

<span class="c1"># and evaluate our function at these points - these will be our weights</span>
<span class="n">y_nodes</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>

<span class="c1"># now a function to reconstruct the p/w linear function</span>
<span class="k">def</span> <span class="nf">pwlinear</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">y_nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to return f_h(x) at locations given in x, </span>
<span class="sd">    with top hat functions on a mesh given by x_nodes, and</span>
<span class="sd">    corresponding weights given in y_nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># loop over x values, equivalently the basis functions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="c1"># which mesh node is directly to the left of x[i] ?</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x_nodes</span> <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># because of the greater than or equals above, deal with problem of hitting last node</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># add together the contributions from the two hat functions at this x location - </span>
        <span class="c1"># the hat functions centred on &quot;node&quot; (to the left)</span>
        <span class="n">phi_node</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
        <span class="c1"># and &quot;node+1&quot; (to the right)</span>
        <span class="n">phi_node_plus_1</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
        <span class="c1"># now take the weighted sum of these two hat functions</span>
        <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">*</span><span class="n">phi_node</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">y_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">phi_node_plus_1</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">f_h</span> <span class="o">=</span> <span class="n">pwlinear</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">y_nodes</span><span class="p">,</span> <span class="n">x_fine</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="c1">#ax1.set_xlabel(&#39;$x$&#39;, fontsize=16)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Interpolant reconstructed using hat functions&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f_h</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;p/w linear using hat functions&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">),</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/abecfea8eeefa24dc88bad1e834f389d0880834d4fdf8eb2a0f5cbd8888c4b68.png" src="../_images/abecfea8eeefa24dc88bad1e834f389d0880834d4fdf8eb2a0f5cbd8888c4b68.png" />
</div>
</div>
<p>So as expected the expansion of these hat (basis) functions goes through the values given by the weights, with straight lines in between.</p>
</section>
<section id="unstructured-mesh-data-structures">
<h2>Unstructured mesh data structures<a class="headerlink" href="#unstructured-mesh-data-structures" title="Permalink to this heading">#</a></h2>
<p>[Note we’ll return to this topic in more detail when discussing local assembly].</p>
<p>The following image presents a schematic of an unstructured mesh data structure, or connectivity, in the simple 1D case and assuming that we have two nodes per element, and that these are located at the ends of the elements (other more complex choices are possible!)</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/connectivity_1d.svg"><img alt="../_images/connectivity_1d.svg" src="../_images/connectivity_1d.svg" width="75%" /></a>
</figure>
<ul class="simple">
<li><p>Blue are the <em>element numbers</em></p></li>
<li><p>Red are the <em>local node numbers</em></p></li>
<li><p>Black are the <em>global node numbers</em></p></li>
</ul>
<p>The connectivity can be described by the so-called connectivity matrix, which again in 1D takes the particularly simple form</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
    0 &amp; 1 &amp; \ldots &amp; i-1 &amp; i   &amp; i+1 &amp; \ldots &amp; n \\
    1 &amp; 2 &amp; \ldots &amp; i   &amp; i+1 &amp; i+2 &amp; \ldots &amp; n+1
\end{pmatrix}
\end{split}\]</div>
<p>the column being the element, the row the local node number, and the entry of the matrix then being the global node number.</p>
<p>The size of the connectivity matrix is therefore:</p>
<div class="math notranslate nohighlight">
\[\text{the number of local nodes per element}\;\;\times\;\;\text{the number of elements}.\]</div>
<section id="terminology">
<h3>Terminology<a class="headerlink" href="#terminology" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><em>element</em>, cell, “finite volume” essentially mean the same thing - discrete objects used to cover or <em>tessellate</em> the entire domain</p></li>
<li><p><em>vertices</em> are the geometrical objects used to define the elements, e.g. the two end points of each sub-interval in 1D,  3 corners of a triangle etc.</p></li>
<li><p><em>nodes</em> are the locations where our unknowns (that we will be solving for) are located, in the early stages of our discussions nodes<span class="math notranslate nohighlight">\(\equiv\)</span>vertices, but this won’t always be the case</p></li>
<li><p>a simple example would be to have three nodes within each interval (at each end and one in the middle) and use these with a quadratic basis function, but only two of them required as the vertices defining the cell. More complex basis functions won’t co-locate any of the nodes with the vertices!</p></li>
</ul>
</section>
</section>
<section id="l-2-projection-of-a-function">
<h2><span class="math notranslate nohighlight">\(L^2\)</span> projection of a function<a class="headerlink" href="#l-2-projection-of-a-function" title="Permalink to this heading">#</a></h2>
<p>Of course interpolation is not the only way to approximate a function.</p>
<p>Indeed interpolation is really developed primarily for the use case where we are given finite <span class="math notranslate nohighlight">\((x,y)\)</span> data, and we don’t have enough information to do anything other than pass through these values as well as possible.</p>
<p>In the case here (projection) we actually have access to the underlying function and so we should be able to do better than what we obtain with interpolation.</p>
<p>To do better with the same number of free parameters (i.e. on the same finite mesh and assuming the same basis functions) we need to relax the assumption that the finite-dimensional approximation passes through the actual function values at the nodes of the mesh.</p>
<p>Basically, we have a set of basis functions <span class="math notranslate nohighlight">\(,\phi_i(x)\)</span>, <span class="math notranslate nohighlight">\(\,i=0,1,\ldots,N\)</span>, which through their linear combinations
define a space <span class="math notranslate nohighlight">\(V_h\)</span> - which here is clearly the space of all piecewise-linear continuous functions.</p>
<p>That is <span class="math notranslate nohighlight">\(v\in V_h\)</span> if and only if we can write</p>
<div class="math notranslate nohighlight">
\[v(x) \equiv \sum_{j=0}^N \alpha_j \phi_j(x),\]</div>
<p>for some combination of weights <span class="math notranslate nohighlight">\(\alpha_j\)</span>.</p>
<p>We want to find the function in this space which minimises the error.  The interpolant <span class="math notranslate nohighlight">\(\,\pi f\,\)</span> is clearly <em><strong>a</strong></em> member of this space, but as we shall see not necessarily the best solution for us.</p>
</section>
<section id="theory">
<h2>Theory<a class="headerlink" href="#theory" title="Permalink to this heading">#</a></h2>
<p>So we want to</p>
<div class="math notranslate nohighlight">
\[\text{find} \;\;\;v\in V_h\;\;\; \text{which minimises }
\;\;\;\; \| f - v\|^2_{L^2(I)} .\]</div>
<p>It turns out that as we ask the question in terms of the <span class="math notranslate nohighlight">\(L^2\)</span> norm, the answer we are looking for is the function <span class="math notranslate nohighlight">\(\,v=P_h\,f\,\)</span> where <span class="math notranslate nohighlight">\(P_h\)</span> stands for the so-called <em><strong><span class="math notranslate nohighlight">\(L^2\)</span> projection</strong></em> of the function <span class="math notranslate nohighlight">\(f\)</span> - think if it as anther operator like <span class="math notranslate nohighlight">\(\pi\)</span> but potentially giving a different answer.</p>
<p>The <span class="math notranslate nohighlight">\(L^2\)</span> projection <span class="math notranslate nohighlight">\(P_h\,f\)</span>, which is a function in <span class="math notranslate nohighlight">\(V_h\)</span>, is uniquely defined by that property that</p>
<div class="math notranslate nohighlight">
\[ \int_I \,(f - P_h\,f )\,v\,dx = 0,\;\;\;\; \forall \; v\in V_h.\]</div>
<br> 
<p>What is this telling us?</p>
<ol class="arabic simple">
<li><p>This means that the error or the residual <span class="math notranslate nohighlight">\((f - P_h\,f)\)</span> is <a class="reference external" href="https://en.wikipedia.org/wiki/Orthogonal_functions"><em><strong>orthogonal</strong></em></a> to every function in <span class="math notranslate nohighlight">\(V_h\)</span>.</p></li>
<li><p>This in turn means that the <span class="math notranslate nohighlight">\(P_h\,f\)</span> we obtain is the closest function <em>within</em> <span class="math notranslate nohighlight">\(V_h\)</span> to <span class="math notranslate nohighlight">\(f\)</span>.</p></li>
<li><p>This means that in the case that <span class="math notranslate nohighlight">\(f\in V_h\)</span>, i.e. if <span class="math notranslate nohighlight">\(f\)</span> is itself p/w linear, then our result is exact: <span class="math notranslate nohighlight">\(P_h\,f\equiv f\)</span>.</p></li>
</ol>
<section id="finite-dimensional-example">
<h3>Finite-dimensional example<a class="headerlink" href="#finite-dimensional-example" title="Permalink to this heading">#</a></h3>
<p>Visually, pretend that <span class="math notranslate nohighlight">\(V_h\)</span> is represented by a straight line in 2D space, and we want to find the point on the line closest to an arbitrary point anywhere in 2D - sketch this case.</p>
</section>
</section>
<section id="theory-continued">
<h2>Theory - continued<a class="headerlink" href="#theory-continued" title="Permalink to this heading">#</a></h2>
<p>How does us satisfying the above constraints “uniquely define” <span class="math notranslate nohighlight">\(P_h\,f\)</span>?</p>
<p>Well notice that <span class="math notranslate nohighlight">\(\,P_h\,f = \sum_{j=0}^N \alpha_j \phi_j(x)\,\)</span> has <span class="math notranslate nohighlight">\(N+1\)</span> free parameters, and the requirement that the above integral is zero for all <span class="math notranslate nohighlight">\(v\in V_h\)</span> actually yields us <span class="math notranslate nohighlight">\(N+1\)</span> pieces of information, as <span class="math notranslate nohighlight">\(V_h\)</span> also has dimension <span class="math notranslate nohighlight">\(n+1\)</span>.</p>
<p>So we have <span class="math notranslate nohighlight">\(N+1\)</span> unknowns and <span class="math notranslate nohighlight">\(N+1\)</span> equations and we know that we can in principle solve this system uniquely.</p>
<p>Specifically, by linearity this requirement is completely equivalent to requiring orthogonality to the individual basis functions:</p>
<div class="math notranslate nohighlight">
\[ \int_I \,(f - P_h\,f )\,\phi_i\,dx = 0,\;\;\;\; i=0,1,\ldots N.\]</div>
<p>So what do we have?</p>
<p>For <span class="math notranslate nohighlight">\(i=0,1,\ldots n\)</span> we want the following to be true</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\int_I \,(f - P_h\,f )\,\phi_i\,dx  &amp;= 0 \\[10pt]
\iff  \int_I \, (P_h\,f) \,\phi_i\,dx &amp;=  \int_I \,f \,\phi_i\,dx\\[10pt]
\iff \int_I \,\sum_{j=0}^n \alpha_j \phi_j \,\phi_i\,dx &amp;=  \int_I \,f \,\phi_i\,dx\\[10pt]
\iff \sum_{j=0}^N \alpha_j  \int_I \,\phi_j \,\phi_i\,dx &amp;=  \int_I \,f \,\phi_i\,dx\\[10pt]
\iff \sum_{j=0}^N \alpha_j  M_{ij} &amp;=  \int_I \,f \,\phi_i\,dx\\[10pt]
\iff    M\,\boldsymbol{\alpha} &amp;=  \boldsymbol{RHS},
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is the so-called <em>mass matrix</em>, <span class="math notranslate nohighlight">\(\boldsymbol{\alpha}\)</span> is the vector of unknown weights <span class="math notranslate nohighlight">\({\alpha}_j\)</span>, and the RHS vector has the entries <span class="math notranslate nohighlight">\(\int_I \,f \,\phi_i\,dx\)</span>.</p>
<p>For historical reasons the RHS is sometimes called the <em>load</em> vector.</p>
<p>We need to compute the mass matrix and the load vector, solve the linear system for the weights <span class="math notranslate nohighlight">\(\boldsymbol{\alpha}\)</span> and we have our <span class="math notranslate nohighlight">\(L^2\)</span> projection.</p>
<p>Note that we introduced notation for our solution to this (projection) problem at the start of this discussion: <span class="math notranslate nohighlight">\(\,P_h\,f\,\)</span>.</p>
<p>Alternatively we could have posed the problem as find <span class="math notranslate nohighlight">\(v_h\in V_h\)</span> such that <span class="math notranslate nohighlight">\(v=f\)</span> in a weak sense,
i.e.</p>
<div class="math notranslate nohighlight">
\[ \int_I \,(f - v_h )\,\phi_i\,dx = 0,\;\;\;\; i=0,1,\ldots N,\]</div>
<p>and since we can write <span class="math notranslate nohighlight">\(v_h = \sum_{j=0}^N \alpha_j \phi_j(x)\,\)</span>, this leads to exactly the same result as in the previous cell.</p>
<br>
<p>The point I’m making here is to emphasise that we solved the <em>equation</em> <span class="math notranslate nohighlight">\(v=f\)</span>, using the “finite element method” (which invovles discretising <span class="math notranslate nohighlight">\(v\)</span> and utilising the weak form of the equation).</p>
</section>
<section id="link-to-the-finite-element-method">
<h2>Link to the finite element method<a class="headerlink" href="#link-to-the-finite-element-method" title="Permalink to this heading">#</a></h2>
<p>This is basically the crux of the finite element method, but when solving a <strong>differential equation</strong> instead of starting from the <strong>equation</strong>  <span class="math notranslate nohighlight">\(\,v = f\,\)</span> and going through the above <span class="math notranslate nohighlight">\(L^2\)</span> projection procedure to find the best approximation (which we know to be <span class="math notranslate nohighlight">\(\,v=P_h\,f\)</span>) from within the function space our basis functions span, we instead start from our <em>differential equation</em> and consider the weak form of that.</p>
<p>In the case of a differential equation we shall see that we get different, or additional, matrices on the LHS, and we also need to deal with boundary conditions. We will see plenty of examples in the context of BVPs and PDEs.</p>
</section>
<section id="implementation-the-mass-matrix">
<h2>Implementation - the mass matrix<a class="headerlink" href="#implementation-the-mass-matrix" title="Permalink to this heading">#</a></h2>
<p>Define the mass matrix to be the matrix <span class="math notranslate nohighlight">\(M\)</span> with entries</p>
<div class="math notranslate nohighlight">
\[ M_{ij} = \int_\Omega \,\phi_i(x)\,\phi_j(x)\,  dx. \]</div>
<p>[NB. Note that if the basis functions where what is called orthogonal functions then the mass matrix would be diagonal.]</p>
<p>In our case we choose basis functions with finite support - what does this mean?</p>
<p>Well if we consider the form of our top hat function, for a given row, i.e. a given value of <span class="math notranslate nohighlight">\(i\)</span>, then the integrand will be zero for all <span class="math notranslate nohighlight">\(j\)</span> values other than <span class="math notranslate nohighlight">\(j=i\)</span>, and <span class="math notranslate nohighlight">\(j=i\pm 1\)</span>, i.e. the mass matrix is tridiagonal.</p>
<br>
<p>Remembering that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\phi_i(x) = 
\begin{cases}
\frac{x - x_{i-1}}{\Delta x_{i-1}}, &amp;\text{if}\;\;\; x\in e_{i-1}\equiv[x_{i-1},x_{i}] \\[5pt]
\frac{x_{i+1} - x}{\Delta x_{i}}, &amp;\text{if}\;\;\; x\in e_{i}\equiv[x_{i},x_{i+1}] \\[5pt]
0, &amp; \text{otherwise} \\
\end{cases}
\end{split}\]</div>
<br>
<p>In the case <span class="math notranslate nohighlight">\(j=i\)</span> we can compute the diagonal entry of the mass matrix:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
M_{ii} &amp;= \int_\Omega \,\phi_i(x)\,\phi_j(x)\,  dx\\[5pt]
&amp; = \int_{x_{i-1}}^{x_{i+1}} \,\phi_i(x)\,\phi_i(x)\,  dx\\[5pt]
&amp; = \int_{x_{i-1}}^{x_{i}} \,\phi_i(x)\,\phi_i(x)\,  dx + \int_{x_{i}}^{x_{i+1}} \,\phi_i(x)\,\phi_i(x)\,  dx\\[5pt]
&amp; = \int_{x_{i-1}}^{x_{i}} \,\frac{x - x_{i-1}}{\Delta x_{i-1}}\,\frac{x - x_{i-1}}{\Delta x_{i-1}}\,  dx + \int_{x_{i}}^{x_{i+1}} \,\frac{x_{i+1} - x}{\Delta x_{i}}\,\frac{x_{i+1} - x}{\Delta x_{i}}\,  dx\\[5pt]
&amp; = \frac{1}{\Delta x_{i-1}^2} \int_{0}^{\Delta x_{i-1}} \,s^2\,  ds + \frac{1}{\Delta x_{i}^2}\int_{0}^{\Delta x_{i}} \, (\Delta x_{i} - t)^2\,  dt\\
&amp; \qquad \qquad (\text{where}\;\;\; s:=x - x_{i-1},\;\;\;
t:=x - x_i\implies x_{i+1} - x = \Delta x_{i} -t)\\[5pt]
&amp; = \frac{\Delta x_{i-1}}{3} + \frac{\Delta x_{i}}{3}.
\end{align*}
\end{split}\]</div>
<p>Similarly,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
M_{i,i-1}
&amp; = \int_{x_{i-1}}^{x_{i+1}} \,\phi_i(x)\,\phi_{i-1}(x)\,  dx\\[5pt]
&amp; = \int_{x_{i-1}}^{x_{i}} \,\phi_i(x)\,\phi_{i-1}(x)\,  dx + \int_{x_{i}}^{x_{i+1}} \,\phi_{i-1}(x)\,\phi_i(x)\,  dx\;\;\;\;\;\;(\text{the second term here is zero!})\\[5pt]
&amp; = \int_{x_{i-1}}^{x_{i}} \,\phi_i(x)\,\phi_{i-1}(x)\,  dx \\[5pt]
&amp; = \int_{x_{i-1}}^{x_{i}} \, \frac{x - x_{i-1}}{\Delta x_{i-1}}\,\frac{x_i - x}{\Delta x_{i-1}}\,  dx \\[5pt]
&amp; = \frac{1}{\Delta x_{i-1}^2} \int_{0}^{\Delta x_{i-1}} \,s(x_i - (s+x_{i-1})\,  ds 
\;\;\;\;\;\;(\text{where}\;\;\; s:=x - x_{i-1})\\[5pt]
&amp; = \frac{1}{\Delta x_{i-1}^2} \int_{0}^{\Delta x_{i-1}} \,s(\Delta x_{i-1} - s)\,  ds \\[5pt]
&amp; = \frac{1}{\Delta x_{i-1}^2} \left[\frac{s^2}{2}\Delta x_{i-1} - \frac{s^3}{3} \right]_{0}^{\Delta x_{i-1}}  \\[5pt]
&amp; = \frac{\Delta x_{i-1}}{6},
\end{align*}
\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
M_{i,i+1} = \ldots =  \frac{\Delta x_{i}}{6}.
\end{align*}
\]</div>
<p>Therefore one internal row (the <span class="math notranslate nohighlight">\(i\)</span>-th row) of the tridiagonal mass matrix has the entries</p>
<div class="math notranslate nohighlight">
\[\left[0 \;\;\;\;\; \cdots \;\;\;\;\; 0 \;\;\;\;\; \frac{\Delta x_{i-1}}{6} \;\;\;\;\;  \frac{\Delta x_{i-1}}{3} + \frac{\Delta x_{i}}{3}  \;\;\;\;\; \frac{\Delta x_{i}}{6} \;\;\;\;\; 0 \;\;\;\;\; \cdots \;\;\;\;\;  0  \right]. \]</div>
<p>For the top and bottom rows of the matrix the diagonal entries are halved as these correspond to the basis functions at the ends of the domain which only have half the support, i.e. the top left entry of the matrix is <span class="math notranslate nohighlight">\(\frac{\Delta x_{0}}{3}\)</span> and the bottom right <span class="math notranslate nohighlight">\(\frac{\Delta x_{N}}{3}\)</span>.</p>
<p>Notice that this matrix is symmetric, as should be clear from its definition:</p>
<div class="math notranslate nohighlight">
\[ M_{ij} = \int_\Omega \,\phi_i(x)\,\phi_j(x)\,  dx, \]</div>
<br>
<p><span class="math notranslate nohighlight">\(M_{ij}\)</span> is obviously the same as <span class="math notranslate nohighlight">\(M_{ji}\)</span> as the integrals don’t care in which order you multiply the basis functions] as well as the calculations we’ve just performed.</p>
<br>
<p>Note that the details of how to compute these integrals exactly aren’t that important, as in practice we will make use of quadrature rules.</p>
</section>
<section id="implementation-in-code">
<h2>Implementation in code<a class="headerlink" href="#implementation-in-code" title="Permalink to this heading">#</a></h2>
<p>First let’s construct the mass matrix explicitly “by hand” using our derivation of the entries above and assuming <span class="math notranslate nohighlight">\(\Delta x\)</span> is constant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># discrete data</span>
<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># for simplicity</span>

<span class="c1"># construct mass matrix</span>
<span class="n">Mass_CG</span> <span class="o">=</span> <span class="mf">4.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>  <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span>  <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Mass_CG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span> 
<span class="n">Mass_CG</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span>
<span class="n">Mass_CG</span> <span class="o">=</span> <span class="n">Mass_CG</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span> <span class="o">/</span> <span class="mf">6.</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">Mass_CG</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[0.33333333, 0.16666667, 0.        , 0.        ],
       [0.16666667, 0.66666667, 0.16666667, 0.        ],
       [0.        , 0.16666667, 0.66666667, 0.16666667],
       [0.        , 0.        , 0.16666667, 0.33333333]])
</pre></div>
</div>
</div>
</div>
<p>Now let’s write a function to do this for use later.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mass_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span>  <span class="o">+</span>  <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="mi">3</span> <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    <span class="n">M</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="mi">6</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="mi">6</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">M</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="n">pprint</span><span class="p">(</span><span class="n">mass_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[0.33333333, 0.16666667, 0.        , 0.        ],
       [0.16666667, 0.66666667, 0.16666667, 0.        ],
       [0.        , 0.16666667, 0.66666667, 0.16666667],
       [0.        , 0.        , 0.16666667, 0.33333333]])
</pre></div>
</div>
</div>
</div>
</section>
<section id="quadrature">
<h2>Quadrature<a class="headerlink" href="#quadrature" title="Permalink to this heading">#</a></h2>
<p>While we can compute these integrals of basis functions exactly (at least in this simple case - see later material on “assembly” for the general way to do this), we are going to need to perform numerical integration in order to compute other more complex integrals.</p>
<p>Of course we could use SciPy here, but let’s use our own implementation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># use the composite version of simpsons rule for this part since we will be</span>
<span class="c1"># integrating over a relatively large number of points below</span>

<span class="k">def</span> <span class="nf">simpsons_composite_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to evaluate the composite Simpson&#39;s rule only using</span>
<span class="sd">    function evaluations at (number_intervals + 1) points.</span>
<span class="sd">    </span>
<span class="sd">    This implementation requires that the number of subintervals (number_intervals) be even</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">number_intervals</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;number_intervals is not even&quot;</span>

    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">number_intervals</span>
    <span class="c1"># start with the two end member values</span>
    <span class="n">I_cS2</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># add in those terms with a coefficient of 4</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="c1"># and those terms with a coefficient of 2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">I_cS2</span> <span class="o">*</span> <span class="p">(</span><span class="n">interval_size</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test this quadrature code, as well as our implementation of the code from near the start to evaluate the basis functions, by numerically computing the integrals which make up the mass matrix we did above exactly, i.e. let’s compute</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
M_{ii}  = \int_{x_{i-1}}^{x_{i+1}} \,\phi_i(x)\,\phi_i(x)\,  dx,
\end{align*}
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
M_{i,i+1} = \int_{x_{i-1}}^{x_{i+1}} \,\phi_i(x)\,\phi_{i+1}(x)\,  dx.
\end{align*}
\]</div>
<p>Let’s consider the simple case <span class="math notranslate nohighlight">\(\Delta x_{i}=1,\)</span>  <span class="math notranslate nohighlight">\(\forall i\)</span>.</p>
<p>From our analytical evaluation of the integrals above we know that we should obtain the values 2/3 and 1/6 respectively.  And in the case of the <span class="math notranslate nohighlight">\((0,0)\)</span> and <span class="math notranslate nohighlight">\((n,n)\)</span> entries of the matrix we should obtain half of the internal main diagonal values, i.e. here 1/3.</p>
<section id="application-of-simpson-s-rule-star">
<h3>Application of Simpson’s rule [<span class="math notranslate nohighlight">\(\star\)</span>]<a class="headerlink" href="#application-of-simpson-s-rule-star" title="Permalink to this heading">#</a></h3>
<div class="toggle toggle-shown docutils container">
<p>We note that the integrands of the integrals we need to compute are quadratic over an element for our current case (the product of two linear functions), and so can be exactly integrated using Simpson’s rule applied over those individual elements where it is non-zero.</p>
<p>Recall from a previous lecture that Simpson’s quadrature rule was</p>
<div class="math notranslate nohighlight">
\[ \int_a^b\,f(x)\,dx \approx \frac{(b-a)}{6}\left( f \left ( a\right ) + 4\,f \left ( \frac{a+b}{2}\right ) + f\left ( b\right )\right), \]</div>
<p>(and remember that it was actually exact for cubic polynomials).</p>
<p>This is what we will actually do in our codes, so let’s check this is correct</p>
<p>(the first step is to split the integral into two, over the two elements over which the product of basis functions is non-zero and on each of which the product is a quadratic function - we need to consider in two parts as we have different quadratics on each element for the diagonal entry)</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
M_{ii}  
&amp;= 
\int_{x_{i-1}}^{x_{i+1}} \,\phi_i(x)\,\phi_i(x)\,  dx\\[10pt]
&amp; = 
\int_{x_{i-1}}^{x_{i}} \,\frac{x - x_{i-1}}{\Delta x_{i-1}}\,\frac{x - x_{i-1}}{\Delta x_{i-1}}\,  dx + \int_{x_{i}}^{x_{i+1}} \,\frac{x_i - x}{\Delta x_{i}}\,\frac{x_i - x}{\Delta x_{i}}\,  dx \\[10pt]
&amp;\qquad \qquad \text{(in the next line we replace the integrals by a Simpsons &quot;approximation&quot;, which we know will be exact here)}\\[10pt]
&amp; = 
\frac{\Delta x_{i-1}}{6}
\left[
\left(\frac{x_{i-1} - x_{i-1}}{\Delta x_{i-1}}\right)^2 
+ 4\left(\frac{(x_{i-1}+x_{i})/2 - x_{i-1}}{\Delta x_{i-1}}\right)^2 
+ \left(\frac{x_{i} - x_{i-1}}{\Delta x_{i-1}}\right)^2
\right]
\\[5pt]
&amp; \;\;\;\;\;\;\; \;\;\;\;\;\;\;  
+ 
\frac{\Delta x_{i}}{6}
\left[
\left(\frac{x_i - x_{i+1}}{\Delta x_{i}}\right)^2 
+ 4\left(\frac{x_i - (x_{i}+x_{i+1})/2}{\Delta x_{i}}\right)^2 
+ \left(\frac{x_i - x_{i+1}}{\Delta x_{i}}\right)^2\right] \\[10pt]
&amp; = 
\frac{\Delta x_{i-1}}{6}
\left[
\left( 0 \right)^2 
+ 4\left(  \frac{ \frac{1}{2} \Delta x_{i-1}}{\Delta x_{i-1}} \right)^2 
+ \left(\frac{\Delta x_{i-1}}{\Delta x_{i-1}}\right)^2\right] \\[5pt]
&amp; \;\;\;\;\;\;\; \;\;\;\;\;\;\;  
+ 
\frac{\Delta x_{i}}{6}
\left[
\left(\frac{-\Delta x_{i}}{\Delta x_{i}}\right)^2 
+ 4\left(\frac{ -\frac{1}{2} \Delta x_{i} }{\Delta x_{i}}\right)^2 
+ \left(0\right)^2 \right]
\\[10pt]
&amp; = 
\frac{\Delta x_{i-1}}{6} \left[ 0 + 1 + 1 \right] + 
\frac{\Delta x_{i}}{6} \left[ 1 + 1 + 0 \right]
\\[10pt]
&amp; = 
\frac{\Delta x_{i-1}}{3} + \frac{\Delta x_{i}}{3},
\end{align*}
\end{split}\]</div>
<p>which agrees with the result we computed analytically above.</p>
<p>We can similarly verify that the leading off-diagonal terms computed using Simpson’s rule agree with what we calculated above, as well as the <span class="math notranslate nohighlight">\(0,0\)</span> and <span class="math notranslate nohighlight">\(n,n\)</span> entries.</p>
<p>This simply confirms that we get the exact result if we use Simpson’s rule, i.e. although we perform numerical integration we do not introduce any errors in these particular operations of our algorithm (as we would if we used a quadrature scheme such as trapezoidal that only integrates linear polynomials exactly).</p>
<p>So if we use Simpson’s rule we would be doing what is called <em>exact quadrature</em>. If we made the decision to use a lower precision rule (e.g. in an attempt to save computational cost), then we would be doing <em>inexact quadrature</em>.</p>
<p>[Note that it is absolutely possible to use higher order basis functions, e.g. quadratics, in which case we would need an appropriately quadrature rule if we wanted to compute the entries of the mass (and other discretisation terms) exactly].</p>
<p>In the calls to <code class="docutils literal notranslate"><span class="pre">simpsons_composite_rule</span></code> below I use 4 “intervals” when integrating over 2 elements (and 2 when integrating over 1) - why?</p>
<p>[Look at the docstring:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>`Function to evaluate the composite Simpson&#39;s rule only using
function evaluations at (number_intervals + 1) points.`
</pre></div>
</div>
<p>]</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># verify values in our mass matrix</span>

<span class="c1"># discrete data</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="c1"># dx being 1 means based on the above we should find entries [... 1/6, 2/3, 1/6, ...] </span>
<span class="c1"># on internal rows,  and 1/3 on the top left and bottom right entries</span>

<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_nodes</span><span class="o">-</span><span class="mi">1</span> <span class="p">,</span><span class="n">N_nodes</span><span class="p">)</span>
<span class="n">y_nodes</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>

<span class="c1"># an internal node</span>
<span class="n">node</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The (i,i) value: &#39;</span><span class="p">,</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span>  <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">4</span> <span class="p">))</span>


<span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">phi_i_plus_1</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i_plus_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The (i,i+1) value: &#39;</span><span class="p">,</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span>  <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">4</span> <span class="p">))</span>
<span class="c1"># and emphasise that the first half of the interval contributes nothing </span>
<span class="c1"># (integrate from x_nodes[node] instead of x_nodes[node-1] ... we get the same answer):</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The (i,i+1) value (only integrate across single element): &#39;</span><span class="p">,</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">2</span> <span class="p">))</span>

<span class="c1"># a boundary node</span>
<span class="n">node</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The (0,0) value: &#39;</span><span class="p">,</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">2</span> <span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The (i,i) value:  0.6666666666666666
The (i,i+1) value:  0.16666666666666666
The (i,i+1) value (only integrate across single element):  0.16666666666666666
The (0,0) value:  0.3333333333333333
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="approximation-using-a-continuous-function">
<h2>Approximation using a continuous function<a class="headerlink" href="#approximation-using-a-continuous-function" title="Permalink to this heading">#</a></h2>
<p>Now let’s actually apply all of this to our simple test case. We need to form and solve</p>
<div class="math notranslate nohighlight">
\[M\,\boldsymbol{\alpha} =  \boldsymbol{RHS},\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is the <em>mass matrix</em> which we now have a function to compute, and the RHS vector has the entries <span class="math notranslate nohighlight">\(\int_I \,f \,\phi_i\,dx\)</span> which we have to compute for our given function <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>Let’s do that now.</p>
<p>[Why did I say continuous in the title of this section?  Because there’s an example in the homework where we still use p/w linear basis functions, but allow our approximating function to be discontinuous between elements!]</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># our example function</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># discrete data</span>
<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">N_elements</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N_nodes</span><span class="p">)</span>


<span class="c1"># construct mass matrix</span>
<span class="n">Mass_CG</span> <span class="o">=</span> <span class="n">mass_matrix</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>


<span class="c1"># construct RHS vector - first initialise an array</span>
<span class="n">RHS_CG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">)</span>
<span class="c1"># then do some quadrature</span>
<span class="c1"># loop over internal nodes</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># form the corresponding basis function</span>
    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
    <span class="c1"># and the integrand we will integrate - our function multiplied by the </span>
    <span class="c1"># corresponding basis function</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">RHS_CG</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>

<span class="c1"># now consider the end nodes</span>
<span class="n">node</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># integrate our function multiplied by the corresponding cts basis function</span>
<span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">RHS_CG</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">N_nodes</span><span class="o">-</span><span class="mi">1</span>
<span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="c1"># integrate our function multiplied by the corresponding cts basis function</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">RHS_CG</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>

<span class="c1"># solve our linear system</span>
<span class="n">approx_CG</span> <span class="o">=</span> <span class="n">sl</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Mass_CG</span><span class="p">,</span> <span class="n">RHS_CG</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="c1">#ax1.set_xlabel(&#39;$x$&#39;, fontsize=16)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Function approximation&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="c1"># plot the exact function on a fine mesh</span>
<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span> <span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="c1"># plot the p/w linear interpolant on a coarse mesh - P1 computed in a cell above</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w linear interpolant&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">),</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">approx_CG</span> <span class="p">,</span> <span class="s1">&#39;ro-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w linear cts projection&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/fd4449bf393994a5074c706a6965db782b99fcd249d1bcbdd7c3498fe0f798b5.png" src="../_images/fd4449bf393994a5074c706a6965db782b99fcd249d1bcbdd7c3498fe0f798b5.png" />
</div>
</div>
</section>
<section id="quality-of-approximation">
<h2>Quality of approximation<a class="headerlink" href="#quality-of-approximation" title="Permalink to this heading">#</a></h2>
<p>Which of these is a better approximation?</p>
<p>Clearly the P1 interpolant if we ask the question of accuracy at the nodes only.</p>
<p>But above we established that, by construction, our projection approach should yield a result that is optimal w.r.t. the <span class="math notranslate nohighlight">\(L^2\)</span> norm, i.e. we cannot do any better when measuring agreement using this norm.</p>
<p>Let’s check this - that the (CG) projection has lower errors than the interpolant when measured in the L2 norm (which we compute/approximate using the RMS error norm (see next cell) evaluated on a fine mesh upon which we evaluate the true function and the discrete approximation):</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/P1vsCGvsDG_convergence.png"><img alt="../_images/P1vsCGvsDG_convergence.png" src="../_images/P1vsCGvsDG_convergence.png" style="width: 75%;" /></a>
</figure>
<p>What’s the DG line? See homework and the image below:</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/CG_DG_projection.png"><img alt="../_images/CG_DG_projection.png" src="../_images/CG_DG_projection.png" style="width: 75%;" /></a>
</figure>
<p>if we relax the requirement of continuity between elements (and so effectively have twice as many degrees of freedom to solve for) we can achieve an even better approximation.</p>
</section>
<section id="rms-root-mean-square-vs-l-2-norm-reminder-from-comp-math">
<h2>RMS (root mean square) vs <span class="math notranslate nohighlight">\(L^2\)</span> norm [reminder from Comp Math]<a class="headerlink" href="#rms-root-mean-square-vs-l-2-norm-reminder-from-comp-math" title="Permalink to this heading">#</a></h2>
<p>Notice that I labeled the <span class="math notranslate nohighlight">\(y\)</span> axes with RMS error rather than the <span class="math notranslate nohighlight">\(L^2\)</span> norm. Why?</p>
<p>We want to compute</p>
<div class="math notranslate nohighlight">
\[
\begin{align*} 
e  := \| f - P_h\, f\|^2_{L^2(I)}
= \left( \int_I\, \left[f - P_h\, f\right]^2\, dx\right)^{1/2}.
\end{align*}
\]</div>
<p>We can approximate the integral as</p>
<div class="math notranslate nohighlight">
\[ \int_I\, \left[f(x) - (P_h\, f)(x)\right]^2\, dx 
\approx \sum_{i=1}^N  \, \left[f(s_i) - (P_h\, f)(s_i)\right]^2\,\Delta s.\]</div>
<p>I’ve introduced the variable <span class="math notranslate nohighlight">\(s\)</span> here to emphasise that we want to evaluate the functions and their difference on a discrete mesh that is ideally finer than our finite element mesh, if we do this this will be an accurate approximation to the integral.</p>
<p>Now we note that (assuming our interval is of length 1) that</p>
<div class="math notranslate nohighlight">
\[\Delta s = \frac{1}{N},\]</div>
<p>and finally we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*} 
e_{L^2} &amp; := \| f - P_h\, f\|^2_{L^2(I)}\\[10pt]
&amp;= \left( \int_I\, \left[f - P_h\, f\right]^2\, dx\right)^{1/2}\\[10pt]
&amp;\approx \left( \frac{1}{N} \sum_{i=1}^N  \, \left[f(s_i) - (P_h\, f)(s_i)\right]^2 \right)^{1/2}
\\[10pt]
&amp;=: e_{\text{RMS}}.
\end{align*}
\end{split}\]</div>
<p>Where if you look at the mathematical operations we perform here - the square <strong>R</strong>oot of the <strong>M</strong>ean of the <strong>S</strong>quares … explains the name “RMS”.</p>
<p>We can implement this in Python with something like</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">sl</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are two vectors of discrete values. This is because the default norm is the Frobenius norm, which is what we need without having divided through by <span class="math notranslate nohighlight">\(N\)</span>. Since this norm has already taken the square root, we just need to divide through by the square root  of <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>Ultimately the RMS error (norm) is the appropriate discrete analogue of the <span class="math notranslate nohighlight">\(L^2\)</span> norm.</p>
<p>But be careful with its use on a non-uniform mesh!</p>
</section>
<section id="solving-boundary-value-problems-bvps-using-the-fem">
<h2>Solving boundary value problems (BVPs) using the FEM<a class="headerlink" href="#solving-boundary-value-problems-bvps-using-the-fem" title="Permalink to this heading">#</a></h2>
<p>Recall that we considered BVPs in a previous lecture where we introduced them in the context of the steady state solution to a PDE.</p>
<p>As with the finite difference method, BVPs provide a useful way to explain spatial discretisation via the finite element method without needing to worry about variations in the time dimension.</p>
</section>
<section id="the-fundamental-form-of-the-discretisation-ignoring-bcs">
<h2>The fundamental form of the discretisation ignoring BCs<a class="headerlink" href="#the-fundamental-form-of-the-discretisation-ignoring-bcs" title="Permalink to this heading">#</a></h2>
<p>As we shall see below the details of the BCs we want to apply will change some of the discretisation details quite a lot, so initially we will explain things ignoring the BCs.</p>
<p>Our problem is to
find <span class="math notranslate nohighlight">\(u\equiv u(x)\)</span> which satisfies the ODE over the interval <span class="math notranslate nohighlight">\(I=[0,1]\)</span></p>
<div class="math notranslate nohighlight">
\[-u'' = f,\]</div>
<p>for a given source term <span class="math notranslate nohighlight">\(\,f\)</span> (subject to some BCs yet to be defined).</p>
<section id="weak-or-variational-form-of-problem">
<h3>Weak or variational form of problem<a class="headerlink" href="#weak-or-variational-form-of-problem" title="Permalink to this heading">#</a></h3>
<p>To progress with a FE discretisation we start from our continuous equation:</p>
<div class="math notranslate nohighlight">
\[-u'' = f.\]</div>
<p>As we did with the <span class="math notranslate nohighlight">\(L^2\)</span> projection of a function, we look for an approximation to the solution from within a finite-dimensional space of functions that is as close as possible to the true solution.</p>
<p>First we consider what the true continuous solution satisfies:</p>
<p>We look for a function <span class="math notranslate nohighlight">\(u\in V\)</span> such that for all <span class="math notranslate nohighlight">\(v\in V\)</span></p>
<div class="math notranslate nohighlight">
\[\int_I \,-u''\,v\,dx = \int_I \,f\,v\,dx,\]</div>
<p>that is we satisfy the equation in a “weak sense”.</p>
<p>It turns out that if we choose <span class="math notranslate nohighlight">\(V\)</span> here to be the appropriate infinite-dimensional function space then this form of the problem <em>is equivalent</em> to the underlying differential equation.</p>
<p>We call the original equation the <em>strong form</em> of the problem, while we call the version where we have multiplied by <span class="math notranslate nohighlight">\(v\)</span> and integrated the <em>weak</em> or the variational form of the problem.</p>
</section>
<section id="discretisation-by-restricting-the-function-space-to-be-finite-dimensional">
<h3>Discretisation by restricting the function space to be finite-dimensional<a class="headerlink" href="#discretisation-by-restricting-the-function-space-to-be-finite-dimensional" title="Permalink to this heading">#</a></h3>
<p>To discretise we simply replace the infinite-dimensional space <span class="math notranslate nohighlight">\(V\)</span> with a finite-dimensional space <span class="math notranslate nohighlight">\(V_h\)</span>, e.g. the space of p/w linear functions we saw earlier!</p>
<p>This is what we mean by the finite element method approximating the solution function but not the underlying equation (or at least its weak form).</p>
<p>In practice we write the solution as</p>
<div class="math notranslate nohighlight">
\[u \approx u_h := \sum_{j=0}^N u_j \phi_j(x).\]</div>
<p>Previously when we were just projecting a given function this led to a discrete system with the mass matrix on the LHS.</p>
<p>Now for an equation with derivatives this again leads to a discrete system, but with a <em>discretisation</em> matrix on the LHS rather than the simple mass matrix.</p>
<br>
<p>So now we have the discretised problem - find <span class="math notranslate nohighlight">\(u_h\in V_h\)</span> (or equivalently find the weights <span class="math notranslate nohighlight">\(u_j\)</span>, <span class="math notranslate nohighlight">\(j=0,\ldots N\)</span>) such that:</p>
<div class="math notranslate nohighlight">
\[\int_I \,-u_h''\,\phi_i\,dx = \int_I \,f\,\phi_i\,dx, \;\;\;\;\text{for}\;\;\;\; i=0,\ldots,N.\]</div>
</section>
<section id="choice-of-basis-functions-a-k-a-choice-of-function-space-a-k-a-choice-of-finite-element">
<h3>Choice of basis functions (a.k.a. choice of function space a.k.a. choice of “finite element”)<a class="headerlink" href="#choice-of-basis-functions-a-k-a-choice-of-function-space-a-k-a-choice-of-finite-element" title="Permalink to this heading">#</a></h3>
<p>But now we’re confronted with a problem - assuming that we’ve made the choice to use linear basis functions then our discrete solution <span class="math notranslate nohighlight">\(u_h\)</span> is p/w linear, so the second derivative appearing in the above is zero everywhere and this equation doesn’t make any sense.</p>
<p>However, since we’re asking for the weak (or variational or integral) form of the problem to be satisfied, we can perform <a class="reference external" href="https://en.wikipedia.org/wiki/Integration_by_parts"><em>integration by parts</em></a> and instead require that</p>
<div class="math notranslate nohighlight">
\[\int_I \,u_h'\,\phi'_i\,dx - \int_{\partial I} u_h'\,\phi_i\,dx = \int_I \,f\,\phi_i\,dx, \;\;\;\;\text{for}\;\;\;\; i=0,\ldots,N.\]</div>
<p>Alternatively we could have considered quadratic (or higher) order basis functions and then we wouldn’t have needed to integrate by parts (it would still have been <em>an option</em> for us, and as we shall see below we often make a decision to integrate by parts when we don’t need to as it helps us to easily apply certain types of boundary conditions).</p>
<p>The topic of basis function (or finite element) choice is a massive research area where considerations of quantitative accuracy, qualitative solution behaviour, stability and efficiency come in.</p>
<p>A particularly important area is in coupled problems where choosing the same basis functions (or discrete function spaces) for all variables may not be stable. An example of this is in the solution of the Navier-Stokes with the FEM, and where we talk about an appropriate <em>finite element pair</em>, i.e. appropriate function spaces for velocity and pressure. The choice of linear functions for both velocity and pressure is not stable on its own, while p/w quadratic functions for velocity and p/w linear functions for pressure is for example.</p>
<p>Things can get very “exotic” when we consider that we can choose discontinuous functions as well, and also in higher dimensions locate our nodes at the faces or edges of elements, rather than at the nodes as we would with the simplest basis functions (<em><strong>see the very final cell of this notebook to see just how exotic!</strong></em>).</p>
</section>
<section id="finite-element-approximation">
<h3>Finite element approximation<a class="headerlink" href="#finite-element-approximation" title="Permalink to this heading">#</a></h3>
<p>We now substitute our approximate solution function</p>
<div class="math notranslate nohighlight">
\[u_h := \sum_{j=0}^{N} u_j\,\phi_j,\]</div>
<p>into our weak form (where we are ignoring the boundary integral for for simplicity)</p>
<div class="math notranslate nohighlight">
\[\int_0^1 u_h'\,\phi_i' \,dx = \int_0^1 f\,\phi_i \,dx, \;\;\;\;\; \text{for}\;\;\;\; i=0, 1,\ldots, N. \]</div>
<p>Following this substitution the LHS can be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\int_0^1 u_h'\phi_i' \,dx 
&amp;= 
\int_0^1 \left(\sum_{j=0}^{N} u_j\,\phi_j'\right)\phi_i' \,dx \\[10pt]
&amp;= 
\sum_{j=0}^{N} u_j\, \int_0^1 \phi_j'\, \phi_i' \,dx.
\end{align*}
\end{split}\]</div>
<p>We now introduce the notation for the “discretisation” (or sometimes for historical reasons “stiffness”) matrix</p>
<div class="math notranslate nohighlight">
\[ K_{ij} = \int_0^1 \phi_j'\, \phi_i' \,dx, \;\;\;\;\; \text{for}\;\;\;\; i, \, j=0, 1,\ldots, N,\]</div>
<p>and the RHS vector</p>
<div class="math notranslate nohighlight">
\[ b_i = \int_0^1 f\, \phi_i \,dx, \;\;\;\;\; \text{for}\;\;\;\; i = 0, 1,\ldots, N.\]</div>
<p>Our discretised system can now be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*} 
\sum_{j=0}^{N} u_j\, \int_0^1 \phi_j'\, \phi_i' \,dx &amp;= \int_0^1 f\, \phi_i \,dx, \;\;\;\;\; \text{for}\;\;\;\; i = 0, 1,\ldots, N \\[10pt]
\iff
\sum_{j=0}^{N} u_j\, K_{ij} &amp;= b_i, \;\;\;\;\; \text{for}\;\;\;\; i = 0, 1,\ldots, N 
 \\[10pt]
\iff
K\boldsymbol{u} &amp;= \boldsymbol{b}.
\end{align*}
\end{split}\]</div>
<p>If we solve this matrix equation for the vector of coefficients <span class="math notranslate nohighlight">\(\,\boldsymbol{u}\,\)</span> then we have a numerical solution to our problem.</p>
<p>This is just as it was for simple <span class="math notranslate nohighlight">\(L^2\)</span> projection of a function, but now the mass matrix has been replaced by a similar discretisation matrix.  “Similar” in the sense that it is also tridiagonal and we can compute its entries in a very similar manner.</p>
</section>
<section id="id2">
<h3>Terminology<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>The basis function that appears in the expansion of the solution, i.e. the <span class="math notranslate nohighlight">\(\phi\)</span> that appears in <span class="math notranslate nohighlight">\(u_h := \sum_j u_j\,\phi_j\)</span> is termed a <em><strong>trial function</strong></em> - as it’s used to form a “<em><strong>trial</strong></em> solution”.  The corresponding function space <span class="math notranslate nohighlight">\(V\)</span> the <span class="math notranslate nohighlight">\(\phi\)</span>’s are a basis for, and hence the space our numerical solution lives in, is called the “<em><strong>trial space</strong></em>”.</p></li>
<li><p>The basis function we multiply our equation by before integrating is called a “<em><strong>test function</strong></em>” as we are “testing” for orthogonality of this solution’s residual to a function space spanned by these test functions. This function space is called the “<em><strong>test space</strong></em>”.</p></li>
<li><p>Note that in what we’ve seen above the trial functions are the same as the test functions.  This was the obvious and simplest choice (as we only needed to define a single set of basis functions and their derivatives etc) and having the same dimension meant we ended up with <span class="math notranslate nohighlight">\(n+1\)</span> equations for <span class="math notranslate nohighlight">\(n+1\)</span> unknowns.  However, there are reasons that one may wish to choose the test space differently to the trial space.</p></li>
<li><p>When we use the same space for test and trial functions the discretisation we end up with is called a <em><strong>Galerkin</strong></em> method (sometimes Bubnov-Galerkin), if different it is called a <em><strong>Petrov-Galerkin</strong></em> method</p></li>
</ol>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading">#</a></h3>
<p>Recall that our basis functions are defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\phi_i(x) = 
\begin{cases}
\frac{x - x_{i-1}}{\Delta x_{i-1}}, &amp;\text{if}\;\;\; x\in e_{i-1}\equiv[x_{i-1},x_{i}] \\[5pt]
\frac{x_{i+1} - x}{\Delta x_{i}}, &amp;\text{if}\;\;\; x\in e_{i}\equiv[x_{i},x_{i+1}] \\[5pt]
0, &amp; \text{otherwise} \\
\end{cases}
\end{split}\]</div>
<p>which looks like the following:</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/fem_basis_functions.svg"><img alt="../_images/fem_basis_functions.svg" src="../_images/fem_basis_functions.svg" width="75%" /></a>
</figure>
<br>
<p>and so their derivatives are simply</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\phi'_i(x) = 
\begin{cases}
\frac{1}{\Delta x_{i-1}}, &amp;\text{if}\;\;\; x\in e_{i-1}\equiv[x_{i-1},x_{i}] \\[5pt]
\frac{-1}{\Delta x_{i}}, &amp;\text{if}\;\;\; x\in e_{i}\equiv[x_{i},x_{i+1}] \\[5pt]
0, &amp; \text{otherwise} \\
\end{cases}
\end{split}\]</div>
<p>i.e. they are constant within elements.</p>
<p>Let’s write a function to return these values, and plot them to make sure they look right.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hat_function_deriv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Derivative of linear continuous basis function at node i.</span>
<span class="sd">    Returns a function for later use in quadrature rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  
                  <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">,</span>
                <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hat</span>

<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># the following would give you a variable mesh!</span>
<span class="c1">#x_nodes = x_nodes + ((x_nodes[-1]-x_nodes[0])/5)*np.random.rand(len(x_nodes))</span>

<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">x_nodes</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="s1">&#39;$x_0$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_3$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_4$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_5$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_6$&#39;</span><span class="p">,</span><span class="s1">&#39;$x_7$&#39;</span> <span class="p">),</span> 
                    <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;P1 basis function and its derivative&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># you can change the following to be in [0,n]</span>
<span class="n">node</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">phi</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\phi(x)$&#39;</span><span class="p">);</span>
<span class="n">phi_x</span> <span class="o">=</span> <span class="n">hat_function_deriv</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">[(</span><span class="n">x_fine</span><span class="o">&gt;</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x_fine</span><span class="o">&lt;</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])],</span> 
             <span class="n">phi_x</span><span class="p">(</span><span class="n">x_fine</span><span class="p">[(</span><span class="n">x_fine</span><span class="o">&gt;</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x_fine</span><span class="o">&lt;</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])]),</span> 
             <span class="s1">&#39;b-&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;$\phi&#39;(x)$&quot;</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;k:&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;k:&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;k:&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.15</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f42e4cb9b80&gt;
</pre></div>
</div>
<img alt="../_images/3b357ba2b4c19ef78ed77a209ba777f6bcc2677173c01155e0a450d0d3ad2fe8.png" src="../_images/3b357ba2b4c19ef78ed77a209ba777f6bcc2677173c01155e0a450d0d3ad2fe8.png" />
</div>
</div>
<p>The fact that the basis function derivatives that appear in the integrand are all constants over individual elements makes this discretisation matrix especially easy to evaluate.</p>
<p>Let’s consider an internal row <span class="math notranslate nohighlight">\(i\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
K_{ii} 
&amp;= \int_0^1 \phi_i'\, \phi_i' \,dx 
\\[10pt]
&amp;= 
\int_{x_{i-1}}^{x_i} \phi_i'\, \phi_i' \,dx + \int_{x_{i}}^{x_{i+1}} \phi_i'\, \phi_i' \,dx
\\[10pt]
&amp;= \int_{x_{i-1}}^{x_i} \frac{1}{\Delta x_{i-1}}\, \frac{1}{\Delta x_{i-1}} \,dx + \int_{x_{i}}^{x_{i+1}} \frac{-1}{\Delta x_{i}}\, \frac{-1}{\Delta x_{i}} \,dx
\\[10pt]
&amp;= \int_{x_{i-1}}^{x_i} \frac{1}{\Delta x_{i-1}^2} \,dx + \int_{x_{i}}^{x_{i+1}} \frac{1}{\Delta x_{i}^2} \,dx
\\[10pt]
&amp;= \frac{\Delta x_{i-1}}{\Delta x_{i-1}^2} + \frac{\Delta x_{i}}{\Delta x_{i}^2}
\\[10pt]
&amp;= \frac{1}{\Delta x_{i-1}} + \frac{1}{\Delta x_{i}}.
\end{align*}
\end{split}\]</div>
<p>Similarly,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
K_{i,i-1} 
&amp;= \int_0^1 \phi_i'\, \phi_{i-1}' \,dx 
\\[10pt]
&amp;= 
\int_{x_{i-1}}^{x_i} \phi_i'\, \phi_{i-1}' \,dx 
\\[10pt]
&amp;= \int_{x_{i-1}}^{x_i} \frac{1}{\Delta x_{i-1}}\, \frac{-1}{\Delta x_{i-1}} \,dx 
\\[10pt]
&amp;= \int_{x_{i-1}}^{x_i} \frac{-1}{\Delta x_{i-1}^2} \,dx 
\\[10pt]
&amp;= \frac{-1}{\Delta x_{i-1}},
\end{align*}
\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
K_{i,i+1} 
&amp;= \int_0^1 \phi_i'\, \phi_{i+1}' \,dx 
\\[10pt]
&amp;= 
\int_{x_{i}}^{x_{i+1}} \phi_i'\, \phi_{i+1}' \,dx 
\\[10pt]
&amp;= \int_{x_{i}}^{x_{i+1}} \frac{-1}{\Delta x_{i}}\, \frac{1}{\Delta x_{i}} \,dx 
\\[10pt]
&amp;= \int_{x_{i}}^{x_{i+1}} \frac{-1}{\Delta x_{i}^2} \,dx 
\\[10pt]
&amp;= \frac{-1}{\Delta x_{i}}.
\end{align*}
\end{split}\]</div>
<p>Now consider the case <span class="math notranslate nohighlight">\(i=0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
K_{0,0} 
&amp;= \int_0^1 \phi_0'\, \phi_0' \,dx 
\\[10pt]
&amp;= 
\int_{x_{0}}^{x_1} \phi_0'\, \phi_0' \,dx \\[10pt]
&amp;= \int_{x_{0}}^{x_1} \frac{-1}{\Delta x_{0}}\, \frac{-1}{\Delta x_{0}} \,dx 
\\[10pt]
&amp;= \int_{x_{0}}^{x_1} \frac{1}{\Delta x_{0}^2} \,dx \\[10pt]
&amp;= \frac{1}{\Delta x_{0}},
\end{align*}
\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
K_{0,1} 
&amp;= \int_0^1 \phi_0'\, \phi_{1}' \,dx 
\\[10pt]
&amp;= 
\int_{x_{0}}^{x_{1}} \phi_0'\, \phi_{1}' \,dx 
\\[10pt]
&amp;= \int_{x_{0}}^{x_{1}} \frac{-1}{\Delta x_{0}}\, \frac{1}{\Delta x_{0}} \,dx 
\\[10pt]
&amp;= \int_{x_{0}}^{x_{1}} \frac{-1}{\Delta x_{0}^2} \,dx 
\\[10pt]
&amp;= \frac{-1}{\Delta x_{0}},
\end{align*}
\end{split}\]</div>
<p>which by symmetry is that same as <span class="math notranslate nohighlight">\(K_{1,0}\)</span>.</p>
<p>The entries for the <span class="math notranslate nohighlight">\(i=n\)</span> row are defined similarly in terms of <span class="math notranslate nohighlight">\(\Delta x_n\)</span>.</p>
<p>Let’s construct an example of the <span class="math notranslate nohighlight">\(K\)</span> matrix, and compare to the mass matrix:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N_elements_CG</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">N_nodes_CG</span> <span class="o">=</span> <span class="n">N_elements_CG</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">N_nodes_CG</span> <span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>

<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_nodes_CG</span><span class="p">,</span> <span class="n">N_nodes_CG</span> <span class="p">))</span>

<span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span>  <span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> \
    <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># add in the top row entries</span>
<span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># add in the bottom row entries</span>
<span class="n">K</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">K</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">K</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;K = &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

<span class="c1"># compare to the mass matrix</span>
<span class="o">%</span><span class="k">precision</span> 3
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">M= &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mass_matrix</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>K = 
[[ 5. -5.  0.  0.  0.  0.]
 [-5. 10. -5.  0.  0.  0.]
 [ 0. -5. 10. -5.  0.  0.]
 [ 0.  0. -5. 10. -5.  0.]
 [ 0.  0.  0. -5. 10. -5.]
 [ 0.  0.  0.  0. -5.  5.]]

M= 
[[0.067 0.033 0.    0.    0.    0.   ]
 [0.033 0.133 0.033 0.    0.    0.   ]
 [0.    0.033 0.133 0.033 0.    0.   ]
 [0.    0.    0.033 0.133 0.033 0.   ]
 [0.    0.    0.    0.033 0.133 0.033]
 [0.    0.    0.    0.    0.033 0.067]]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="a-simple-problem-with-homogeneous-dirichlet-bcs">
<h2>A simple problem with homogeneous Dirichlet BCs<a class="headerlink" href="#a-simple-problem-with-homogeneous-dirichlet-bcs" title="Permalink to this heading">#</a></h2>
<p>Now let’s complete the description of our problem through the addition of some boundary conditions - our problem is not well-posed (we cannot solve it) without the addition of appropriate BCs.</p>
<section id="problem-description">
<h3>Problem description<a class="headerlink" href="#problem-description" title="Permalink to this heading">#</a></h3>
<p>Find <span class="math notranslate nohighlight">\(u\equiv u(x)\)</span> which satisfies the ODE over the interval <span class="math notranslate nohighlight">\([0,1]\)</span></p>
<div class="math notranslate nohighlight">
\[-u'' = f,\]</div>
<p>for a given source term <span class="math notranslate nohighlight">\(\,f\)</span>, with homogeneous Dirichlet boundary conditions:</p>
<div class="math notranslate nohighlight">
\[ u(0) = u(1) = 0.\]</div>
<p>Physically we can interpret this as the steady state solution to a diffusion problem with a source given by <span class="math notranslate nohighlight">\(f\)</span> and the solution “clamped” at the value zero at the ends of the domain.</p>
<p>To begin let’s consider the problem with <span class="math notranslate nohighlight">\(f\equiv 1\)</span> which with these BCs has the exact solution <span class="math notranslate nohighlight">\(u=-x(x-1)/2\)</span>.</p>
</section>
<section id="id3">
<h3>Finite element approximation<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h3>
<p>For this version of the problem (i.e. with Dirichlet boundary conditions) we have to make a few changes to what we did above for the generic case with no boundary conditions.</p>
<p>In the case of Dirichlet BCs we know the value of the solution at the ends of the domain, and so we do not need to solve for the discrete values <span class="math notranslate nohighlight">\(u_0\)</span> and <span class="math notranslate nohighlight">\(u_N\)</span>.</p>
<p>Furthermore, since these take the values zero in this case
the approximate solution we substitute into our weak form is therefore</p>
<div class="math notranslate nohighlight">
\[u_h := \sum_{j=1}^{N-1} u_j\,\phi_j,\]</div>
<p>[we’ve dropped the first and last terms in the summation that we know are zero - a consequence is that our approximate solution only has <span class="math notranslate nohighlight">\(N-1\)</span> free parameters].</p>
<p>Said another way, we look for a solution to our problem in the space of p/w linear functions which are zero at the boundaries:</p>
<div class="math notranslate nohighlight">
\[V_h^0 := \left\{v \in V_h \,|\, v(0)=v(1)=0\right\}.\]</div>
<p>In our weak form we test against all <span class="math notranslate nohighlight">\(v\in V_h^0\)</span>, and since all these <span class="math notranslate nohighlight">\(v\)</span> vanish at the boundary
this justified why in this case we can simply ignore the boundary term in our weak form (i.e.
<span class="math notranslate nohighlight">\(\int_{\partial I} u_h'\,v\,dx = 0\)</span>) and thus we have:</p>
<div class="math notranslate nohighlight">
\[\int_I \,u_h'\,v'\,dx = \int_I \,f\,v\,dx, \quad \forall v\in V_h^0.\]</div>
<p>We can again equivalently instead consider basis functions and ask that our solution satisfies</p>
<div class="math notranslate nohighlight">
\[\int_0^1 u_h'\,\phi_i' \,dx = \int_0^1 f\,\phi_i \,dx, \;\;\;\;\; \text{for}\;\;\;\; i=1, 2,\ldots, N-1, \]</div>
<p>where now <span class="math notranslate nohighlight">\(i\)</span> ranges over 2 less values (as <span class="math notranslate nohighlight">\(V_h^0\)</span> is now <span class="math notranslate nohighlight">\(N-1\)</span> rather than <span class="math notranslate nohighlight">\(N+1\)</span> dimensional on our mesh).</p>
<p>[This is equivalent to the so-called “lifting” approach for imposing BCs we saw earlier].</p>
<p>Substituting in our form for our numerical solution again leads us to the matrix system</p>
<div class="math notranslate nohighlight">
\[K\boldsymbol{u} = \boldsymbol{b},\]</div>
<p>where <span class="math notranslate nohighlight">\(K\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{b}\)</span> are defined as before, but without the first and last rows and columns (for <span class="math notranslate nohighlight">\(A\)</span>) we had previously.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># don&#39;t need the composite version of Simpson&#39;s rule here - </span>
<span class="c1"># use the non composite version that is able to integrate over a </span>
<span class="c1"># **single** interval and evaluates the function</span>
<span class="c1"># at the two end points as well as the mid point</span>
<span class="k">def</span> <span class="nf">simpsons_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Function to evaluate Simpson&#39;s rule. </span>
<span class="sd">    </span>
<span class="sd">    Note that this implementation takes the function as an argument, </span>
<span class="sd">    and evaluates this at the midpoint of subintervals in addition to the </span>
<span class="sd">    end point. Hence additional information is generated and used through </span>
<span class="sd">    additional function evaluations. </span>
<span class="sd">    </span>
<span class="sd">    This is different to the function/implementation available with SciPy  </span>
<span class="sd">    where discrete data only is passed to the function. </span>
<span class="sd">    </span>
<span class="sd">    Bear this in mind when comparing results - there will be a factor of two</span>
<span class="sd">    in the definition of &quot;n&quot; we need to be careful about!</span>
<span class="sd">    </span>
<span class="sd">    Also note that this version of the function performs redundant function </span>
<span class="sd">    evaluations - see the **composite** implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">number_intervals</span>

    <span class="k">assert</span> <span class="n">interval_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>

    <span class="n">I_S</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Loop to valuate Simpson&#39;s formula over each interval </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
        <span class="c1"># Find a, c, and b</span>
        <span class="n">this_bin_start</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">interval_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">this_bin_mid</span> <span class="o">=</span> <span class="n">this_bin_start</span> <span class="o">+</span> <span class="n">interval_size</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">this_bin_end</span> <span class="o">=</span> <span class="n">this_bin_start</span> <span class="o">+</span> <span class="n">interval_size</span>
        <span class="c1"># Calculate the rule and add to running total.</span>
        <span class="n">I_S</span> <span class="o">+=</span> <span class="p">(</span><span class="n">interval_size</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">this_bin_start</span><span class="p">)</span> <span class="o">+</span>
                                  <span class="mi">4</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">this_bin_mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">this_bin_end</span><span class="p">))</span>

    <span class="c1"># Return our running total result</span>
    <span class="k">return</span> <span class="n">I_S</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># let&#39;s discretise and solve our problem using the FEM</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span>

<span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">N_elements_CG</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">N_nodes_CG</span> <span class="o">=</span> <span class="n">N_elements_CG</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">N_nodes_CG</span> <span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>

<span class="c1"># space to store our discretisaton matrices</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_nodes_CG</span> <span class="o">-</span><span class="mi">2</span> <span class="p">,</span> <span class="n">N_nodes_CG</span> <span class="o">-</span><span class="mi">2</span> <span class="p">))</span>

<span class="c1"># we only need the internal entries of the K defined above in this case</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span>  <span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> \
    <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> \
    <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># print out K to show that we&#39;ve lost the first and last rows/columns </span>
<span class="c1"># compared to the previous K we printed</span>
<span class="nb">print</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

<span class="c1"># form RHS vector by integrating the function f multiplied by a basis function.</span>
<span class="c1"># loop over internal nodes</span>
<span class="n">RHS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_nodes_CG</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_nodes_CG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="c1"># and integrate our function multiplied by the corresponding cts basis function  </span>
    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># simpsons with number intervals = 2 can integrate this exactly</span>
    <span class="n">RHS</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpsons_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>

<span class="c1"># now we have our equation for the unknowns (K @ u=RHS) solve for u:</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">sl</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">RHS</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[18. -9.  0.  0.  0.  0.  0.  0.]
 [-9. 18. -9.  0.  0.  0.  0.  0.]
 [ 0. -9. 18. -9.  0.  0.  0.  0.]
 [ 0.  0. -9. 18. -9.  0.  0.  0.]
 [ 0.  0.  0. -9. 18. -9.  0.  0.]
 [ 0.  0.  0.  0. -9. 18. -9.  0.]
 [ 0.  0.  0.  0.  0. -9. 18. -9.]
 [ 0.  0.  0.  0.  0.  0. -9. 18.]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot the exact solution and our numerical approximation, </span>
<span class="c1"># and print out the RMS error</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$u(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Steady state diffusion solve&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;bo-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;FE solution&#39;</span><span class="p">)</span>
<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x_fine</span><span class="o">*</span><span class="p">(</span><span class="n">x_fine</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exact solution&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error (RMS at nodes only) = &#39;</span><span class="p">,</span> 
      <span class="n">sl</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
      <span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>error (RMS at nodes only) =  6.582812753581314e-17
</pre></div>
</div>
<img alt="../_images/9b7c288ff7a667f9849a011c999d7726604c365ff4d19b0304243b5df9892e62.png" src="../_images/9b7c288ff7a667f9849a011c999d7726604c365ff4d19b0304243b5df9892e62.png" />
</div>
</div>
</section>
<section id="id4">
<h3>Comments<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>We could of course add back in the fact that <span class="math notranslate nohighlight">\(u_h(0)=u_h(1)=0\)</span> values to get a solution plot that extends all the way to the boundaries.</p></li>
<li><p>Notice that we have obtained a solution in this case that is exact (to round off error) at the nodes. This is because we can evaluate the RHS vector exactly (i.e. no errors are introduced in this step) and also as our scheme is of high enough order to be able to integrate this problem exactly.</p></li>
<li><p>But notice that the error is not zero when considered in the interior of elements - the more complex examples consider this point further.</p></li>
</ul>
<br>
<p>Some more complex problems with non-zero RHS and/or more complex inhomogeneous Dirichlet/Neumann type BCs are covered in the homework notebook.</p>
</section>
</section>
<section id="practical-implementation-of-the-fem-local-assembly-over-elements">
<h2>Practical implementation of the FEM - local assembly over elements<a class="headerlink" href="#practical-implementation-of-the-fem-local-assembly-over-elements" title="Permalink to this heading">#</a></h2>
</section>
<section id="the-underlying-idea">
<h2>The underlying idea<a class="headerlink" href="#the-underlying-idea" title="Permalink to this heading">#</a></h2>
<p>When we formed the discretisation matrices in the examples we considered earlier (both the projection of a given function as well as the solution of BVPs examples), recall that we <em><strong>looped over the nodes</strong></em> and did an integral over the elements either side (in 1D, and apart from at boundaries).</p>
<p>These nodes corresponded with a particular trial function.</p>
<p>For each node we constructed the corresponding entry of the <strong>load vector</strong> by integrating using Simpson’s rule the appropriate integral (<span class="math notranslate nohighlight">\(f\,\phi_i\)</span>) over the elements on each side of that node [in homework exercise].</p>
<br>
In general we constructed the left hand side **discretisation matrix** directly (i.e. we wrote functions that used appropriate `np.diag` calls) using our analytical knowledge of the values of the required integrals (e.g. of $\phi_i\,\phi_j$ in the case of the mass matrix, and products of the derivatives of the basis functions in the BVP case), and the fact that they took a simple tridiagonal form. 
<p>Recall that we did demonstrate through an application of Simpson’s rule that quadrature rules were able to recreate our analytical result for the mass matrix (due to us being in 1D (hence simple shape) and integrating relatively low order polynomials).</p>
<br>
<p>However, note that this means of constructing the left hand side matrix won’t be possible for more complex problems, and in the case of the load vector an approach of looping over nodes and then visiting each surrounding element won’t be optimal in higher dimensions</p>
<br> 
<p>A far better approach, termed <em><strong>assembly</strong></em> or <em><strong>local assembly</strong></em>, which addresses both issues is instead to loop <em><strong>over the elements</strong></em> visting each one just once, compute the required integrals only over that element, and <em>add</em> the appropriate results of these integrals into the appropriate locations of the global discretisation matrices.</p>
<br>
<p>To help clarify this idea let’s consider the example of the mass matrix.</p>
</section>
<section id="local-assembly-for-the-mass-matrix">
<h2>Local assembly for the mass matrix<a class="headerlink" href="#local-assembly-for-the-mass-matrix" title="Permalink to this heading">#</a></h2>
<p>Recall that the mass matrix <span class="math notranslate nohighlight">\(M\)</span> is defined to be the matrix with the entries</p>
<div class="math notranslate nohighlight">
\[ M_{ij} = \int_\Omega \,\phi_i(x)\,\phi_j(x)\,  dx. \]</div>
<p>We noted that given the form of our basis functions (i.e. having finite compact support) that <span class="math notranslate nohighlight">\(M\)</span> is <em>sparse</em> - for a given row, <span class="math notranslate nohighlight">\(i\)</span>,  the integrand in the definition above will be zero for all <span class="math notranslate nohighlight">\(j\)</span> values other than <span class="math notranslate nohighlight">\(j=i\)</span>, and <span class="math notranslate nohighlight">\(j=i\pm 1\)</span>, i.e. the mass matrix is tridiagonal in 1D.</p>
<p>We demonstrated that an internal row (the <span class="math notranslate nohighlight">\(i\)</span>-th row) of the tridiagonal mass matrix has the entries</p>
<div class="math notranslate nohighlight">
\[\left[0 \;\;\;\;\; \cdots \;\;\;\;\; 0 \;\;\;\;\; \frac{\Delta x_{i-1}}{6} \;\;\;\;\;  \frac{\Delta x_{i-1}}{3} + \frac{\Delta x_{i}}{3}  \;\;\;\;\; \frac{\Delta x_{i}}{6} \;\;\;\;\; 0 \;\;\;\;\; \cdots \;\;\;\;\;  0  \right], \]</div>
<p>with the first and last rows being</p>
<div class="math notranslate nohighlight">
\[\left[\frac{\Delta x_{0}}{3}  \;\;\;\;\; \frac{\Delta x_{0}}{6} \;\;\;\;\; 0 \;\;\;\;\; \cdots \;\;\;\;\;  0  \right], \]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\left[0 \;\;\;\;\; \cdots \;\;\;\;\; 0 \;\;\;\;\; \frac{\Delta x_{n}}{6} \;\;\;\;\;  \frac{\Delta x_{n}}{3}\right]. \]</div>
<p>Combining we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} M = 
\begin{pmatrix}
\frac{\Delta x_0}{3}  &amp; \frac{\Delta x_0}{6} &amp; &amp; &amp;  
\\
\frac{\Delta x_0}{6}  &amp; \left(\frac{\Delta x_0}{3} + \frac{\Delta x_1}{3}\right) &amp; \frac{\Delta x_1}{6} &amp; &amp;  \\
&amp;\frac{\Delta x_1}{6}  &amp; \left(\frac{\Delta x_1}{3} + \frac{\Delta x_2}{3}\right) &amp; \frac{\Delta x_2}{6}  &amp;  \\
&amp;  &amp;  \ddots &amp; &amp;  
\\
&amp; &amp;\frac{\Delta x_{n-1}}{6}  &amp; \left(\frac{\Delta x_{n-1}}{3} + \frac{\Delta x_n}{3}\right) &amp; \frac{\Delta x_n}{6}  \\
&amp; &amp;   &amp;  \frac{\Delta x_n}{6} &amp; \frac{\Delta x_n}{3}
\end{pmatrix}.
\end{split}\]</div>
<p>Notice first that this is equivalent to [NB. I’m using notation that assumes that all entries not explicitly given in the presented matrices are zero]</p>
<div class="math notranslate nohighlight">
\[\begin{split} M = 
\begin{bmatrix}
\frac{\Delta x_0}{3} &amp; \frac{\Delta x_0}{6} &amp; &amp;  \\
\frac{\Delta x_0}{6} &amp; \frac{\Delta x_0}{3} &amp; &amp; \\ 
&amp; &amp; &amp; \\
&amp; &amp; &amp; \\
&amp; &amp; &amp; \\
&amp; &amp; &amp; 
\end{bmatrix} 
+
\begin{bmatrix}
&amp; &amp; &amp; \\
&amp; \frac{\Delta x_1}{3} &amp; \frac{\Delta x_1}{6}  &amp; \\ 
&amp; \frac{\Delta x_1}{6} &amp; \frac{\Delta x_1}{3}  &amp;  \\
&amp; &amp; &amp; \\
&amp; &amp; &amp; \\
&amp; &amp; &amp; 
\end{bmatrix} 
+ \ldots +
\begin{bmatrix}
&amp; &amp; &amp; \\
&amp; &amp; &amp; \\
&amp; &amp; &amp; \\
&amp; &amp; &amp; \\
&amp; &amp; \frac{\Delta x_n}{3} &amp; \frac{\Delta x_n}{6} \\
&amp; &amp;\frac{\Delta x_n}{6}  &amp; \frac{\Delta x_n}{3}  
\end{bmatrix},
\end{split}\]</div>
<p>i.e. the global mass matrix is equivalent to the summation of (<span class="math notranslate nohighlight">\(n\)</span>, which is the number of elements)
<span class="math notranslate nohighlight">\(2\times 2\)</span> matrices which all take the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{6}
\begin{bmatrix}
2 &amp; 1\\
1 &amp; 2
\end{bmatrix}{\Delta x_i}.
\end{split}\]</div>
<p>Note that this smaller matrix only involves the size of element <span class="math notranslate nohighlight">\(i\)</span>, and as we shall see can be associated only with element <span class="math notranslate nohighlight">\(i\)</span>.  We therefore call it the <em><strong>local element mass matrix</strong></em> for element <span class="math notranslate nohighlight">\(i\)</span>.  Notice also that this same definition applies equally well to the first and last elements, i.e. we don’t need to do anything special/different at boundaries (we will see that this is expected as we are dealing with each element in isolation, it’s not important if it’s next to the boundary or not).</p>
<p>Considering element <span class="math notranslate nohighlight">\(i\)</span>, we can see that the above <span class="math notranslate nohighlight">\(2\times 2\)</span> sub-matrix block comes from the following contributions</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
\int_{e_i} \,\phi_i(x)\,\phi_i(x)\, dx     &amp; \int_{e_i} \,\phi_i(x)\,\phi_{i+1}(x)\, dx \\
\int_{e_i} \,\phi_i(x)\,\phi_{i+1}(x)\, dx &amp; \int_{e_i} \,\phi_{i+1}(x)\,\phi_{i+1}(x)\, dx
\end{bmatrix}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(e_i = [x_i,x_{i+1}]\)</span> is the <span class="math notranslate nohighlight">\(i\)</span>-th element.</p>
<p>Note that when we sum up all these individual local mass matrices, each main diagonal (other than the first and last) will receive two contributions. Note that all that is happening here is what we saw analytically earlier when we integrated over the two elements either side of the node under consideration in order to derive an expression for the mass matrix.</p>
<p>To see that this makes sense another way, first we note that the total integral can be split up over elements:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
M_{ij} &amp;= \int_\Omega \,\phi_i(x)\,\phi_j(x)\,  dx\\[5pt]
&amp;= \sum_k\,\int_{e_k} \,\phi_i(x)\,\phi_j(x)\,  dx.
\end{align*}
\end{split}\]</div>
<p>Then we note that most of the elemental contributions will be zero since the integrand will be zero over them. For example, for the diagonal entries we only have to consider</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
M_{ii} 
&amp; = \sum_k\,\int_{e_k} \,\phi_i(x)\,\phi_i(x)\,  dx\\[5pt]
&amp; = \int_{e_{i-1}} \,\phi_i(x)\,\phi_i(x)\,  dx + \int_{e_{i}} \,\phi_i(x)\,\phi_i(x)\,  dx\\[5pt]
&amp; = \int_{x_{i-1}}^{x_{i}} \,\phi_i(x)\,\phi_i(x)\,  dx + \int_{x_{i}}^{x_{i+1}} \,\phi_i(x)\,\phi_i(x)\,  dx\\[5pt]
&amp; \; \vdots\\[5pt]
&amp; = \frac{\Delta x_{i-1}}{3} + \frac{\Delta x_{i}}{3}.
\end{align*}
\end{split}\]</div>
<br>
<p>The overall procedure underlying <em>local assembly</em> is therefore to</p>
<ol class="arabic simple">
<li><p>loop over elements</p></li>
<li><p>calculate the individual contributions to the local element mass matrix by considering combinations of the basis functions corresponding to the local node numbers (i.e. the four entries in the <span class="math notranslate nohighlight">\(2\times 2\)</span> sub-matrix block above)</p></li>
<li><p>Identify the appropriate locations of the global mass matrix and <em>add</em> the current element’s contributions to the values already in these locations</p></li>
</ol>
<p>Note that for fully unstructured meshes in higher dimensions, there will be multiple contributions feeding into each entry of the global mass matrix (think multiple triangular elements surrounding a node/vertex).</p>
<p>Note also that exactly the same assembly procedure can be used to construct more complex discretisation matrices (e.g. the matrix <span class="math notranslate nohighlight">\(A\)</span> in the BVP section) as well as the RHS load vectors.</p>
</section>
<section id="example-projection">
<h2>Example - projection<a class="headerlink" href="#example-projection" title="Permalink to this heading">#</a></h2>
<p>Let’s demonstrate the assembly process through an example.</p>
<p>Recall our initial example from earlier where we “projected” a general function <span class="math notranslate nohighlight">\(\,f\,\)</span> into the space of p/w linear functions.</p>
<p>First let’s run our code from earlier which involved us defining the mass matrix analytically, and computing the RHS load vector through a <strong>loop over nodes</strong> (and evaluating the integrals on the elements either side to compute the nodal entry in one go) - an approach we just said isn’t really a viable approach in higher dimensions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># to do this we need our Simpson&#39;s quadrature codes</span>

<span class="k">def</span> <span class="nf">simpsons_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Function to evaluate Simpson&#39;s rule. </span>
<span class="sd">    </span>
<span class="sd">    Note that this implementation takes the function as an argument, </span>
<span class="sd">    and evaluates this at the midpoint of subintervals in addition to the </span>
<span class="sd">    end point. Hence additional information is generated and used through </span>
<span class="sd">    additional function evaluations. </span>
<span class="sd">    </span>
<span class="sd">    This is different to the function/implementation available with SciPy  </span>
<span class="sd">    where discrete data only is passed to the function. </span>
<span class="sd">    </span>
<span class="sd">    Bear this in mind when comparing results - there will be a factor of two</span>
<span class="sd">    in the definition of &quot;n&quot; we need to be careful about!</span>
<span class="sd">    </span>
<span class="sd">    Also note that this version of the function performs redundant function </span>
<span class="sd">    evaluations - see the **composite** implementation below.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">number_intervals</span>

    <span class="k">assert</span> <span class="n">interval_size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>

    <span class="n">I_S</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Loop to valuate Simpson&#39;s formula over each interval </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_intervals</span><span class="p">):</span>
        <span class="c1"># Find a, c, and b</span>
        <span class="n">this_bin_start</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">interval_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">this_bin_mid</span> <span class="o">=</span> <span class="n">this_bin_start</span> <span class="o">+</span> <span class="n">interval_size</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">this_bin_end</span> <span class="o">=</span> <span class="n">this_bin_start</span> <span class="o">+</span> <span class="n">interval_size</span>
        <span class="c1"># Calculate the rule and add to running total.</span>
        <span class="n">I_S</span> <span class="o">+=</span> <span class="p">(</span><span class="n">interval_size</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">this_bin_start</span><span class="p">)</span> <span class="o">+</span>
                                  <span class="mi">4</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">this_bin_mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">this_bin_end</span><span class="p">))</span>

    <span class="c1"># Return our running total result</span>
    <span class="k">return</span> <span class="n">I_S</span>

<span class="k">def</span> <span class="nf">simpsons_composite_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to evaluate the composite Simpson&#39;s rule only using</span>
<span class="sd">    function evaluations at (number_intervals + 1) points.</span>
<span class="sd">    </span>
<span class="sd">    This implementation requires that the number of subintervals (number_intervals) be even</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">number_intervals</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;number_intervals is not even&quot;</span>

    <span class="n">interval_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">number_intervals</span>
    <span class="c1"># start with the two end member values</span>
    <span class="n">I_cS2</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># add in those terms with a coefficient of 4</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">number_intervals</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="c1"># and those terms with a coefficient of 2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number_intervals</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">I_cS2</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">I_cS2</span> <span class="o">*</span> <span class="p">(</span><span class="n">interval_size</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The following is the code we wrote to set-up and solve the appropriate matrix system to yield the solution at the mesh vertices earlier - we repeat it here to give us something to verify our new approach/code against.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># discrete data</span>
<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">N_elements</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N_nodes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mass_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span>  <span class="o">+</span>  <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="mi">3</span> <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    <span class="n">M</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="mi">6</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="mi">6</span>   <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">M</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="n">Mass_CG</span> <span class="o">=</span> <span class="n">mass_matrix</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>

<span class="c1"># construct RHS vector</span>
<span class="n">RHS_CG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">hat_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Top hat basis function at node i.</span>
<span class="sd">    Returns a function for later use in quadrature rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  
                  <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]],[</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">,</span>
                <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hat</span>


<span class="c1"># loop over internal nodes</span>

<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># and integrate our function multiplied by the corresponding cts basis function</span>
    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># simpsons with number intervals = 2 can integrate this exactly</span>
    <span class="n">RHS_CG</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpsons_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="c1">#</span>
                                 <span class="n">integrand</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>
    
    
<span class="c1"># now the end nodes</span>
<span class="n">node</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># integrate our function multiplied by the corresponding cts basis function</span>
<span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">RHS_CG</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> 
                                       <span class="n">integrand</span><span class="p">,</span> <span class="mi">50</span> <span class="p">)</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">N_nodes</span><span class="o">-</span><span class="mi">1</span>
<span class="c1"># integrate our function multiplied by the corresponding cts basis function</span>
<span class="n">phi_i</span> <span class="o">=</span> <span class="n">hat_function</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">x_nodes</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">RHS_CG</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">50</span> <span class="p">)</span>

<span class="n">approx_CG</span> <span class="o">=</span> <span class="n">sl</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Mass_CG</span><span class="p">,</span> <span class="n">RHS_CG</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mass matrix =&#39;</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">Mass_CG</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RHS vector =&#39;</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">RHS_CG</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mass matrix =
array([[0.111, 0.056, 0.   , 0.   ],
       [0.056, 0.222, 0.056, 0.   ],
       [0.   , 0.056, 0.222, 0.056],
       [0.   , 0.   , 0.056, 0.111]])

RHS vector =
array([ 0.137,  0.197, -0.199, -0.092])
</pre></div>
</div>
</div>
</div>
<p>Note that in the code above we looped over the nodes, and for the internal nodes computed the appropriate integral over the elements either side of the node in one go to compute the RHS vector, and we used our analytical function for the mass matrix.</p>
<br>
<p>Let’s recode this using <em>local assembly</em> for both the mass matrix and the RHS vector, and check we get the same result.</p>
<p>We need to:</p>
<ol class="arabic simple">
<li><p>Loop over elements.</p></li>
<li><p>Loop over combinations of the local basis functions (giving the 4 entries of the <span class="math notranslate nohighlight">\(2\times 2\)</span> elemental matrix).</p></li>
<li><p>Perform the quadratures only over the local element (to actually compute these 4 entries).</p></li>
<li><p>Add in the contributions to the appropriate locations of the global matrices/vectors.</p></li>
</ol>
</section>
<section id="unstructured-mesh-data-structures-the-connectivity-matrix">
<h2>Unstructured mesh data structures (the connectivity matrix)<a class="headerlink" href="#unstructured-mesh-data-structures-the-connectivity-matrix" title="Permalink to this heading">#</a></h2>
<p>In order to know where the local contributions contribute to the global matrices, we make use of the so-called <em>connectivity matrix</em>.</p>
<p>It will seem a triviality in 1D, but it’s vitally important in higher dimensions. We’ll give the 2D generalisation later.</p>
<p>The following image presents a schematic of an unstructured mesh data structure, or connectivity, in the simple 1D case and assuming that we have two nodes per element (i.e. the p/w linear case), and that these are located at the ends of the elements (other more complex choices are possible!)</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/connectivity_1d.svg"><img alt="../_images/connectivity_1d.svg" src="../_images/connectivity_1d.svg" width="75%" /></a>
</figure>
<ul class="simple">
<li><p>Blue are the <em>element numbers</em></p></li>
<li><p>Red are the <em>local node numbers</em> (as in local to that element)</p></li>
<li><p>Black are the <em>global node numbers</em></p></li>
</ul>
<p>The connectivity can be described by the so-called connectivity matrix, which again in 1D takes the particularly simple form</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
    0 &amp; 1 &amp; \ldots &amp; i-1 &amp; i   &amp; i+1 &amp; \ldots &amp; n \\
    1 &amp; 2 &amp; \ldots &amp; i   &amp; i+1 &amp; i+2 &amp; \ldots &amp; n+1
\end{pmatrix}
\end{split}\]</div>
<p>the column being the element, the row the local node number, and the entry of the matrix then being the global node number.</p>
<p>The size of the connectivity matrix is therefore:</p>
<div class="math notranslate nohighlight">
\[\text{the number of local nodes per element}\;\;\times\;\;\text{the number of elements},\]</div>
<p>and it provides a mapping from elements to global node numbers that we use to tell us where to add in the entries we compute over a local element into the global discretisation matrices.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the connectivity matrix in 1D we need to use for this case.</span>

<span class="c1"># mesh information</span>
<span class="n">N_nodes</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">N_elements</span> <span class="o">=</span> <span class="n">N_nodes</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">x_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N_nodes</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">)</span>

<span class="c1"># number of nodes per element </span>
<span class="n">N_loc</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># the connectivity matrix giving us a mapping from local to global numbering</span>
<span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_loc</span><span class="p">,</span> <span class="n">N_elements</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">N_elements</span><span class="p">):</span>
    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>
    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span> <span class="o">+</span> <span class="mi">1</span>
    
<span class="nb">print</span><span class="p">(</span><span class="n">connectivity_matrix</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0 1 2]
 [1 2 3]]
</pre></div>
</div>
</div>
</div>
<p>Now let’s write some code to perform assembly to compute both the mass matrix as well as the RHS load vector, and check that we get the same results as our previous implementation which returned</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">Mass</span> <span class="n">matrix</span> <span class="o">=</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.11111111</span><span class="p">,</span> <span class="mf">0.05555556</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span><span class="mf">0.05555556</span><span class="p">,</span> <span class="mf">0.22222222</span><span class="p">,</span> <span class="mf">0.05555556</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.05555556</span><span class="p">,</span> <span class="mf">0.22222222</span><span class="p">,</span> <span class="mf">0.05555556</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.05555556</span><span class="p">,</span> <span class="mf">0.11111111</span><span class="p">]])</span>

<span class="n">RHS</span> <span class="n">vector</span> <span class="o">=</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.13686339</span><span class="p">,</span>  <span class="mf">0.19747647</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1988013</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.0924463</span> <span class="p">])</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># project f(x) onto p/w linears using local assembly to form mass matrix and RHS load vector</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          
<span class="c1"># construct mass matrix and RHS vector using **local assembly**</span>

<span class="c1"># initialise M to a zero array - we will **add** in the entries</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">N_nodes</span><span class="p">))</span>
<span class="n">RHS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">)</span>
<span class="c1"># loop over elements</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_elements</span><span class="p">):</span>
    <span class="c1"># loop over the LOCAL nodes (i: test functions)</span>
    <span class="k">for</span> <span class="n">i_local</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_loc</span><span class="p">):</span>
        <span class="c1"># for this local node number on this element, </span>
        <span class="c1"># compute the corresponding global node number</span>
        <span class="n">i_global</span> <span class="o">=</span> <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">i_local</span><span class="p">,</span> <span class="n">element</span><span class="p">]</span>
        <span class="c1"># add contribution to RHS vector - </span>
        <span class="c1"># these integrals will be explained in the next cell</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i_local</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i_global</span><span class="p">]</span> <span class="o">+</span> 
                                       <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="n">element</span><span class="p">])</span> <span class="o">+</span> 
                                     <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">*</span><span class="n">xi</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># here i_global corresponds to node i+1 so redefine x(xi) accordingly</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span> <span class="p">((</span><span class="n">x_nodes</span><span class="p">[</span><span class="n">i_global</span><span class="p">]</span><span class="o">-</span><span class="n">dx</span><span class="p">[</span><span class="n">element</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="n">element</span><span class="p">])</span> 
                                     <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">*</span><span class="n">xi</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">xi</span><span class="p">)</span>
        <span class="n">RHS</span><span class="p">[</span><span class="n">i_global</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">*</span> <span class="n">simpsons_composite_rule</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>
        <span class="c1"># Now for the mass matrix</span>
        <span class="c1"># loop over local nodes (j: trial functions)</span>
        <span class="k">for</span> <span class="n">j_local</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_loc</span><span class="p">):</span>
            <span class="n">j_global</span> <span class="o">=</span> <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">j_local</span><span class="p">,</span> <span class="n">element</span><span class="p">]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i_local</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">j_local</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>      
                    <span class="c1"># again, these integrals will be explained properly in the next cell</span>
                    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">xi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="n">j_local</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>           
                    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">xi</span><span class="p">)</span>
            <span class="c1"># add in the local contribution to the global mass matrix</span>
            <span class="n">M</span><span class="p">[</span><span class="n">i_global</span><span class="p">,</span><span class="n">j_global</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">*</span> <span class="n">simpsons_rule</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M = &#39;</span><span class="p">)</span>       
<span class="n">pprint</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RHS = &#39;</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">RHS</span><span class="p">)</span>

<span class="n">approx_CG</span> <span class="o">=</span> <span class="n">sl</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">RHS</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">approx_CG = &#39;</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">approx_CG</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Function approximation&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="c1"># plot the exact function on a fine mesh</span>
<span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_fine</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;exact&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">approx_CG</span> <span class="p">,</span> <span class="s1">&#39;ro-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;p/w linear cts projection&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>M = 
array([[0.111, 0.056, 0.   , 0.   ],
       [0.056, 0.222, 0.056, 0.   ],
       [0.   , 0.056, 0.222, 0.056],
       [0.   , 0.   , 0.056, 0.111]])

RHS = 
array([ 0.137,  0.197, -0.199, -0.092])

approx_CG = 
array([ 0.748,  0.967, -1.061, -0.302])
</pre></div>
</div>
<img alt="../_images/a33bc641b0a8f15fd2326fbedacd0ade80d0a4bd2abc07d09009d8d0c94e4493.png" src="../_images/a33bc641b0a8f15fd2326fbedacd0ade80d0a4bd2abc07d09009d8d0c94e4493.png" />
</div>
</div>
</section>
<section id="quadrature-over-the-local-element-change-of-variables-to-a-reference-element">
<h2>Quadrature over the local element (change of variables to a reference element)<a class="headerlink" href="#quadrature-over-the-local-element-change-of-variables-to-a-reference-element" title="Permalink to this heading">#</a></h2>
<p>We’ve played one final trick in the implementation above.</p>
<p>It turns out that, especially in higher dimensions and for more complicated basis functions, that it is advantageous to transform our integrals over each individual element (which each could be a different shape and size) so that they are all performed over the same “reference” element.</p>
<p>Consider the schematic below.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/reference_elements_1d.svg"><img alt="../_images/reference_elements_1d.svg" src="../_images/reference_elements_1d.svg" width="75%" /></a>
</figure>
<br>
<p>The left part shows the mesh in the real physical coordinate we want to compute our solution over; the right shows the reference element we compute integrals over, with the mappings between the two also indicated.</p>
</section>
<section id="transformation-to-the-reference-element">
<h2>Transformation to the reference element<a class="headerlink" href="#transformation-to-the-reference-element" title="Permalink to this heading">#</a></h2>
<p>It is common to define the reference element in 1D to be either <span class="math notranslate nohighlight">\(\,e_\text{ref}:=[0,1]\,\)</span> or <span class="math notranslate nohighlight">\(\,e_\text{ref}:=[-1,1]\,\)</span>.</p>
<p>As per the schematic we shall choose the latter option.</p>
<p>We use <span class="math notranslate nohighlight">\(\,\xi\,\)</span> as the notation of the coordinate over the reference element.</p>
<p>We can then define the linear mapping between the physical <span class="math notranslate nohighlight">\(\,x\in[x_L, x_R]\,\)</span> and the reference element <span class="math notranslate nohighlight">\(\,\xi\in[-1,1]\,\)</span> via</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*} 
x &amp;= \frac{1}{2}\left(x_L+x_R\right) + \frac{1}{2}\left(x_R - x_L\right)\xi \\[5pt]
&amp;= \frac{1}{2}\left(x_L+x_R\right) + \frac{1}{2}\Delta x\,\xi.
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\,\Delta x = x_R-x_L\,\)</span> is the <em>local</em> mesh size.</p>
<p>Integrals over a physical element <span class="math notranslate nohighlight">\(\,e_i\,\)</span> can then be computed as in the following example of a mass matrix entry:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\int_{e_i} \,\phi_{i}(x)\,\phi_{i}(x)\, dx 
&amp;\equiv 
\int_{x_i}^{x_{i+1}} \,\phi_{i}(x)\,\phi_{i}(x)\, dx \\[10pt]
&amp; = 
\int_{-1}^{1} \,\phi_{i}(\xi)\,\phi_{i}(\xi)\, |J| \, d\xi\\[10pt]
&amp; \equiv 
\int_{e_{\text{ref}}} \,\phi_{i}(\xi)\,\phi_{i}(\xi)\, |J| \, d\xi
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(|J|\)</span> is the Jacobian determinant which we always need to remember to include when we perform a <a class="reference external" href="http://mathworld.wolfram.com/ChangeofVariablesTheorem.html"><em>change of variables in an integral</em></a>.</p>
<p>In our case</p>
<div class="math notranslate nohighlight">
\[ J = \frac{dx}{d\xi} = \frac{1}{2}\Delta x,\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta x\)</span> is understood to be the local element size.</p>
<p>We need to consider how the basis functions <span class="math notranslate nohighlight">\(\phi_i\)</span> and <span class="math notranslate nohighlight">\(\phi_{i+1}\)</span> are defined in terms of the variable <span class="math notranslate nohighlight">\(\xi\)</span>, i.e. what they look like in the reference element. But this is simple as we know for linear basis functions they are 1 at one node, 0 at the other, and linear in between. The two basis functions on the reference element are therefore in the linear case simply</p>
<div class="math notranslate nohighlight">
\[ \phi_0(\xi) := \frac{1}{2}( 1 - \xi),\;\;\;\;\;\;\;\; \phi_1(\xi) := \frac{1}{2}( 1 + \xi), \]</div>
<p>where the subscripts 0 and 1 refer to the <em>local</em> node number on the element.</p>
<p>These take a particularly simple form; this is one of the advantages of the reference element approach and extends to higher order elements.</p>
<p>This is why in the code above we defined one of the integrands to be</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">integrand</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">xi:</span> <span class="pre">0.5*(1-xi)</span> <span class="pre">*</span> <span class="pre">0.5*(1-xi)</span></code></p>
</div></blockquote>
<p>and multiplied through by half the element size after computing the integral of this over the interval <span class="math notranslate nohighlight">\([-1,1]\)</span>:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">M[i_global,j_global]</span> <span class="pre">+=</span> <span class="pre">0.5*dx[element]</span> <span class="pre">*</span> <span class="pre">simpsons_rule(-1,</span> <span class="pre">1,</span> <span class="pre">integrand,</span> <span class="pre">1</span> <span class="pre">)</span></code></p>
</div></blockquote>
<p>and for the RHS vector why the source function argument takes the form:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">f(</span> <span class="pre">(x_nodes[i_global]</span> <span class="pre">+</span> <span class="pre">0.5*dx[element])</span> <span class="pre">+</span> <span class="pre">0.5*dx[element]*xi</span> <span class="pre">)</span> </code></p>
</div></blockquote>
<p>where we use the fact that <span class="math notranslate nohighlight">\(\frac{1}{2}\left(x_L+x_R\right)+ \frac{1}{2}\Delta x\,\xi= \left(x_L + \frac{1}{2}\Delta x\right) + \frac{1}{2}\Delta x\,\xi\)</span>.</p>
<section id="aside-quadratic-basis-functions">
<h3>Aside: quadratic basis functions<a class="headerlink" href="#aside-quadratic-basis-functions" title="Permalink to this heading">#</a></h3>
<p>As a further example let’s consider what quadratic basis functions would look like, and how easily they can be defined, on the reference element:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">h_pad</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\xi$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Linear basis functions </span><span class="se">\n</span><span class="s1">over the reference element&#39;</span><span class="p">,</span> 
              <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="c1"># the two linear basis functions</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\phi_0$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\phi_1$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\xi$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Quadratic basis functions </span><span class="se">\n</span><span class="s1">over the reference element&#39;</span><span class="p">,</span> 
              <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="c1"># the three quadratic basis functions</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\phi_0$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\phi_1$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\phi_2$&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f42e48757c0&gt;
</pre></div>
</div>
<img alt="../_images/fba9a9ecf301958c4e973253e5bfa4c5dfbf2529dfb8d42a7a986f104129b734.png" src="../_images/fba9a9ecf301958c4e973253e5bfa4c5dfbf2529dfb8d42a7a986f104129b734.png" />
</div>
</div>
<p><strong>The mass matrix</strong></p>
<p>Following through the example case of the mass matrix and p/w linear basis functions we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\int_{e_i} \,\phi_{i}(x)\,\phi_{i}(x)\, dx 
&amp;\equiv 
\int_{x_i}^{x_{i+1}} \,\phi_{i}(x)\,\phi_{i}(x)\, dx \\[10pt]
&amp; = 
\int_{-1}^{1} \,\phi_{0}(\xi)\,\phi_{0}(\xi)\, |J| \, d\xi\\[10pt]
&amp; = \int_{-1}^{1} \, \frac{1}{2}( 1 - \xi) \, \frac{1}{2}( 1 - \xi) \, \frac{\Delta x_i}{2} \, d\xi
\\[10pt]
&amp; = \frac{\Delta x_i}{8} \int_{-1}^{1} \, ( 1 - \xi)^2 \,  d\xi
\\[10pt]
&amp; = \frac{\Delta x_i}{8} \left[ -\frac{1}{3}( 1 - \xi)^3 \right]_{-1}^{1}
\\[10pt]
&amp; = \frac{\Delta x_i}{8} \left[ -\frac{1}{3}( 1 - 1)^3  + \frac{1}{3}( 1 - (-1))^3\right]
\\[10pt]
&amp; = \frac{\Delta x_i}{3}, 
\end{align*}
\end{split}\]</div>
<p>which agrees with what we’ve computed before (which of course it should do!).</p>
<p>The other entries we need follow similarly:</p>
<div class="math notranslate nohighlight">
\[
\int_{e_i} \,\phi_{i+1}(x)\,\phi_{i+1}(x)\, dx =  \frac{\Delta x_i}{3},
\]</div>
<div class="math notranslate nohighlight">
\[
\int_{e_i} \,\phi_{i}(x)\,\phi_{i+1}(x)\, dx =  \frac{\Delta x_i}{6}.
\]</div>
<p><strong>The load vector</strong></p>
<p>For contributions to the load vector of the form</p>
<div class="math notranslate nohighlight">
\[ \int_{e_{i}}\,f(x)\,\phi_i(x)\, dx \equiv \int_{x_{i}}^{x_{i+1}} \,f(x)\,\phi_i(x)\, dx,\]</div>
<p>we actually compute over the reference element the following</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}
\begin{align*} 
\int_{x_{i}}^{x_{i+1}} \,f(x)\,\phi_i(x)\, dx
&amp; = \int_{-1}^{1} \,f(x(\xi))\,\phi_0(\xi)\, \frac{\Delta x}{2} \, d\xi \\[10pt]
&amp; = \frac{\Delta x}{2}
\int_{-1}^{1} \,f\left( \frac{1}{2}\left(x_L+x_R\right) + \frac{1}{2}\Delta x\,\xi \right) \,\frac{1}{2}( 1 - \xi) \, d\xi,
\end{align*}\end{split}\\where $\phi_0$ refers to the &quot;first&quot; basis function **on the reference element** (over element $e_i$ it would be $\phi_{i+1}(x)$ that corresponds to the local basis function $\phi_1(\xi)$).
\end{aligned}\end{align} \]</div>
</section>
</section>
<section id="local-assembly-for-integrands-that-involve-derivatives">
<h2>Local assembly for integrands that involve derivatives<a class="headerlink" href="#local-assembly-for-integrands-that-involve-derivatives" title="Permalink to this heading">#</a></h2>
<p>So now we know how to assemble the contributions which feed into the mass matrix and the RHS load vector.</p>
<p>The final issue we need to consider is how to deal with derivatives of basis functions.</p>
<p>For example, from the BVP section earlier we know that we needed to consider integrals of the form</p>
<div class="math notranslate nohighlight">
\[\int_0^1 \phi_j'\, \phi_i' \,dx,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\phi_i' \equiv \frac{d}{dx}\phi_i(x).\]</div>
<p>When transformed to the reference element we are therefore going to need to evaluate the <span class="math notranslate nohighlight">\(x\)</span> derivative of the transformed basis functions, e.g.</p>
<div class="math notranslate nohighlight">
\[\frac{d}{dx}\phi_0(\xi) 
\;\;\;\;\;\;\; \text{where}\;\;\;\;\; \;\;\; 
\phi_0(\xi):=\frac{1}{2}( 1 - \xi).\]</div>
<p>How do we do this?  Via the chain rule:</p>
<div class="math notranslate nohighlight">
\[\frac{d}{dx}\phi_0(\xi) = \frac{d}{d\xi}\phi_0(\xi)\, \frac{d\xi}{dx} = \phi'_0(\xi)\, \frac{d\xi}{dx},\]</div>
<p>and we know that</p>
<div class="math notranslate nohighlight">
\[ \frac{d\xi}{dx} = \left( \frac{dx}{d\xi} \right)^{-1} = \frac{2}{\Delta x}
\qquad\text{as}\quad 
x = \frac{1}{2}\left(x_L+x_R\right) + \frac{1}{2}\Delta x\,\xi,
\]</div>
<p>and for our linear basis functions</p>
<div class="math notranslate nohighlight">
\[\phi'_0(\xi) = -\frac{1}{2}\;\;\;\;\;\;\;\; \text{and}\;\;\;\;\;\;\;\; 
\phi'_1(\xi) = \frac{1}{2}.\]</div>
<p>In higher dimensions we have something similar, we just need to make use of the Jacobian matrix.</p>
</section>
<section id="using-the-fem-to-solve-time-dependent-pdes">
<h2>Using the FEM to solve time-dependent PDEs<a class="headerlink" href="#using-the-fem-to-solve-time-dependent-pdes" title="Permalink to this heading">#</a></h2>
<p>Whether or not we use the local assembly approach, or the first approach we encountered for BVPs, to construct the discretisation matrices,
we now have all we need to implement a FEM based solver for pretty much any PDE in any spatial dimension.</p>
<br>
<p>But how do we deal with time-dependent problems, i.e. with time derivatives?</p>
<br>
<p>Consider time-dependent diffusion written in the form</p>
<div class="math notranslate nohighlight">
\[\frac{\partial u}{\partial t} = \kappa\frac{\partial^2 u}{\partial x^2}, \]</div>
<p>and assuming for simplicity that the diffusivity <span class="math notranslate nohighlight">\(\kappa\)</span> is constant.</p>
<p>The weak/variational form of this problem can be written as (ignoring boundary terms)</p>
<div class="math notranslate nohighlight">
\[ \int_I \,\frac{\partial u}{\partial t}\,v\,dx + \kappa\int_I \,u'\,v'\,dx = 0, \;\;\;\;\forall \;\; v\in V.\]</div>
<p>Substituting in our approximate solution function</p>
<div class="math notranslate nohighlight">
\[u_h(x,t) := \sum_{j=0}^{n} u_j(t)\,\phi_j(x),\]</div>
<p>and restricting the test functions to the appropriate finite-dimensional space (<span class="math notranslate nohighlight">\(v\in V_h\)</span> with a basis given by <span class="math notranslate nohighlight">\(\phi_i\)</span>) yields the discrete system</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*} 
\sum_{j=0}^{n} \,\frac{\partial u_j}{\partial t}\, \int_0^1 \phi_j\, \phi_i \,dx  +  \kappa\sum_{j=0}^{n} u_j\, \int_0^1 \phi_j'\, \phi_i' \,dx &amp;= 0\;\;\;\;\; \text{for}\;\;\;\; i = 0, 1,\ldots, n \\[10pt]
\iff
\sum_{j=0}^{n} \,\frac{d u_j}{d t} M_{ij} + \kappa\sum_{j=0}^{n} u_j\, K_{ij} &amp;= 0, \;\;\;\;\; \text{for}\;\;\;\; i = 0, 1,\ldots, n.
\end{align*}
\end{split}\]</div>
<p>Or in matrix form</p>
<div class="math notranslate nohighlight">
\[
M\, \frac{d \boldsymbol{u}}{d t} + \kappa\, K\,\boldsymbol{u} = \boldsymbol{0},
\]</div>
<p>where <span class="math notranslate nohighlight">\(K\)</span> is the discretisation matrix for diffusion we saw previously, and <span class="math notranslate nohighlight">\(M\)</span> is the mass matrix. Note that at this stage we have semi-discretised in space using the “method of lines” approach we saw previously when solving PDEs using the FDM.</p>
<p>To discretise in time we simply replace the time derivative with a finite difference approximation (or indeed any of the range of ODE solvers/libraries we have seen).</p>
<p>Suppose we want to implement the “theta” method (to give us the flexibility to choose forward Euler, backward Euler or Crank-Nicolson), then we have to consider the system</p>
<div class="math notranslate nohighlight">
\[
M \,\frac{\boldsymbol{u}^{n+1} - \boldsymbol{u}^{n}}{\Delta t} + \kappa\, K\,\left(\theta \left(\boldsymbol{u}^{n+1} + (1-\theta)\boldsymbol{u}^{n}\right)\right) = \boldsymbol{0},
\]</div>
<p>which can be rearranged to</p>
<div class="math notranslate nohighlight">
\[ \left( M + \theta\,\Delta t \,\kappa\, K \right)  \boldsymbol{u}^{n+1} = \left( M - (1-\theta)\, \Delta t \,\kappa\, K \right) \boldsymbol{u}^{n}.\]</div>
<br>
<p>But this is just a matrix system for the solution at the new time level we can solve using linear solvers.</p>
</section>
<section id="higher-dimensions-and-unstructured-meshes">
<h2>Higher dimensions and unstructured meshes<a class="headerlink" href="#higher-dimensions-and-unstructured-meshes" title="Permalink to this heading">#</a></h2>
<p>In 1D we could form a basis for the space of piecewise linear continuous functions, from “hat” (or “tent”) functions that take the value unity at a single node, and are zero at all others, e.g.:</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/hat-function-1d.png"><img alt="../_images/hat-function-1d.png" src="../_images/hat-function-1d.png" style="width: 50%;" /></a>
</figure>
<p>In two dimension we do exactly the same. This is what it looks like:</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/hat-function-2d.svg"><img alt="../_images/hat-function-2d.svg" src="../_images/hat-function-2d.svg" width="50%" /></a>
</figure>
<p><sup><strong><a class="reference external" href="http://brickisland.net/cs177/?p=309">source</a></strong></sup></p>
<p>As you can see the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is 1 at the node <span class="math notranslate nohighlight">\(i\)</span> and linearly decreases to 0 over the adjacent triangles. Anywhere else <span class="math notranslate nohighlight">\(\phi_i\)</span> is 0.</p>
<p>Just like in 1D, we can write any piecewise linear function as a linear combination of such basis functions:</p>
<div class="math notranslate nohighlight">
\[f_h(x) = \sum_{i=0}^N \alpha_i \phi_i(x). \]</div>
<p>It is also possible to allow for higher degree polynomials. For piecewise <em>quadratic</em> polynomials, we need the function value at six locations in each triangle. A common choice is to use the same three vertices of the triangle as with p/w linears, as well as three additional nodes located at the middle of each edge.</p>
<p>We can also choose to allow polynomials that are <em>discontinous</em> between adjacent triangles. The “hat” basis functions displayed above are continuous, and thus the linear combination of these are continuous as well. By choosing basis functions that are nonzero over a single triangle only, i.e. it takes the value of one at one vertex <em>inside</em> the triangle, but jumps to zero immediately outside the triangle, we can form discontinuous functions as well. The choice between continuous and discontinuous basis functions leads to the so-called Continuous Galerkin (CG) and Discontinuous Galerkin (DG) methods</p>
<img src="https://mathstats.uncg.edu/applied/wp-content/uploads/sites/2/2018/01/DG_CG_edit.jpg">
<p><sup><strong><a class="reference external" href="https://mathstats.uncg.edu/applied/wp-content/uploads/sites/2/2018/01/DG_CG_edit.jpg">source</a></strong></sup></p>
<br>
<p>Finally, we should note that we do not <em>have to</em> use triangular (or tetrahedral in 3D) meshes for the FEM. Quadrilateral meshes are another possibility where we can for instance choose piecewise <em>bilinear</em> basis functions.  In practice we can use any shape element as long as we can represent the appropriate
basis functions and perform integrals over that shape with ease.</p>
</section>
<section id="final-comments">
<h2>Final comments<a class="headerlink" href="#final-comments" title="Permalink to this heading">#</a></h2>
<p>That might have all seemed like a lot of work (to essentially arrive at something not completely  dis-similar to what FDM could do) with a lot of additional steps and computational overhead (e.g. all those quadratures we did not need with FDM).</p>
<p>The power of the FEM really comes into play when</p>
<ol class="arabic simple">
<li><p>we move to higher dimensions, and/or</p></li>
<li><p>we use more exotic basis functions, and/or</p></li>
<li><p>we want to make use of some of the theoretical properties that can be established with the FEM, e.g. rigorous error estimators that can be used to guide adaptive mesh algorithms to achieve accuracy and efficiency.</p></li>
</ol>
<br>
<p>An important final thing for you to understand is how we would go about discretising more complex equations - to help with this a homework questions asks you to consider the problem <span class="math notranslate nohighlight">\(u''+u=f\)</span>.</p>
</section>
<section id="the-perodic-table-of-finite-elements">
<h2>The perodic table of finite elements<a class="headerlink" href="#the-perodic-table-of-finite-elements" title="Permalink to this heading">#</a></h2>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/femtable.png"><img alt="../_images/femtable.png" src="../_images/femtable.png" style="width: 75%;" /></a>
</figure>
<p>for more details see <a class="reference external" href="http://www-users.math.umn.edu/~arnold/femtable/">http://www-users.math.umn.edu/~arnold/femtable/</a></p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Chapter12"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">12. Finite Element Methods</p>
      </div>
    </a>
    <a class="right-next"
       href="Homework.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Homework <a class="tocSkip"></p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Imperial College London
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>